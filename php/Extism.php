<?php use double;
interface iExtism {}
interface iExtism_ptr {}
/**
 * @property int $__mb_cur_max
 * @property string_ $suboptarg
 */
class Extism {
    const SOFILE = '/usr/local/lib/libextism.dylib';
    const TYPES_DEF = 'typedef __builtin_va_list va_list;
typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;
typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;
typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
typedef int __darwin_ct_rune_t;
typedef union {
  char __mbstate8[128];
  long long _mbstateL;
} __mbstate_t;
typedef __mbstate_t __darwin_mbstate_t;
typedef long int __darwin_ptrdiff_t;
typedef long unsigned int __darwin_size_t;
typedef __builtin_va_list __darwin_va_list;
typedef int __darwin_wchar_t;
typedef __darwin_wchar_t __darwin_rune_t;
typedef unsigned int __darwin_wint_t;
typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;
typedef __darwin_ino64_t __darwin_ino_t;
typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];
struct __darwin_pthread_handler_rec {
  void (*__routine)(void *);
  void *__arg;
  struct __darwin_pthread_handler_rec *__next;
};
struct _opaque_pthread_attr_t {
  long __sig;
  char __opaque[56];
};
struct _opaque_pthread_cond_t {
  long __sig;
  char __opaque[40];
};
struct _opaque_pthread_condattr_t {
  long __sig;
  char __opaque[8];
};
struct _opaque_pthread_mutex_t {
  long __sig;
  char __opaque[56];
};
struct _opaque_pthread_mutexattr_t {
  long __sig;
  char __opaque[8];
};
struct _opaque_pthread_once_t {
  long __sig;
  char __opaque[8];
};
struct _opaque_pthread_rwlock_t {
  long __sig;
  char __opaque[192];
};
struct _opaque_pthread_rwlockattr_t {
  long __sig;
  char __opaque[16];
};
struct _opaque_pthread_t {
  long __sig;
  struct __darwin_pthread_handler_rec *__cleanup_stack;
  char __opaque[8176];
};
typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t *__darwin_pthread_t;
typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned int u_int32_t;
typedef unsigned long long u_int64_t;
typedef int64_t register_t;
typedef unsigned long uintptr_t;
typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;
typedef u_int64_t syscall_arg_t;
typedef __darwin_intptr_t intptr_t;
typedef long int intmax_t;
typedef long unsigned int uintmax_t;
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;
typedef __uint32_t __darwin_wctype_t;
typedef enum {
  P_ALL,
  P_PID,
  P_PGID,
} idtype_t;
typedef __darwin_pid_t pid_t;
typedef __darwin_id_t id_t;
typedef int sig_atomic_t;
struct __darwin_i386_thread_state {
  unsigned int __eax;
  unsigned int __ebx;
  unsigned int __ecx;
  unsigned int __edx;
  unsigned int __edi;
  unsigned int __esi;
  unsigned int __ebp;
  unsigned int __esp;
  unsigned int __ss;
  unsigned int __eflags;
  unsigned int __eip;
  unsigned int __cs;
  unsigned int __ds;
  unsigned int __es;
  unsigned int __fs;
  unsigned int __gs;
};
struct __darwin_fp_control {
  unsigned short __invalid :1;
  unsigned short __denorm :1;
  unsigned short __zdiv :1;
  unsigned short __ovrfl :1;
  unsigned short __undfl :1;
  unsigned short __precis :1;
  unsigned short :2;
  unsigned short __pc :2;
  unsigned short __rc :2;
  unsigned short :1;
  unsigned short :3;
};
typedef struct __darwin_fp_control __darwin_fp_control_t;
struct __darwin_fp_status {
  unsigned short __invalid :1;
  unsigned short __denorm :1;
  unsigned short __zdiv :1;
  unsigned short __ovrfl :1;
  unsigned short __undfl :1;
  unsigned short __precis :1;
  unsigned short __stkflt :1;
  unsigned short __errsumm :1;
  unsigned short __c0 :1;
  unsigned short __c1 :1;
  unsigned short __c2 :1;
  unsigned short __tos :3;
  unsigned short __c3 :1;
  unsigned short __busy :1;
};
typedef struct __darwin_fp_status __darwin_fp_status_t;
struct __darwin_mmst_reg {
  char __mmst_reg[10];
  char __mmst_rsrv[6];
};
struct __darwin_xmm_reg {
  char __xmm_reg[16];
};
struct __darwin_ymm_reg {
  char __ymm_reg[32];
};
struct __darwin_zmm_reg {
  char __zmm_reg[64];
};
struct __darwin_opmask_reg {
  char __opmask_reg[8];
};
struct __darwin_i386_float_state {
  int __fpu_reserved[2];
  struct __darwin_fp_control __fpu_fcw;
  struct __darwin_fp_status __fpu_fsw;
  __uint8_t __fpu_ftw;
  __uint8_t __fpu_rsrv1;
  __uint16_t __fpu_fop;
  __uint32_t __fpu_ip;
  __uint16_t __fpu_cs;
  __uint16_t __fpu_rsrv2;
  __uint32_t __fpu_dp;
  __uint16_t __fpu_ds;
  __uint16_t __fpu_rsrv3;
  __uint32_t __fpu_mxcsr;
  __uint32_t __fpu_mxcsrmask;
  struct __darwin_mmst_reg __fpu_stmm0;
  struct __darwin_mmst_reg __fpu_stmm1;
  struct __darwin_mmst_reg __fpu_stmm2;
  struct __darwin_mmst_reg __fpu_stmm3;
  struct __darwin_mmst_reg __fpu_stmm4;
  struct __darwin_mmst_reg __fpu_stmm5;
  struct __darwin_mmst_reg __fpu_stmm6;
  struct __darwin_mmst_reg __fpu_stmm7;
  struct __darwin_xmm_reg __fpu_xmm0;
  struct __darwin_xmm_reg __fpu_xmm1;
  struct __darwin_xmm_reg __fpu_xmm2;
  struct __darwin_xmm_reg __fpu_xmm3;
  struct __darwin_xmm_reg __fpu_xmm4;
  struct __darwin_xmm_reg __fpu_xmm5;
  struct __darwin_xmm_reg __fpu_xmm6;
  struct __darwin_xmm_reg __fpu_xmm7;
  char __fpu_rsrv4[(14 * 16)];
  int __fpu_reserved1;
};
struct __darwin_i386_avx_state {
  int __fpu_reserved[2];
  struct __darwin_fp_control __fpu_fcw;
  struct __darwin_fp_status __fpu_fsw;
  __uint8_t __fpu_ftw;
  __uint8_t __fpu_rsrv1;
  __uint16_t __fpu_fop;
  __uint32_t __fpu_ip;
  __uint16_t __fpu_cs;
  __uint16_t __fpu_rsrv2;
  __uint32_t __fpu_dp;
  __uint16_t __fpu_ds;
  __uint16_t __fpu_rsrv3;
  __uint32_t __fpu_mxcsr;
  __uint32_t __fpu_mxcsrmask;
  struct __darwin_mmst_reg __fpu_stmm0;
  struct __darwin_mmst_reg __fpu_stmm1;
  struct __darwin_mmst_reg __fpu_stmm2;
  struct __darwin_mmst_reg __fpu_stmm3;
  struct __darwin_mmst_reg __fpu_stmm4;
  struct __darwin_mmst_reg __fpu_stmm5;
  struct __darwin_mmst_reg __fpu_stmm6;
  struct __darwin_mmst_reg __fpu_stmm7;
  struct __darwin_xmm_reg __fpu_xmm0;
  struct __darwin_xmm_reg __fpu_xmm1;
  struct __darwin_xmm_reg __fpu_xmm2;
  struct __darwin_xmm_reg __fpu_xmm3;
  struct __darwin_xmm_reg __fpu_xmm4;
  struct __darwin_xmm_reg __fpu_xmm5;
  struct __darwin_xmm_reg __fpu_xmm6;
  struct __darwin_xmm_reg __fpu_xmm7;
  char __fpu_rsrv4[(14 * 16)];
  int __fpu_reserved1;
  char __avx_reserved1[64];
  struct __darwin_xmm_reg __fpu_ymmh0;
  struct __darwin_xmm_reg __fpu_ymmh1;
  struct __darwin_xmm_reg __fpu_ymmh2;
  struct __darwin_xmm_reg __fpu_ymmh3;
  struct __darwin_xmm_reg __fpu_ymmh4;
  struct __darwin_xmm_reg __fpu_ymmh5;
  struct __darwin_xmm_reg __fpu_ymmh6;
  struct __darwin_xmm_reg __fpu_ymmh7;
};
struct __darwin_i386_avx512_state {
  int __fpu_reserved[2];
  struct __darwin_fp_control __fpu_fcw;
  struct __darwin_fp_status __fpu_fsw;
  __uint8_t __fpu_ftw;
  __uint8_t __fpu_rsrv1;
  __uint16_t __fpu_fop;
  __uint32_t __fpu_ip;
  __uint16_t __fpu_cs;
  __uint16_t __fpu_rsrv2;
  __uint32_t __fpu_dp;
  __uint16_t __fpu_ds;
  __uint16_t __fpu_rsrv3;
  __uint32_t __fpu_mxcsr;
  __uint32_t __fpu_mxcsrmask;
  struct __darwin_mmst_reg __fpu_stmm0;
  struct __darwin_mmst_reg __fpu_stmm1;
  struct __darwin_mmst_reg __fpu_stmm2;
  struct __darwin_mmst_reg __fpu_stmm3;
  struct __darwin_mmst_reg __fpu_stmm4;
  struct __darwin_mmst_reg __fpu_stmm5;
  struct __darwin_mmst_reg __fpu_stmm6;
  struct __darwin_mmst_reg __fpu_stmm7;
  struct __darwin_xmm_reg __fpu_xmm0;
  struct __darwin_xmm_reg __fpu_xmm1;
  struct __darwin_xmm_reg __fpu_xmm2;
  struct __darwin_xmm_reg __fpu_xmm3;
  struct __darwin_xmm_reg __fpu_xmm4;
  struct __darwin_xmm_reg __fpu_xmm5;
  struct __darwin_xmm_reg __fpu_xmm6;
  struct __darwin_xmm_reg __fpu_xmm7;
  char __fpu_rsrv4[(14 * 16)];
  int __fpu_reserved1;
  char __avx_reserved1[64];
  struct __darwin_xmm_reg __fpu_ymmh0;
  struct __darwin_xmm_reg __fpu_ymmh1;
  struct __darwin_xmm_reg __fpu_ymmh2;
  struct __darwin_xmm_reg __fpu_ymmh3;
  struct __darwin_xmm_reg __fpu_ymmh4;
  struct __darwin_xmm_reg __fpu_ymmh5;
  struct __darwin_xmm_reg __fpu_ymmh6;
  struct __darwin_xmm_reg __fpu_ymmh7;
  struct __darwin_opmask_reg __fpu_k0;
  struct __darwin_opmask_reg __fpu_k1;
  struct __darwin_opmask_reg __fpu_k2;
  struct __darwin_opmask_reg __fpu_k3;
  struct __darwin_opmask_reg __fpu_k4;
  struct __darwin_opmask_reg __fpu_k5;
  struct __darwin_opmask_reg __fpu_k6;
  struct __darwin_opmask_reg __fpu_k7;
  struct __darwin_ymm_reg __fpu_zmmh0;
  struct __darwin_ymm_reg __fpu_zmmh1;
  struct __darwin_ymm_reg __fpu_zmmh2;
  struct __darwin_ymm_reg __fpu_zmmh3;
  struct __darwin_ymm_reg __fpu_zmmh4;
  struct __darwin_ymm_reg __fpu_zmmh5;
  struct __darwin_ymm_reg __fpu_zmmh6;
  struct __darwin_ymm_reg __fpu_zmmh7;
};
struct __darwin_i386_exception_state {
  __uint16_t __trapno;
  __uint16_t __cpu;
  __uint32_t __err;
  __uint32_t __faultvaddr;
};
struct __darwin_x86_debug_state32 {
  unsigned int __dr0;
  unsigned int __dr1;
  unsigned int __dr2;
  unsigned int __dr3;
  unsigned int __dr4;
  unsigned int __dr5;
  unsigned int __dr6;
  unsigned int __dr7;
};
struct __x86_instruction_state {
  int __insn_stream_valid_bytes;
  int __insn_offset;
  int __out_of_synch;
  __uint8_t __insn_bytes[((2448 - 64) - 4)];
  __uint8_t __insn_cacheline[64];
};
struct __last_branch_record {
  __uint64_t __from_ip;
  __uint64_t __to_ip;
  __uint32_t __mispredict :1;
  __uint32_t __tsx_abort :1;
  __uint32_t __in_tsx :1;
  __uint32_t __cycle_count :16;
  __uint32_t __reserved :13;
};
struct __last_branch_state {
  int __lbr_count;
  __uint32_t __lbr_supported_tsx :1;
  __uint32_t __lbr_supported_cycle_count :1;
  __uint32_t __reserved :30;
  struct __last_branch_record __lbrs[32];
};
struct __x86_pagein_state {
  int __pagein_error;
};
struct __darwin_x86_thread_state64 {
  __uint64_t __rax;
  __uint64_t __rbx;
  __uint64_t __rcx;
  __uint64_t __rdx;
  __uint64_t __rdi;
  __uint64_t __rsi;
  __uint64_t __rbp;
  __uint64_t __rsp;
  __uint64_t __r8;
  __uint64_t __r9;
  __uint64_t __r10;
  __uint64_t __r11;
  __uint64_t __r12;
  __uint64_t __r13;
  __uint64_t __r14;
  __uint64_t __r15;
  __uint64_t __rip;
  __uint64_t __rflags;
  __uint64_t __cs;
  __uint64_t __fs;
  __uint64_t __gs;
};
struct __darwin_x86_thread_full_state64 {
  struct __darwin_x86_thread_state64 __ss64;
  __uint64_t __ds;
  __uint64_t __es;
  __uint64_t __ss;
  __uint64_t __gsbase;
};
struct __darwin_x86_float_state64 {
  int __fpu_reserved[2];
  struct __darwin_fp_control __fpu_fcw;
  struct __darwin_fp_status __fpu_fsw;
  __uint8_t __fpu_ftw;
  __uint8_t __fpu_rsrv1;
  __uint16_t __fpu_fop;
  __uint32_t __fpu_ip;
  __uint16_t __fpu_cs;
  __uint16_t __fpu_rsrv2;
  __uint32_t __fpu_dp;
  __uint16_t __fpu_ds;
  __uint16_t __fpu_rsrv3;
  __uint32_t __fpu_mxcsr;
  __uint32_t __fpu_mxcsrmask;
  struct __darwin_mmst_reg __fpu_stmm0;
  struct __darwin_mmst_reg __fpu_stmm1;
  struct __darwin_mmst_reg __fpu_stmm2;
  struct __darwin_mmst_reg __fpu_stmm3;
  struct __darwin_mmst_reg __fpu_stmm4;
  struct __darwin_mmst_reg __fpu_stmm5;
  struct __darwin_mmst_reg __fpu_stmm6;
  struct __darwin_mmst_reg __fpu_stmm7;
  struct __darwin_xmm_reg __fpu_xmm0;
  struct __darwin_xmm_reg __fpu_xmm1;
  struct __darwin_xmm_reg __fpu_xmm2;
  struct __darwin_xmm_reg __fpu_xmm3;
  struct __darwin_xmm_reg __fpu_xmm4;
  struct __darwin_xmm_reg __fpu_xmm5;
  struct __darwin_xmm_reg __fpu_xmm6;
  struct __darwin_xmm_reg __fpu_xmm7;
  struct __darwin_xmm_reg __fpu_xmm8;
  struct __darwin_xmm_reg __fpu_xmm9;
  struct __darwin_xmm_reg __fpu_xmm10;
  struct __darwin_xmm_reg __fpu_xmm11;
  struct __darwin_xmm_reg __fpu_xmm12;
  struct __darwin_xmm_reg __fpu_xmm13;
  struct __darwin_xmm_reg __fpu_xmm14;
  struct __darwin_xmm_reg __fpu_xmm15;
  char __fpu_rsrv4[(6 * 16)];
  int __fpu_reserved1;
};
struct __darwin_x86_avx_state64 {
  int __fpu_reserved[2];
  struct __darwin_fp_control __fpu_fcw;
  struct __darwin_fp_status __fpu_fsw;
  __uint8_t __fpu_ftw;
  __uint8_t __fpu_rsrv1;
  __uint16_t __fpu_fop;
  __uint32_t __fpu_ip;
  __uint16_t __fpu_cs;
  __uint16_t __fpu_rsrv2;
  __uint32_t __fpu_dp;
  __uint16_t __fpu_ds;
  __uint16_t __fpu_rsrv3;
  __uint32_t __fpu_mxcsr;
  __uint32_t __fpu_mxcsrmask;
  struct __darwin_mmst_reg __fpu_stmm0;
  struct __darwin_mmst_reg __fpu_stmm1;
  struct __darwin_mmst_reg __fpu_stmm2;
  struct __darwin_mmst_reg __fpu_stmm3;
  struct __darwin_mmst_reg __fpu_stmm4;
  struct __darwin_mmst_reg __fpu_stmm5;
  struct __darwin_mmst_reg __fpu_stmm6;
  struct __darwin_mmst_reg __fpu_stmm7;
  struct __darwin_xmm_reg __fpu_xmm0;
  struct __darwin_xmm_reg __fpu_xmm1;
  struct __darwin_xmm_reg __fpu_xmm2;
  struct __darwin_xmm_reg __fpu_xmm3;
  struct __darwin_xmm_reg __fpu_xmm4;
  struct __darwin_xmm_reg __fpu_xmm5;
  struct __darwin_xmm_reg __fpu_xmm6;
  struct __darwin_xmm_reg __fpu_xmm7;
  struct __darwin_xmm_reg __fpu_xmm8;
  struct __darwin_xmm_reg __fpu_xmm9;
  struct __darwin_xmm_reg __fpu_xmm10;
  struct __darwin_xmm_reg __fpu_xmm11;
  struct __darwin_xmm_reg __fpu_xmm12;
  struct __darwin_xmm_reg __fpu_xmm13;
  struct __darwin_xmm_reg __fpu_xmm14;
  struct __darwin_xmm_reg __fpu_xmm15;
  char __fpu_rsrv4[(6 * 16)];
  int __fpu_reserved1;
  char __avx_reserved1[64];
  struct __darwin_xmm_reg __fpu_ymmh0;
  struct __darwin_xmm_reg __fpu_ymmh1;
  struct __darwin_xmm_reg __fpu_ymmh2;
  struct __darwin_xmm_reg __fpu_ymmh3;
  struct __darwin_xmm_reg __fpu_ymmh4;
  struct __darwin_xmm_reg __fpu_ymmh5;
  struct __darwin_xmm_reg __fpu_ymmh6;
  struct __darwin_xmm_reg __fpu_ymmh7;
  struct __darwin_xmm_reg __fpu_ymmh8;
  struct __darwin_xmm_reg __fpu_ymmh9;
  struct __darwin_xmm_reg __fpu_ymmh10;
  struct __darwin_xmm_reg __fpu_ymmh11;
  struct __darwin_xmm_reg __fpu_ymmh12;
  struct __darwin_xmm_reg __fpu_ymmh13;
  struct __darwin_xmm_reg __fpu_ymmh14;
  struct __darwin_xmm_reg __fpu_ymmh15;
};
struct __darwin_x86_avx512_state64 {
  int __fpu_reserved[2];
  struct __darwin_fp_control __fpu_fcw;
  struct __darwin_fp_status __fpu_fsw;
  __uint8_t __fpu_ftw;
  __uint8_t __fpu_rsrv1;
  __uint16_t __fpu_fop;
  __uint32_t __fpu_ip;
  __uint16_t __fpu_cs;
  __uint16_t __fpu_rsrv2;
  __uint32_t __fpu_dp;
  __uint16_t __fpu_ds;
  __uint16_t __fpu_rsrv3;
  __uint32_t __fpu_mxcsr;
  __uint32_t __fpu_mxcsrmask;
  struct __darwin_mmst_reg __fpu_stmm0;
  struct __darwin_mmst_reg __fpu_stmm1;
  struct __darwin_mmst_reg __fpu_stmm2;
  struct __darwin_mmst_reg __fpu_stmm3;
  struct __darwin_mmst_reg __fpu_stmm4;
  struct __darwin_mmst_reg __fpu_stmm5;
  struct __darwin_mmst_reg __fpu_stmm6;
  struct __darwin_mmst_reg __fpu_stmm7;
  struct __darwin_xmm_reg __fpu_xmm0;
  struct __darwin_xmm_reg __fpu_xmm1;
  struct __darwin_xmm_reg __fpu_xmm2;
  struct __darwin_xmm_reg __fpu_xmm3;
  struct __darwin_xmm_reg __fpu_xmm4;
  struct __darwin_xmm_reg __fpu_xmm5;
  struct __darwin_xmm_reg __fpu_xmm6;
  struct __darwin_xmm_reg __fpu_xmm7;
  struct __darwin_xmm_reg __fpu_xmm8;
  struct __darwin_xmm_reg __fpu_xmm9;
  struct __darwin_xmm_reg __fpu_xmm10;
  struct __darwin_xmm_reg __fpu_xmm11;
  struct __darwin_xmm_reg __fpu_xmm12;
  struct __darwin_xmm_reg __fpu_xmm13;
  struct __darwin_xmm_reg __fpu_xmm14;
  struct __darwin_xmm_reg __fpu_xmm15;
  char __fpu_rsrv4[(6 * 16)];
  int __fpu_reserved1;
  char __avx_reserved1[64];
  struct __darwin_xmm_reg __fpu_ymmh0;
  struct __darwin_xmm_reg __fpu_ymmh1;
  struct __darwin_xmm_reg __fpu_ymmh2;
  struct __darwin_xmm_reg __fpu_ymmh3;
  struct __darwin_xmm_reg __fpu_ymmh4;
  struct __darwin_xmm_reg __fpu_ymmh5;
  struct __darwin_xmm_reg __fpu_ymmh6;
  struct __darwin_xmm_reg __fpu_ymmh7;
  struct __darwin_xmm_reg __fpu_ymmh8;
  struct __darwin_xmm_reg __fpu_ymmh9;
  struct __darwin_xmm_reg __fpu_ymmh10;
  struct __darwin_xmm_reg __fpu_ymmh11;
  struct __darwin_xmm_reg __fpu_ymmh12;
  struct __darwin_xmm_reg __fpu_ymmh13;
  struct __darwin_xmm_reg __fpu_ymmh14;
  struct __darwin_xmm_reg __fpu_ymmh15;
  struct __darwin_opmask_reg __fpu_k0;
  struct __darwin_opmask_reg __fpu_k1;
  struct __darwin_opmask_reg __fpu_k2;
  struct __darwin_opmask_reg __fpu_k3;
  struct __darwin_opmask_reg __fpu_k4;
  struct __darwin_opmask_reg __fpu_k5;
  struct __darwin_opmask_reg __fpu_k6;
  struct __darwin_opmask_reg __fpu_k7;
  struct __darwin_ymm_reg __fpu_zmmh0;
  struct __darwin_ymm_reg __fpu_zmmh1;
  struct __darwin_ymm_reg __fpu_zmmh2;
  struct __darwin_ymm_reg __fpu_zmmh3;
  struct __darwin_ymm_reg __fpu_zmmh4;
  struct __darwin_ymm_reg __fpu_zmmh5;
  struct __darwin_ymm_reg __fpu_zmmh6;
  struct __darwin_ymm_reg __fpu_zmmh7;
  struct __darwin_ymm_reg __fpu_zmmh8;
  struct __darwin_ymm_reg __fpu_zmmh9;
  struct __darwin_ymm_reg __fpu_zmmh10;
  struct __darwin_ymm_reg __fpu_zmmh11;
  struct __darwin_ymm_reg __fpu_zmmh12;
  struct __darwin_ymm_reg __fpu_zmmh13;
  struct __darwin_ymm_reg __fpu_zmmh14;
  struct __darwin_ymm_reg __fpu_zmmh15;
  struct __darwin_zmm_reg __fpu_zmm16;
  struct __darwin_zmm_reg __fpu_zmm17;
  struct __darwin_zmm_reg __fpu_zmm18;
  struct __darwin_zmm_reg __fpu_zmm19;
  struct __darwin_zmm_reg __fpu_zmm20;
  struct __darwin_zmm_reg __fpu_zmm21;
  struct __darwin_zmm_reg __fpu_zmm22;
  struct __darwin_zmm_reg __fpu_zmm23;
  struct __darwin_zmm_reg __fpu_zmm24;
  struct __darwin_zmm_reg __fpu_zmm25;
  struct __darwin_zmm_reg __fpu_zmm26;
  struct __darwin_zmm_reg __fpu_zmm27;
  struct __darwin_zmm_reg __fpu_zmm28;
  struct __darwin_zmm_reg __fpu_zmm29;
  struct __darwin_zmm_reg __fpu_zmm30;
  struct __darwin_zmm_reg __fpu_zmm31;
};
struct __darwin_x86_exception_state64 {
  __uint16_t __trapno;
  __uint16_t __cpu;
  __uint32_t __err;
  __uint64_t __faultvaddr;
};
struct __darwin_x86_debug_state64 {
  __uint64_t __dr0;
  __uint64_t __dr1;
  __uint64_t __dr2;
  __uint64_t __dr3;
  __uint64_t __dr4;
  __uint64_t __dr5;
  __uint64_t __dr6;
  __uint64_t __dr7;
};
struct __darwin_x86_cpmu_state64 {
  __uint64_t __ctrs[16];
};
struct __darwin_mcontext32 {
  struct __darwin_i386_exception_state __es;
  struct __darwin_i386_thread_state __ss;
  struct __darwin_i386_float_state __fs;
};
struct __darwin_mcontext_avx32 {
  struct __darwin_i386_exception_state __es;
  struct __darwin_i386_thread_state __ss;
  struct __darwin_i386_avx_state __fs;
};
struct __darwin_mcontext_avx512_32 {
  struct __darwin_i386_exception_state __es;
  struct __darwin_i386_thread_state __ss;
  struct __darwin_i386_avx512_state __fs;
};
struct __darwin_mcontext64 {
  struct __darwin_x86_exception_state64 __es;
  struct __darwin_x86_thread_state64 __ss;
  struct __darwin_x86_float_state64 __fs;
};
struct __darwin_mcontext64_full {
  struct __darwin_x86_exception_state64 __es;
  struct __darwin_x86_thread_full_state64 __ss;
  struct __darwin_x86_float_state64 __fs;
};
struct __darwin_mcontext_avx64 {
  struct __darwin_x86_exception_state64 __es;
  struct __darwin_x86_thread_state64 __ss;
  struct __darwin_x86_avx_state64 __fs;
};
struct __darwin_mcontext_avx64_full {
  struct __darwin_x86_exception_state64 __es;
  struct __darwin_x86_thread_full_state64 __ss;
  struct __darwin_x86_avx_state64 __fs;
};
struct __darwin_mcontext_avx512_64 {
  struct __darwin_x86_exception_state64 __es;
  struct __darwin_x86_thread_state64 __ss;
  struct __darwin_x86_avx512_state64 __fs;
};
struct __darwin_mcontext_avx512_64_full {
  struct __darwin_x86_exception_state64 __es;
  struct __darwin_x86_thread_full_state64 __ss;
  struct __darwin_x86_avx512_state64 __fs;
};
typedef struct __darwin_mcontext64 *mcontext_t;
typedef __darwin_pthread_attr_t pthread_attr_t;
struct __darwin_sigaltstack {
  void *ss_sp;
  __darwin_size_t ss_size;
  int ss_flags;
};
typedef struct __darwin_sigaltstack stack_t;
struct __darwin_ucontext {
  int uc_onstack;
  __darwin_sigset_t uc_sigmask;
  struct __darwin_sigaltstack uc_stack;
  struct __darwin_ucontext *uc_link;
  __darwin_size_t uc_mcsize;
  struct __darwin_mcontext64 *uc_mcontext;
};
typedef struct __darwin_ucontext ucontext_t;
typedef __darwin_sigset_t sigset_t;
typedef __darwin_uid_t uid_t;
union sigval {
  int sival_int;
  void *sival_ptr;
};
struct sigevent {
  int sigev_notify;
  int sigev_signo;
  union sigval sigev_value;
  void (*sigev_notify_function)(union sigval);
  pthread_attr_t *sigev_notify_attributes;
};
typedef struct __siginfo {
  int si_signo;
  int si_errno;
  int si_code;
  pid_t si_pid;
  uid_t si_uid;
  int si_status;
  void *si_addr;
  union sigval si_value;
  long si_band;
  unsigned long __pad[7];
} siginfo_t;
union __sigaction_u {
  void (*__sa_handler)(int);
  void (*__sa_sigaction)(int, struct __siginfo *, void *);
};
struct __sigaction {
  union __sigaction_u __sigaction_u;
  void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
  sigset_t sa_mask;
  int sa_flags;
};
struct sigaction {
  union __sigaction_u __sigaction_u;
  sigset_t sa_mask;
  int sa_flags;
};
typedef void (*sig_t)(int);
struct sigvec {
  void (*sv_handler)(int);
  int sv_mask;
  int sv_flags;
};
struct sigstack {
  char *ss_sp;
  int ss_onstack;
};
struct timeval {
  __darwin_time_t tv_sec;
  __darwin_suseconds_t tv_usec;
};
typedef __uint64_t rlim_t;
struct rusage {
  struct timeval ru_utime;
  struct timeval ru_stime;
  long ru_maxrss;
  long ru_ixrss;
  long ru_idrss;
  long ru_isrss;
  long ru_minflt;
  long ru_majflt;
  long ru_nswap;
  long ru_inblock;
  long ru_oublock;
  long ru_msgsnd;
  long ru_msgrcv;
  long ru_nsignals;
  long ru_nvcsw;
  long ru_nivcsw;
};
typedef void *rusage_info_t;
struct rusage_info_v0 {
  uint8_t ri_uuid[16];
  uint64_t ri_user_time;
  uint64_t ri_system_time;
  uint64_t ri_pkg_idle_wkups;
  uint64_t ri_interrupt_wkups;
  uint64_t ri_pageins;
  uint64_t ri_wired_size;
  uint64_t ri_resident_size;
  uint64_t ri_phys_footprint;
  uint64_t ri_proc_start_abstime;
  uint64_t ri_proc_exit_abstime;
};
struct rusage_info_v1 {
  uint8_t ri_uuid[16];
  uint64_t ri_user_time;
  uint64_t ri_system_time;
  uint64_t ri_pkg_idle_wkups;
  uint64_t ri_interrupt_wkups;
  uint64_t ri_pageins;
  uint64_t ri_wired_size;
  uint64_t ri_resident_size;
  uint64_t ri_phys_footprint;
  uint64_t ri_proc_start_abstime;
  uint64_t ri_proc_exit_abstime;
  uint64_t ri_child_user_time;
  uint64_t ri_child_system_time;
  uint64_t ri_child_pkg_idle_wkups;
  uint64_t ri_child_interrupt_wkups;
  uint64_t ri_child_pageins;
  uint64_t ri_child_elapsed_abstime;
};
struct rusage_info_v2 {
  uint8_t ri_uuid[16];
  uint64_t ri_user_time;
  uint64_t ri_system_time;
  uint64_t ri_pkg_idle_wkups;
  uint64_t ri_interrupt_wkups;
  uint64_t ri_pageins;
  uint64_t ri_wired_size;
  uint64_t ri_resident_size;
  uint64_t ri_phys_footprint;
  uint64_t ri_proc_start_abstime;
  uint64_t ri_proc_exit_abstime;
  uint64_t ri_child_user_time;
  uint64_t ri_child_system_time;
  uint64_t ri_child_pkg_idle_wkups;
  uint64_t ri_child_interrupt_wkups;
  uint64_t ri_child_pageins;
  uint64_t ri_child_elapsed_abstime;
  uint64_t ri_diskio_bytesread;
  uint64_t ri_diskio_byteswritten;
};
struct rusage_info_v3 {
  uint8_t ri_uuid[16];
  uint64_t ri_user_time;
  uint64_t ri_system_time;
  uint64_t ri_pkg_idle_wkups;
  uint64_t ri_interrupt_wkups;
  uint64_t ri_pageins;
  uint64_t ri_wired_size;
  uint64_t ri_resident_size;
  uint64_t ri_phys_footprint;
  uint64_t ri_proc_start_abstime;
  uint64_t ri_proc_exit_abstime;
  uint64_t ri_child_user_time;
  uint64_t ri_child_system_time;
  uint64_t ri_child_pkg_idle_wkups;
  uint64_t ri_child_interrupt_wkups;
  uint64_t ri_child_pageins;
  uint64_t ri_child_elapsed_abstime;
  uint64_t ri_diskio_bytesread;
  uint64_t ri_diskio_byteswritten;
  uint64_t ri_cpu_time_qos_default;
  uint64_t ri_cpu_time_qos_maintenance;
  uint64_t ri_cpu_time_qos_background;
  uint64_t ri_cpu_time_qos_utility;
  uint64_t ri_cpu_time_qos_legacy;
  uint64_t ri_cpu_time_qos_user_initiated;
  uint64_t ri_cpu_time_qos_user_interactive;
  uint64_t ri_billed_system_time;
  uint64_t ri_serviced_system_time;
};
struct rusage_info_v4 {
  uint8_t ri_uuid[16];
  uint64_t ri_user_time;
  uint64_t ri_system_time;
  uint64_t ri_pkg_idle_wkups;
  uint64_t ri_interrupt_wkups;
  uint64_t ri_pageins;
  uint64_t ri_wired_size;
  uint64_t ri_resident_size;
  uint64_t ri_phys_footprint;
  uint64_t ri_proc_start_abstime;
  uint64_t ri_proc_exit_abstime;
  uint64_t ri_child_user_time;
  uint64_t ri_child_system_time;
  uint64_t ri_child_pkg_idle_wkups;
  uint64_t ri_child_interrupt_wkups;
  uint64_t ri_child_pageins;
  uint64_t ri_child_elapsed_abstime;
  uint64_t ri_diskio_bytesread;
  uint64_t ri_diskio_byteswritten;
  uint64_t ri_cpu_time_qos_default;
  uint64_t ri_cpu_time_qos_maintenance;
  uint64_t ri_cpu_time_qos_background;
  uint64_t ri_cpu_time_qos_utility;
  uint64_t ri_cpu_time_qos_legacy;
  uint64_t ri_cpu_time_qos_user_initiated;
  uint64_t ri_cpu_time_qos_user_interactive;
  uint64_t ri_billed_system_time;
  uint64_t ri_serviced_system_time;
  uint64_t ri_logical_writes;
  uint64_t ri_lifetime_max_phys_footprint;
  uint64_t ri_instructions;
  uint64_t ri_cycles;
  uint64_t ri_billed_energy;
  uint64_t ri_serviced_energy;
  uint64_t ri_interval_max_phys_footprint;
  uint64_t ri_runnable_time;
};
struct rusage_info_v5 {
  uint8_t ri_uuid[16];
  uint64_t ri_user_time;
  uint64_t ri_system_time;
  uint64_t ri_pkg_idle_wkups;
  uint64_t ri_interrupt_wkups;
  uint64_t ri_pageins;
  uint64_t ri_wired_size;
  uint64_t ri_resident_size;
  uint64_t ri_phys_footprint;
  uint64_t ri_proc_start_abstime;
  uint64_t ri_proc_exit_abstime;
  uint64_t ri_child_user_time;
  uint64_t ri_child_system_time;
  uint64_t ri_child_pkg_idle_wkups;
  uint64_t ri_child_interrupt_wkups;
  uint64_t ri_child_pageins;
  uint64_t ri_child_elapsed_abstime;
  uint64_t ri_diskio_bytesread;
  uint64_t ri_diskio_byteswritten;
  uint64_t ri_cpu_time_qos_default;
  uint64_t ri_cpu_time_qos_maintenance;
  uint64_t ri_cpu_time_qos_background;
  uint64_t ri_cpu_time_qos_utility;
  uint64_t ri_cpu_time_qos_legacy;
  uint64_t ri_cpu_time_qos_user_initiated;
  uint64_t ri_cpu_time_qos_user_interactive;
  uint64_t ri_billed_system_time;
  uint64_t ri_serviced_system_time;
  uint64_t ri_logical_writes;
  uint64_t ri_lifetime_max_phys_footprint;
  uint64_t ri_instructions;
  uint64_t ri_cycles;
  uint64_t ri_billed_energy;
  uint64_t ri_serviced_energy;
  uint64_t ri_interval_max_phys_footprint;
  uint64_t ri_runnable_time;
  uint64_t ri_flags;
};
typedef struct rusage_info_v5 rusage_info_current;
struct rlimit {
  rlim_t rlim_cur;
  rlim_t rlim_max;
};
struct proc_rlimit_control_wakeupmon {
  uint32_t wm_flags;
  int32_t wm_rate;
};
union wait {
  int w_status;
  struct {
    unsigned int w_Termsig :7;
    unsigned int w_Coredump :1;
    unsigned int w_Retcode :8;
    unsigned int w_Filler :16;
  } w_T;
  struct {
    unsigned int w_Stopval :8;
    unsigned int w_Stopsig :8;
    unsigned int w_Filler :16;
  } w_S;
};
typedef __darwin_ct_rune_t ct_rune_t;
typedef __darwin_rune_t rune_t;
typedef __darwin_wchar_t wchar_t;
typedef struct {
  int quot;
  int rem;
} div_t;
typedef struct {
  long quot;
  long rem;
} ldiv_t;
typedef struct {
  long long quot;
  long long rem;
} lldiv_t;
typedef __darwin_dev_t dev_t;
typedef __darwin_mode_t mode_t;
typedef int32_t ExtismPlugin;
typedef uint64_t ExtismSize;
';
    const HEADER_DEF = self::TYPES_DEF . 'void *malloc(size_t __size);
void *calloc(size_t __count, size_t __size);
void free(void *);
void *realloc(void *__ptr, size_t __size);
int posix_memalign(void **__memptr, size_t __alignment, size_t __size);
void abort(void);
char *getenv(char *);
ExtismPlugin extism_plugin_register(uint8_t *wasm, ExtismSize wasm_size, _Bool with_wasi);
_Bool extism_plugin_config(ExtismPlugin plugin, uint8_t *json, ExtismSize json_size);
_Bool extism_function_exists(ExtismPlugin plugin, char *func_name);
int32_t extism_call(ExtismPlugin plugin_id, char *func_name, uint8_t *data, ExtismSize data_len);
char *extism_error(ExtismPlugin plugin);
ExtismSize extism_output_length(ExtismPlugin plugin);
void extism_output_get(ExtismPlugin plugin, uint8_t *buf, ExtismSize len);
_Bool extism_log_file(char *filename, char *log_level);
';
    private FFI $ffi;
    private static FFI $staticFFI;
    private array $__literalStrings = [];
    const __x86_64__ = 1;
    const __LP64__ = 1;
    const __GNUC_VA_LIST = 1;
    const __GNUC__ = 4;
    const __GNUC_MINOR__ = 2;
    const __STDC__ = 1;
    const __bool_true_false_are_defined = 1;
    const false = 0;
    const true = 1;
    const __WORDSIZE = 64;
    const __DARWIN_ONLY_64_BIT_INO_T = 0;
    const __DARWIN_ONLY_UNIX_CONFORMANCE = 1;
    const __DARWIN_ONLY_VERS_1050 = 0;
    const __DARWIN_UNIX03 = 1;
    const __DARWIN_64_BIT_INO_T = 1;
    const __DARWIN_VERS_1050 = 1;
    const __DARWIN_NON_CANCELABLE = 0;
    const __DARWIN_C_ANSI = 010000;
    const __DARWIN_C_FULL = 900000;
    const __STDC_WANT_LIB_EXT1__ = 1;
    const __DARWIN_NO_LONG_LONG = 0;
    const _DARWIN_FEATURE_64_BIT_INODE = 1;
    const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;
    const _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;
    const __PTHREAD_SIZE__ = 8176;
    const __PTHREAD_ATTR_SIZE__ = 56;
    const __PTHREAD_MUTEXATTR_SIZE__ = 8;
    const __PTHREAD_MUTEX_SIZE__ = 56;
    const __PTHREAD_CONDATTR_SIZE__ = 8;
    const __PTHREAD_COND_SIZE__ = 40;
    const __PTHREAD_ONCE_SIZE__ = 8;
    const __PTHREAD_RWLOCK_SIZE__ = 192;
    const __PTHREAD_RWLOCKATTR_SIZE__ = 16;
    const INT8_MAX = 127;
    const INT16_MAX = 32767;
    const INT32_MAX = 2147483647;
    const INT64_MAX = 9223372036854775807;
    const UINT8_MAX = 255;
    const UINT16_MAX = 65535;
    const UINT32_MAX = 4294967295;
    const UINT64_MAX = 18446744073709551615;
    const INTPTR_MAX = 9223372036854775807;
    const UINTPTR_MAX = 18446744073709551615;
    const WCHAR_MAX = 0x7fffffff;
    const __API_TO_BE_DEPRECATED = 100000;
    const __MAC_10_0 = 1000;
    const __MAC_10_1 = 1010;
    const __MAC_10_2 = 1020;
    const __MAC_10_3 = 1030;
    const __MAC_10_4 = 1040;
    const __MAC_10_5 = 1050;
    const __MAC_10_6 = 1060;
    const __MAC_10_7 = 1070;
    const __MAC_10_8 = 1080;
    const __MAC_10_9 = 1090;
    const __MAC_10_10 = 101000;
    const __MAC_10_10_2 = 101002;
    const __MAC_10_10_3 = 101003;
    const __MAC_10_11 = 101100;
    const __MAC_10_11_2 = 101102;
    const __MAC_10_11_3 = 101103;
    const __MAC_10_11_4 = 101104;
    const __MAC_10_12 = 101200;
    const __MAC_10_12_1 = 101201;
    const __MAC_10_12_2 = 101202;
    const __MAC_10_12_4 = 101204;
    const __MAC_10_13 = 101300;
    const __MAC_10_13_1 = 101301;
    const __MAC_10_13_2 = 101302;
    const __MAC_10_13_4 = 101304;
    const __MAC_10_14 = 101400;
    const __MAC_10_14_1 = 101401;
    const __MAC_10_14_4 = 101404;
    const __MAC_10_14_6 = 101406;
    const __MAC_10_15 = 101500;
    const __MAC_10_15_1 = 101501;
    const __MAC_10_15_4 = 101504;
    const __MAC_10_16 = 101600;
    const __MAC_11_0 = 110000;
    const __MAC_11_1 = 110100;
    const __MAC_11_3 = 110300;
    const __IPHONE_2_0 = 20000;
    const __IPHONE_2_1 = 20100;
    const __IPHONE_2_2 = 20200;
    const __IPHONE_3_0 = 30000;
    const __IPHONE_3_1 = 30100;
    const __IPHONE_3_2 = 30200;
    const __IPHONE_4_0 = 40000;
    const __IPHONE_4_1 = 40100;
    const __IPHONE_4_2 = 40200;
    const __IPHONE_4_3 = 40300;
    const __IPHONE_5_0 = 50000;
    const __IPHONE_5_1 = 50100;
    const __IPHONE_6_0 = 60000;
    const __IPHONE_6_1 = 60100;
    const __IPHONE_7_0 = 70000;
    const __IPHONE_7_1 = 70100;
    const __IPHONE_8_0 = 80000;
    const __IPHONE_8_1 = 80100;
    const __IPHONE_8_2 = 80200;
    const __IPHONE_8_3 = 80300;
    const __IPHONE_8_4 = 80400;
    const __IPHONE_9_0 = 90000;
    const __IPHONE_9_1 = 90100;
    const __IPHONE_9_2 = 90200;
    const __IPHONE_9_3 = 90300;
    const __IPHONE_10_0 = 100000;
    const __IPHONE_10_1 = 100100;
    const __IPHONE_10_2 = 100200;
    const __IPHONE_10_3 = 100300;
    const __IPHONE_11_0 = 110000;
    const __IPHONE_11_1 = 110100;
    const __IPHONE_11_2 = 110200;
    const __IPHONE_11_3 = 110300;
    const __IPHONE_11_4 = 110400;
    const __IPHONE_12_0 = 120000;
    const __IPHONE_12_1 = 120100;
    const __IPHONE_12_2 = 120200;
    const __IPHONE_12_3 = 120300;
    const __IPHONE_12_4 = 120400;
    const __IPHONE_13_0 = 130000;
    const __IPHONE_13_1 = 130100;
    const __IPHONE_13_2 = 130200;
    const __IPHONE_13_3 = 130300;
    const __IPHONE_13_4 = 130400;
    const __IPHONE_13_5 = 130500;
    const __IPHONE_13_6 = 130600;
    const __IPHONE_13_7 = 130700;
    const __IPHONE_14_0 = 140000;
    const __IPHONE_14_1 = 140100;
    const __IPHONE_14_2 = 140200;
    const __IPHONE_14_3 = 140300;
    const __IPHONE_14_5 = 140500;
    const __TVOS_9_0 = 90000;
    const __TVOS_9_1 = 90100;
    const __TVOS_9_2 = 90200;
    const __TVOS_10_0 = 100000;
    const __TVOS_10_0_1 = 100001;
    const __TVOS_10_1 = 100100;
    const __TVOS_10_2 = 100200;
    const __TVOS_11_0 = 110000;
    const __TVOS_11_1 = 110100;
    const __TVOS_11_2 = 110200;
    const __TVOS_11_3 = 110300;
    const __TVOS_11_4 = 110400;
    const __TVOS_12_0 = 120000;
    const __TVOS_12_1 = 120100;
    const __TVOS_12_2 = 120200;
    const __TVOS_12_3 = 120300;
    const __TVOS_12_4 = 120400;
    const __TVOS_13_0 = 130000;
    const __TVOS_13_2 = 130200;
    const __TVOS_13_3 = 130300;
    const __TVOS_13_4 = 130400;
    const __TVOS_14_0 = 140000;
    const __TVOS_14_1 = 140100;
    const __TVOS_14_2 = 140200;
    const __TVOS_14_3 = 140300;
    const __TVOS_14_5 = 140500;
    const __WATCHOS_1_0 = 10000;
    const __WATCHOS_2_0 = 20000;
    const __WATCHOS_2_1 = 20100;
    const __WATCHOS_2_2 = 20200;
    const __WATCHOS_3_0 = 30000;
    const __WATCHOS_3_1 = 30100;
    const __WATCHOS_3_1_1 = 30101;
    const __WATCHOS_3_2 = 30200;
    const __WATCHOS_4_0 = 40000;
    const __WATCHOS_4_1 = 40100;
    const __WATCHOS_4_2 = 40200;
    const __WATCHOS_4_3 = 40300;
    const __WATCHOS_5_0 = 50000;
    const __WATCHOS_5_1 = 50100;
    const __WATCHOS_5_2 = 50200;
    const __WATCHOS_5_3 = 50300;
    const __WATCHOS_6_0 = 60000;
    const __WATCHOS_6_1 = 60100;
    const __WATCHOS_6_2 = 60200;
    const __WATCHOS_7_0 = 70000;
    const __WATCHOS_7_1 = 70100;
    const __WATCHOS_7_2 = 70200;
    const __WATCHOS_7_3 = 70300;
    const __WATCHOS_7_4 = 70400;
    const MAC_OS_X_VERSION_10_0 = 1000;
    const MAC_OS_X_VERSION_10_1 = 1010;
    const MAC_OS_X_VERSION_10_2 = 1020;
    const MAC_OS_X_VERSION_10_3 = 1030;
    const MAC_OS_X_VERSION_10_4 = 1040;
    const MAC_OS_X_VERSION_10_5 = 1050;
    const MAC_OS_X_VERSION_10_6 = 1060;
    const MAC_OS_X_VERSION_10_7 = 1070;
    const MAC_OS_X_VERSION_10_8 = 1080;
    const MAC_OS_X_VERSION_10_9 = 1090;
    const MAC_OS_X_VERSION_10_10 = 101000;
    const MAC_OS_X_VERSION_10_10_2 = 101002;
    const MAC_OS_X_VERSION_10_10_3 = 101003;
    const MAC_OS_X_VERSION_10_11 = 101100;
    const MAC_OS_X_VERSION_10_11_2 = 101102;
    const MAC_OS_X_VERSION_10_11_3 = 101103;
    const MAC_OS_X_VERSION_10_11_4 = 101104;
    const MAC_OS_X_VERSION_10_12 = 101200;
    const MAC_OS_X_VERSION_10_12_1 = 101201;
    const MAC_OS_X_VERSION_10_12_2 = 101202;
    const MAC_OS_X_VERSION_10_12_4 = 101204;
    const MAC_OS_X_VERSION_10_13 = 101300;
    const MAC_OS_X_VERSION_10_13_1 = 101301;
    const MAC_OS_X_VERSION_10_13_2 = 101302;
    const MAC_OS_X_VERSION_10_13_4 = 101304;
    const MAC_OS_X_VERSION_10_14 = 101400;
    const MAC_OS_X_VERSION_10_14_1 = 101401;
    const MAC_OS_X_VERSION_10_14_4 = 101404;
    const MAC_OS_X_VERSION_10_14_6 = 101406;
    const MAC_OS_X_VERSION_10_15 = 101500;
    const MAC_OS_X_VERSION_10_15_1 = 101501;
    const MAC_OS_X_VERSION_10_16 = 101600;
    const MAC_OS_VERSION_11_0 = 110000;
    const __DRIVERKIT_19_0 = 190000;
    const __DRIVERKIT_20_0 = 200000;
    const __DARWIN_WCHAR_MAX = 0x7fffffff;
    const _FORTIFY_SOURCE = 2;
    const __DARWIN_NSIG = 32;
    const _I386_SIGNAL_H_ = 1;
    const SIGHUP = 1;
    const SIGINT = 2;
    const SIGQUIT = 3;
    const SIGILL = 4;
    const SIGTRAP = 5;
    const SIGABRT = 6;
    const SIGEMT = 7;
    const SIGFPE = 8;
    const SIGKILL = 9;
    const SIGBUS = 10;
    const SIGSEGV = 11;
    const SIGSYS = 12;
    const SIGPIPE = 13;
    const SIGALRM = 14;
    const SIGTERM = 15;
    const SIGURG = 16;
    const SIGSTOP = 17;
    const SIGTSTP = 18;
    const SIGCONT = 19;
    const SIGCHLD = 20;
    const SIGTTIN = 21;
    const SIGTTOU = 22;
    const SIGIO = 23;
    const SIGXCPU = 24;
    const SIGXFSZ = 25;
    const SIGVTALRM = 26;
    const SIGPROF = 27;
    const SIGWINCH = 28;
    const SIGINFO = 29;
    const SIGUSR1 = 30;
    const SIGUSR2 = 31;
    const FP_PREC_24B = 0;
    const FP_PREC_53B = 2;
    const FP_PREC_64B = 3;
    const FP_RND_NEAR = 0;
    const FP_RND_DOWN = 1;
    const FP_RND_UP = 2;
    const FP_CHOP = 3;
    const FP_STATE_BYTES = 512;
    const _X86_INSTRUCTION_STATE_CACHELINE_SIZE = 64;
    const __LASTBRANCH_MAX = 32;
    const SIGEV_NONE = 0;
    const SIGEV_SIGNAL = 1;
    const SIGEV_THREAD = 3;
    const ILL_NOOP = 0;
    const ILL_ILLOPC = 1;
    const ILL_ILLTRP = 2;
    const ILL_PRVOPC = 3;
    const ILL_ILLOPN = 4;
    const ILL_ILLADR = 5;
    const ILL_PRVREG = 6;
    const ILL_COPROC = 7;
    const ILL_BADSTK = 8;
    const FPE_NOOP = 0;
    const FPE_FLTDIV = 1;
    const FPE_FLTOVF = 2;
    const FPE_FLTUND = 3;
    const FPE_FLTRES = 4;
    const FPE_FLTINV = 5;
    const FPE_FLTSUB = 6;
    const FPE_INTDIV = 7;
    const FPE_INTOVF = 8;
    const SEGV_NOOP = 0;
    const SEGV_MAPERR = 1;
    const SEGV_ACCERR = 2;
    const BUS_NOOP = 0;
    const BUS_ADRALN = 1;
    const BUS_ADRERR = 2;
    const BUS_OBJERR = 3;
    const TRAP_BRKPT = 1;
    const TRAP_TRACE = 2;
    const CLD_NOOP = 0;
    const CLD_EXITED = 1;
    const CLD_KILLED = 2;
    const CLD_DUMPED = 3;
    const CLD_TRAPPED = 4;
    const CLD_STOPPED = 5;
    const CLD_CONTINUED = 6;
    const POLL_IN = 1;
    const POLL_OUT = 2;
    const POLL_MSG = 3;
    const POLL_ERR = 4;
    const POLL_PRI = 5;
    const POLL_HUP = 6;
    const SA_ONSTACK = 0x0001;
    const SA_RESTART = 0x0002;
    const SA_RESETHAND = 0x0004;
    const SA_NOCLDSTOP = 0x0008;
    const SA_NODEFER = 0x0010;
    const SA_NOCLDWAIT = 0x0020;
    const SA_SIGINFO = 0x0040;
    const SA_USERTRAMP = 0x0100;
    const SA_64REGSET = 0x0200;
    const SIG_BLOCK = 1;
    const SIG_UNBLOCK = 2;
    const SIG_SETMASK = 3;
    const SI_USER = 0x10001;
    const SI_QUEUE = 0x10002;
    const SI_TIMER = 0x10003;
    const SI_ASYNCIO = 0x10004;
    const SI_MESGQ = 0x10005;
    const SS_ONSTACK = 0x0001;
    const SS_DISABLE = 0x0004;
    const MINSIGSTKSZ = 32768;
    const SIGSTKSZ = 131072;
    const PRIO_PROCESS = 0;
    const PRIO_PGRP = 1;
    const PRIO_USER = 2;
    const PRIO_DARWIN_THREAD = 3;
    const PRIO_DARWIN_PROCESS = 4;
    const PRIO_MAX = 20;
    const PRIO_DARWIN_BG = 0x1000;
    const PRIO_DARWIN_NONUI = 0x1001;
    const RUSAGE_SELF = 0;
    const RUSAGE_INFO_V0 = 0;
    const RUSAGE_INFO_V1 = 1;
    const RUSAGE_INFO_V2 = 2;
    const RUSAGE_INFO_V3 = 3;
    const RUSAGE_INFO_V4 = 4;
    const RUSAGE_INFO_V5 = 5;
    const RU_PROC_RUNS_RESLIDE = 0x00000001;
    const RLIMIT_CPU = 0;
    const RLIMIT_FSIZE = 1;
    const RLIMIT_DATA = 2;
    const RLIMIT_STACK = 3;
    const RLIMIT_CORE = 4;
    const RLIMIT_AS = 5;
    const RLIMIT_MEMLOCK = 6;
    const RLIMIT_NPROC = 7;
    const RLIMIT_NOFILE = 8;
    const RLIM_NLIMITS = 9;
    const _RLIMIT_POSIX_FLAG = 0x1000;
    const RLIMIT_WAKEUPS_MONITOR = 0x1;
    const RLIMIT_CPU_USAGE_MONITOR = 0x2;
    const RLIMIT_THREAD_CPULIMITS = 0x3;
    const RLIMIT_FOOTPRINT_INTERVAL = 0x4;
    const WAKEMON_ENABLE = 0x01;
    const WAKEMON_DISABLE = 0x02;
    const WAKEMON_GET_PARAMS = 0x04;
    const WAKEMON_SET_DEFAULTS = 0x08;
    const WAKEMON_MAKE_FATAL = 0x10;
    const CPUMON_MAKE_FATAL = 0x1000;
    const FOOTPRINT_INTERVAL_RESET = 0x1;
    const IOPOL_TYPE_DISK = 0;
    const IOPOL_TYPE_VFS_ATIME_UPDATES = 2;
    const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES = 3;
    const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME = 4;
    const IOPOL_TYPE_VFS_TRIGGER_RESOLVE = 5;
    const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION = 6;
    const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS = 7;
    const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE = 8;
    const IOPOL_SCOPE_PROCESS = 0;
    const IOPOL_SCOPE_THREAD = 1;
    const IOPOL_SCOPE_DARWIN_BG = 2;
    const IOPOL_DEFAULT = 0;
    const IOPOL_IMPORTANT = 1;
    const IOPOL_PASSIVE = 2;
    const IOPOL_THROTTLE = 3;
    const IOPOL_UTILITY = 4;
    const IOPOL_STANDARD = 5;
    const IOPOL_ATIME_UPDATES_DEFAULT = 0;
    const IOPOL_ATIME_UPDATES_OFF = 1;
    const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT = 0;
    const IOPOL_MATERIALIZE_DATALESS_FILES_OFF = 1;
    const IOPOL_MATERIALIZE_DATALESS_FILES_ON = 2;
    const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT = 0;
    const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME = 1;
    const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT = 0;
    const IOPOL_VFS_TRIGGER_RESOLVE_OFF = 1;
    const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT = 0;
    const IOPOL_VFS_CONTENT_PROTECTION_IGNORE = 1;
    const IOPOL_VFS_IGNORE_PERMISSIONS_OFF = 0;
    const IOPOL_VFS_IGNORE_PERMISSIONS_ON = 1;
    const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF = 0;
    const IOPOL_VFS_SKIP_MTIME_UPDATE_ON = 1;
    const WNOHANG = 0x00000001;
    const WUNTRACED = 0x00000002;
    const WCOREFLAG = 0200;
    const _WSTOPPED = 0177;
    const WEXITED = 0x00000004;
    const WSTOPPED = 0x00000008;
    const WCONTINUED = 0x00000010;
    const WNOWAIT = 0x00000020;
    const WAIT_MYPGRP = 0;
    const _QUAD_HIGHWORD = 1;
    const _QUAD_LOWWORD = 0;
    const __DARWIN_LITTLE_ENDIAN = 1234;
    const __DARWIN_BIG_ENDIAN = 4321;
    const __DARWIN_PDP_ENDIAN = 3412;
    const EXIT_FAILURE = 1;
    const EXIT_SUCCESS = 0;
    const RAND_MAX = 0x7fffffff;
    public function __construct(string $pathToSoFile = self::SOFILE) {
        $this->ffi = FFI::cdef(self::HEADER_DEF, $pathToSoFile);
    }

    public static function cast(iExtism $from, string $to): iExtism {
        if (!is_a($to, iExtism::class)) {
            throw new \LogicException("Cannot cast to a non-wrapper type");
        }
        return new $to(self::$staticFFI->cast($to::getType(), $from->getData()));
    }

    public static function makeArray(string $class, array $elements): iExtism {
        $type = $class::getType();
        if (substr($type, -1) !== "*") {
            throw new \LogicException("Attempting to make a non-pointer element into an array");
        }
        $cdata = self::$staticFFI->new(substr($type, 0, -1) . "[" . count($elements) . "]");
        foreach ($elements as $key => $raw) {
            $cdata[$key] = $raw === null ? null : $raw->getData();
        }
        return new $class($cdata);
    }

    public static function sizeof($classOrObject): int {
        if (is_object($classOrObject) && $classOrObject instanceof iExtism) {
            return self::$staticFFI->sizeof($classOrObject->getData());
        } elseif (is_a($classOrObject, iExtism::class)) {
            return self::$staticFFI->sizeof(self::$staticFFI->type($classOrObject::getType()));
        } else {
            throw new \LogicException("Unknown class/object passed to sizeof()");
        }
    }

    public function getFFI(): FFI {
        return $this->ffi;
    }


    public function __get(string $name) {
        switch($name) {
            default: return $this->ffi->$name;
        }
    }
    public function __set(string $name, $value) {
        switch($name) {
            default: return $this->ffi->$name;
        }
    }
    public function __allocCachedString(string $str): FFI\CData {
        return $this->__literalStrings[$str] ??= string_::ownedZero($str)->getData();
    }
    // typedefenum idtype_t
    const P_ALL = (0) + 0;
    const P_PID = (0) + 1;
    const P_PGID = (0) + 2;
    public function malloc(int $__size): ?void_ptr {
        $result = $this->ffi->malloc($__size);
        return $result === null ? null : new void_ptr($result);
    }
    public function calloc(int $__count, int $__size): ?void_ptr {
        $result = $this->ffi->calloc($__count, $__size);
        return $result === null ? null : new void_ptr($result);
    }
    public function free(iExtism_ptr | null | array $_0): void {
        $__ffi_internal_refs_0 = [];
        if (\is_array($_0)) {
            $_ = $this->ffi->new("void[" . \count($_0) . "]");
            $_i = 0;
            foreach ($_0 as $_k => $_v) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, $_k)) {
                    $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                }
                $_[$_i++] = $_v?->getData();
            }
            $__ffi_internal_original_0 = $_0 = $_;
        } else {
            $_0 = $_0?->getData();
        }
        $this->ffi->free($_0);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_0[$_k];
        }
    }
    public function realloc(iExtism_ptr | null | array $__ptr, int $__size): ?void_ptr {
        $__ffi_internal_refs__ptr = [];
        if (\is_array($__ptr)) {
            $_ = $this->ffi->new("void[" . \count($__ptr) . "]");
            $_i = 0;
            foreach ($__ptr as $_k => $_v) {
                if ($_ref = \ReflectionReference::fromArrayElement($__ptr, $_k)) {
                    $__ffi_internal_refs__ptr[$_i] = &$__ptr[$_k];
                }
                $_[$_i++] = $_v?->getData();
            }
            $__ffi_internal_original__ptr = $__ptr = $_;
        } else {
            $__ptr = $__ptr?->getData();
        }
        $result = $this->ffi->realloc($__ptr, $__size);
        foreach ($__ffi_internal_refs__ptr as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original__ptr[$_k];
        }
        return $result === null ? null : new void_ptr($result);
    }
    public function posix_memalign(void_ptr | void_ptr_ptr | null | array $__memptr, int $__alignment, int $__size): int {
        $__ffi_internal_refs__memptr = [];
        if (\is_array($__memptr)) {
            $_ = $this->ffi->new("void*[" . \count($__memptr) . "]");
            $_i = 0;
            foreach ($__memptr as $_k => $_v) {
                if ($_ref = \ReflectionReference::fromArrayElement($__memptr, $_k)) {
                    $__ffi_internal_refs__memptr[$_i] = &$__memptr[$_k];
                }
                $_[$_i++] = $_v?->getData();
            }
            $__ffi_internal_original__memptr = $__memptr = $_;
        } else {
            $__memptr = $__memptr?->getData();
        }
        $result = $this->ffi->posix_memalign($__memptr, $__alignment, $__size);
        foreach ($__ffi_internal_refs__memptr as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original__memptr[$_k];
        }
        return $result;
    }
    public function abort(): void {
        $this->ffi->abort();
    }
    public function getenv(void_ptr | string_ | null | string | array $_0): ?string_ {
        $__ffi_internal_refs_0 = [];
        if (\is_string($_0)) {
            $_0 = string_::ownedZero($_0)->getData();
        } elseif (\is_array($_0)) {
            $_ = $this->ffi->new("char[" . \count($_0) . "]");
            $_i = 0;
            foreach ($_0 as $_k => $_v) {
                if ($_ref = \ReflectionReference::fromArrayElement($_0, $_k)) {
                    $__ffi_internal_refs_0[$_i] = &$_0[$_k];
                }
                $_[$_i++] = $_v ?? 0;
            }
            $__ffi_internal_original_0 = $_0 = $_;
        } else {
            $_0 = $_0?->getData();
        }
        $result = $this->ffi->getenv($_0);
        foreach ($__ffi_internal_refs_0 as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_original_0[$_k];
        }
        return $result === null ? null : new string_($result);
    }
    public function extism_plugin_register(void_ptr | uint8_t_ptr | null | array $wasm, int $wasm_size, int $with_wasi): int {
        $__ffi_internal_refswasm = [];
        if (\is_array($wasm)) {
            $_ = $this->ffi->new("uint8_t[" . \count($wasm) . "]");
            $_i = 0;
            foreach ($wasm as $_k => $_v) {
                if ($_ref = \ReflectionReference::fromArrayElement($wasm, $_k)) {
                    $__ffi_internal_refswasm[$_i] = &$wasm[$_k];
                }
                $_[$_i++] = $_v ?? 0;
            }
            $__ffi_internal_originalwasm = $wasm = $_;
        } else {
            $wasm = $wasm?->getData();
        }
        $result = $this->ffi->extism_plugin_register($wasm, $wasm_size, $with_wasi);
        foreach ($__ffi_internal_refswasm as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalwasm[$_k];
        }
        return $result;
    }
    public function extism_plugin_config(int $plugin, void_ptr | uint8_t_ptr | null | array $json, int $json_size): int {
        $__ffi_internal_refsjson = [];
        if (\is_array($json)) {
            $_ = $this->ffi->new("uint8_t[" . \count($json) . "]");
            $_i = 0;
            foreach ($json as $_k => $_v) {
                if ($_ref = \ReflectionReference::fromArrayElement($json, $_k)) {
                    $__ffi_internal_refsjson[$_i] = &$json[$_k];
                }
                $_[$_i++] = $_v ?? 0;
            }
            $__ffi_internal_originaljson = $json = $_;
        } else {
            $json = $json?->getData();
        }
        $result = $this->ffi->extism_plugin_config($plugin, $json, $json_size);
        foreach ($__ffi_internal_refsjson as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originaljson[$_k];
        }
        return $result;
    }
    public function extism_function_exists(int $plugin, void_ptr | string_ | null | string | array $func_name): int {
        $__ffi_internal_refsfunc_name = [];
        if (\is_string($func_name)) {
            $func_name = string_::ownedZero($func_name)->getData();
        } elseif (\is_array($func_name)) {
            $_ = $this->ffi->new("char[" . \count($func_name) . "]");
            $_i = 0;
            foreach ($func_name as $_k => $_v) {
                if ($_ref = \ReflectionReference::fromArrayElement($func_name, $_k)) {
                    $__ffi_internal_refsfunc_name[$_i] = &$func_name[$_k];
                }
                $_[$_i++] = $_v ?? 0;
            }
            $__ffi_internal_originalfunc_name = $func_name = $_;
        } else {
            $func_name = $func_name?->getData();
        }
        $result = $this->ffi->extism_function_exists($plugin, $func_name);
        foreach ($__ffi_internal_refsfunc_name as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalfunc_name[$_k];
        }
        return $result;
    }
    public function extism_call(int $plugin_id, void_ptr | string_ | null | string | array $func_name, void_ptr | uint8_t_ptr | null | array $data, int $data_len): int {
        $__ffi_internal_refsfunc_name = [];
        if (\is_string($func_name)) {
            $func_name = string_::ownedZero($func_name)->getData();
        } elseif (\is_array($func_name)) {
            $_ = $this->ffi->new("char[" . \count($func_name) . "]");
            $_i = 0;
            foreach ($func_name as $_k => $_v) {
                if ($_ref = \ReflectionReference::fromArrayElement($func_name, $_k)) {
                    $__ffi_internal_refsfunc_name[$_i] = &$func_name[$_k];
                }
                $_[$_i++] = $_v ?? 0;
            }
            $__ffi_internal_originalfunc_name = $func_name = $_;
        } else {
            $func_name = $func_name?->getData();
        }
        $__ffi_internal_refsdata = [];
        if (\is_array($data)) {
            $_ = $this->ffi->new("uint8_t[" . \count($data) . "]");
            $_i = 0;
            foreach ($data as $_k => $_v) {
                if ($_ref = \ReflectionReference::fromArrayElement($data, $_k)) {
                    $__ffi_internal_refsdata[$_i] = &$data[$_k];
                }
                $_[$_i++] = $_v ?? 0;
            }
            $__ffi_internal_originaldata = $data = $_;
        } else {
            $data = $data?->getData();
        }
        $result = $this->ffi->extism_call($plugin_id, $func_name, $data, $data_len);
        foreach ($__ffi_internal_refsfunc_name as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalfunc_name[$_k];
        }
        foreach ($__ffi_internal_refsdata as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originaldata[$_k];
        }
        return $result;
    }
    public function extism_error(int $plugin): ?string_ {
        $result = $this->ffi->extism_error($plugin);
        return $result === null ? null : new string_($result);
    }
    public function extism_output_length(int $plugin): int {
        $result = $this->ffi->extism_output_length($plugin);
        return $result;
    }
    public function extism_output_get(int $plugin, void_ptr | uint8_t_ptr | null | array $buf, int $len): void {
        $__ffi_internal_refsbuf = [];
        if (\is_array($buf)) {
            $_ = $this->ffi->new("uint8_t[" . \count($buf) . "]");
            $_i = 0;
            foreach ($buf as $_k => $_v) {
                if ($_ref = \ReflectionReference::fromArrayElement($buf, $_k)) {
                    $__ffi_internal_refsbuf[$_i] = &$buf[$_k];
                }
                $_[$_i++] = $_v ?? 0;
            }
            $__ffi_internal_originalbuf = $buf = $_;
        } else {
            $buf = $buf?->getData();
        }
        $this->ffi->extism_output_get($plugin, $buf, $len);
        foreach ($__ffi_internal_refsbuf as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalbuf[$_k];
        }
    }
    public function extism_log_file(void_ptr | string_ | null | string | array $filename, void_ptr | string_ | null | string | array $log_level): int {
        $__ffi_internal_refsfilename = [];
        if (\is_string($filename)) {
            $filename = string_::ownedZero($filename)->getData();
        } elseif (\is_array($filename)) {
            $_ = $this->ffi->new("char[" . \count($filename) . "]");
            $_i = 0;
            foreach ($filename as $_k => $_v) {
                if ($_ref = \ReflectionReference::fromArrayElement($filename, $_k)) {
                    $__ffi_internal_refsfilename[$_i] = &$filename[$_k];
                }
                $_[$_i++] = $_v ?? 0;
            }
            $__ffi_internal_originalfilename = $filename = $_;
        } else {
            $filename = $filename?->getData();
        }
        $__ffi_internal_refslog_level = [];
        if (\is_string($log_level)) {
            $log_level = string_::ownedZero($log_level)->getData();
        } elseif (\is_array($log_level)) {
            $_ = $this->ffi->new("char[" . \count($log_level) . "]");
            $_i = 0;
            foreach ($log_level as $_k => $_v) {
                if ($_ref = \ReflectionReference::fromArrayElement($log_level, $_k)) {
                    $__ffi_internal_refslog_level[$_i] = &$log_level[$_k];
                }
                $_[$_i++] = $_v ?? 0;
            }
            $__ffi_internal_originallog_level = $log_level = $_;
        } else {
            $log_level = $log_level?->getData();
        }
        $result = $this->ffi->extism_log_file($filename, $log_level);
        foreach ($__ffi_internal_refsfilename as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originalfilename[$_k];
        }
        foreach ($__ffi_internal_refslog_level as $_k => &$__ffi_internal_ref_v) {
            $__ffi_internal_ref_v = $__ffi_internal_originallog_level[$_k];
        }
        return $result;
    }
    public function _OSSwapInt16(int $_data): int {
        $result = $this->_ffi_internal__OSSwapInt16($_data);
        return $result;
    }
    private function _ffi_internal__OSSwapInt16(int $_data): int {
        $_data = (function ($cdata, $val) { $cdata->cdata = $val; return $cdata; })($this->ffi->new("int"), $_data);
        return ((int) ((($_data)->cdata << 8) | (($_data)->cdata >> 8)));
    }
    public function _OSSwapInt32(int $_data): int {
        $result = $this->_ffi_internal__OSSwapInt32($_data);
        return $result;
    }
    private function _ffi_internal__OSSwapInt32(int $_data): int {
        $_data = (function ($cdata, $val) { $cdata->cdata = $val; return $cdata; })($this->ffi->new("int"), $_data);
        throw new \LogicException("Unsupported assembly statement");
        return ($_data)->cdata;
    }
    public function _OSSwapInt64(int $_data): int {
        $result = $this->_ffi_internal__OSSwapInt64($_data);
        return $result;
    }
    private function _ffi_internal__OSSwapInt64(int $_data): int {
        $_data = (function ($cdata, $val) { $cdata->cdata = $val; return $cdata; })($this->ffi->new("int"), $_data);
        throw new \LogicException("Unsupported assembly statement");
        return ($_data)->cdata;
    }
}
(function() { self::$staticFFI = \FFI::cdef(Extism::TYPES_DEF); })->bindTo(null, Extism::class)();

class string_ implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(string_ $other): bool { return $this->data == $other->data; }
    public function addr(): string_ptr { return new string_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = \chr($value); }
    public function deref(int $n = 0): int { return \ord($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return int[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while ("\0" !== $cur = $this->data[$i++]) { $ret[] = \ord($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = \ord($this->data[$i]); } } return $ret; }
    public function toString(?int $length = null): string { return $length === null ? FFI::string($this->data) : FFI::string($this->data, $length); }
    public static function persistent(string $string): self { $str = new self(FFI::new("char[" . \strlen($string) . "]", false)); FFI::memcpy($str->data, $string, \strlen($string)); return $str; }
    public static function owned(string $string): self { $str = new self(FFI::new("char[" . \strlen($string) . "]", true)); FFI::memcpy($str->data, $string, \strlen($string)); return $str; }
    public static function persistentZero(string $string): self { return self::persistent("$string\0"); }
    public static function ownedZero(string $string): self { return self::owned("$string\0"); }
    public function set(int | void_ptr | string_ $value): void {
        if (\is_scalar($value)) {
            $this->data[0] = \chr($value);
        } else {
            FFI::addr($this->data)[0] = $value->getData();
        }
    }
    public static function getType(): string { return 'char*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class string_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(string_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): string_ptr_ptr { return new string_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): string_ { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): string_ { return new string_($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return string_[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new string_($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new string_($this->data[$i]); } } return $ret; }
    public function set(void_ptr | string_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'char**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class string_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(string_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): string_ptr_ptr_ptr { return new string_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): string_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): string_ptr { return new string_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return string_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new string_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new string_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | string_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'char***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class string_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(string_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): string_ptr_ptr_ptr_ptr { return new string_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): string_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): string_ptr_ptr { return new string_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return string_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new string_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new string_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | string_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'char***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class void_ptr implements iExtism, iExtism_ptr {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(void_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): void_ptr_ptr { return new void_ptr_ptr(FFI::addr($this->data)); }
    public function set(iExtism_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'void*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class void_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(void_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): void_ptr_ptr_ptr { return new void_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): void_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): void_ptr { return new void_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return void_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new void_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new void_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | void_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'void**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class void_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(void_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): void_ptr_ptr_ptr_ptr { return new void_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): void_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): void_ptr_ptr { return new void_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return void_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new void_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new void_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | void_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'void***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class void_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(void_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): void_ptr_ptr_ptr_ptr_ptr { return new void_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): void_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): void_ptr_ptr_ptr { return new void_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return void_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new void_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new void_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | void_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'void****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class function_type_ptr implements iExtism, iExtism_ptr {
    private FFI\CData $data;
    private array $types;
    public function __construct(FFI\CData $data, array $types) { $this->data = $data; $this->types = $types; }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(function_type_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): function_type_ptr_ptr { return new function_type_ptr_ptr(FFI::addr($this->data)); }
    public function set(callable | void_ptr | function_type_ptr $value): void {
        if ($value instanceof void_ptr) {
            $value = $value->getData();
        } elseif ($value instanceof function_type_ptr) {
            if ($value->types != $this->types) {
                throw new \TypeError("Cannot assign " . get_class($value) . " with type signature " . json_encode($value->types) . " to " . get_class($this) . " with type signature " . json_encode($this->types));
            }
            $value = $value->getData();
        } else {
            $types = $this->types;
            $value = static function (...$args) use ($value, $types) {
                foreach ($args as $i => $arg) {
                    $type = $types[$i + 1];
                    if ($type === "char") {
                        $args[$i] = \chr($arg);
                    } elseif (\is_array($type)) {
                        $args[$i] = new (__NAMESPACE__ . "\\" . $type[0])($arg, array_slice($type, 1));
                    } elseif ($type !== "int" && $type !== "float") {
                        $args[$i] = new (__NAMESPACE__ . "\\" . $type)($arg);
                    }
                }
                $ret = $value(...$args);
                if ($types[0] === "int" || $types === "float") {
                    return $ret;
                } elseif ($types[0] === "char") {
                    return \chr($ret);
                } elseif ($types[0] !== null) {
                    return $ret->getData();
                }
            };
        }
        FFI::addr($this->data)[0] = $value;
    }
    public static function getType(): string { return "(*)"; }
    public function getDefinition(): string { return ($this->types[0] !== null ? \is_array($this->types[0]) ? (new (__NAMESPACE__ . "\\" . $this->types[0][0])($this->data, array_slice($this->types[0], 1)))->getDefinition() : $this->types[0]::getType() : "void") . "(*)(" . implode(", ", array_map(function($t) { return \is_array($t) ? (new (__NAMESPACE__ . "\\" . $t[0])($this->data, array_slice($t, 1)))->getDefinition() : $t::getType(); }, array_slice($this->types, 1))) . ")"; }
}
class function_type_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    private array $types;
    public function __construct(FFI\CData $data, array $types) { $this->data = $data; $this->types = $types; }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(function_type_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): function_type_ptr_ptr_ptr { return new function_type_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): function_type_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->deref($offset)->set($value); }
    public function deref(int $n = 0): function_type_ptr { return new function_type_ptr($this->data[$n], $this->types); }
    /** @return function_type_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new function_type_ptr($cur, $this->types); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new function_type_ptr($this->data[$i], $this->types); } } return $ret; }
    public function set(void_ptr | function_type_ptr_ptr $value): void {
        if ($value instanceof function_type_ptr_ptr && $value->types != $this->types) {
            throw new \TypeError("Cannot assign " . get_class($value) . " with type signature " . json_encode($value->types) . " to " . get_class($this) . " with type signature " . json_encode($this->types));
        }
        FFI::addr($this->data)[0] = $value;
    }
    public static function getType(): string { return "(**)"; }
    public function getDefinition(): string { return ($this->types[0] !== null ? \is_array($this->types[0]) ? (new (__NAMESPACE__ . "\\" . $this->types[0][0])($this->data, array_slice($this->types[0], 1)))->getDefinition() : $this->types[0]::getType() : "void") . "(**)(" . implode(", ", array_map(function($t) { return \is_array($t) ? (new (__NAMESPACE__ . "\\" . $t[0])($this->data, array_slice($t, 1)))->getDefinition() : $t::getType(); }, array_slice($this->types, 1))) . ")"; }
}
class function_type_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    private array $types;
    public function __construct(FFI\CData $data, array $types) { $this->data = $data; $this->types = $types; }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(function_type_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): function_type_ptr_ptr_ptr_ptr { return new function_type_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): function_type_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->deref($offset)->set($value); }
    public function deref(int $n = 0): function_type_ptr_ptr { return new function_type_ptr_ptr($this->data[$n], $this->types); }
    /** @return function_type_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new function_type_ptr_ptr($cur, $this->types); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new function_type_ptr_ptr($this->data[$i], $this->types); } } return $ret; }
    public function set(void_ptr | function_type_ptr_ptr_ptr $value): void {
        if ($value instanceof function_type_ptr_ptr_ptr && $value->types != $this->types) {
            throw new \TypeError("Cannot assign " . get_class($value) . " with type signature " . json_encode($value->types) . " to " . get_class($this) . " with type signature " . json_encode($this->types));
        }
        FFI::addr($this->data)[0] = $value;
    }
    public static function getType(): string { return "(***)"; }
    public function getDefinition(): string { return ($this->types[0] !== null ? \is_array($this->types[0]) ? (new (__NAMESPACE__ . "\\" . $this->types[0][0])($this->data, array_slice($this->types[0], 1)))->getDefinition() : $this->types[0]::getType() : "void") . "(***)(" . implode(", ", array_map(function($t) { return \is_array($t) ? (new (__NAMESPACE__ . "\\" . $t[0])($this->data, array_slice($t, 1)))->getDefinition() : $t::getType(); }, array_slice($this->types, 1))) . ")"; }
}
class function_type_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    private array $types;
    public function __construct(FFI\CData $data, array $types) { $this->data = $data; $this->types = $types; }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(function_type_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): function_type_ptr_ptr_ptr_ptr_ptr { return new function_type_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): function_type_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->deref($offset)->set($value); }
    public function deref(int $n = 0): function_type_ptr_ptr_ptr { return new function_type_ptr_ptr_ptr($this->data[$n], $this->types); }
    /** @return function_type_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new function_type_ptr_ptr_ptr($cur, $this->types); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new function_type_ptr_ptr_ptr($this->data[$i], $this->types); } } return $ret; }
    public function set(void_ptr | function_type_ptr_ptr_ptr_ptr $value): void {
        if ($value instanceof function_type_ptr_ptr_ptr_ptr && $value->types != $this->types) {
            throw new \TypeError("Cannot assign " . get_class($value) . " with type signature " . json_encode($value->types) . " to " . get_class($this) . " with type signature " . json_encode($this->types));
        }
        FFI::addr($this->data)[0] = $value;
    }
    public static function getType(): string { return "(****)"; }
    public function getDefinition(): string { return ($this->types[0] !== null ? \is_array($this->types[0]) ? (new (__NAMESPACE__ . "\\" . $this->types[0][0])($this->data, array_slice($this->types[0], 1)))->getDefinition() : $this->types[0]::getType() : "void") . "(****)(" . implode(", ", array_map(function($t) { return \is_array($t) ? (new (__NAMESPACE__ . "\\" . $t[0])($this->data, array_slice($t, 1)))->getDefinition() : $t::getType(); }, array_slice($this->types, 1))) . ")"; }
}
class __builtin_va_list implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(__builtin_va_list $other): bool { return $this->data == $other->data; }
    public function addr(): __builtin_va_list_ptr { return new __builtin_va_list_ptr(FFI::addr($this->data)); }
    public function set(__builtin_va_list $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '__builtin_va_list'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class __builtin_va_list_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(__builtin_va_list_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): __builtin_va_list_ptr_ptr { return new __builtin_va_list_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): __builtin_va_list { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): __builtin_va_list { return new __builtin_va_list($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return __builtin_va_list[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new __builtin_va_list($this->data[$i]); } return $ret; }
    public function set(void_ptr | __builtin_va_list_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '__builtin_va_list*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class __builtin_va_list_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(__builtin_va_list_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): __builtin_va_list_ptr_ptr_ptr { return new __builtin_va_list_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): __builtin_va_list_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): __builtin_va_list_ptr { return new __builtin_va_list_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return __builtin_va_list_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new __builtin_va_list_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new __builtin_va_list_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | __builtin_va_list_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '__builtin_va_list**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class __builtin_va_list_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(__builtin_va_list_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): __builtin_va_list_ptr_ptr_ptr_ptr { return new __builtin_va_list_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): __builtin_va_list_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): __builtin_va_list_ptr_ptr { return new __builtin_va_list_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return __builtin_va_list_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new __builtin_va_list_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new __builtin_va_list_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | __builtin_va_list_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '__builtin_va_list***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class __builtin_va_list_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(__builtin_va_list_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): __builtin_va_list_ptr_ptr_ptr_ptr_ptr { return new __builtin_va_list_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): __builtin_va_list_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): __builtin_va_list_ptr_ptr_ptr { return new __builtin_va_list_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return __builtin_va_list_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new __builtin_va_list_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new __builtin_va_list_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | __builtin_va_list_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '__builtin_va_list****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property string_ $__mbstate8
 * @property int $_mbstateL
 */
class __mbstate_t implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(__mbstate_t $other): bool { return $this->data == $other->data; }
    public function addr(): __mbstate_t_ptr { return new __mbstate_t_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__mbstate8": return new string_($this->data->__mbstate8);
            case "_mbstateL": return $this->data->_mbstateL;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__mbstate8":
                (new string_($this->data->__mbstate8))->set($value);
                break;
            case "_mbstateL":
                $this->data->_mbstateL = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(__mbstate_t $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '__mbstate_t'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property string_ $__mbstate8
 * @property int $_mbstateL
 */
class __mbstate_t_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(__mbstate_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): __mbstate_t_ptr_ptr { return new __mbstate_t_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): __mbstate_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): __mbstate_t { return new __mbstate_t($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return __mbstate_t[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new __mbstate_t($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__mbstate8": return new string_($this->data[0]->__mbstate8);
            case "_mbstateL": return $this->data[0]->_mbstateL;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__mbstate8":
                (new string_($this->data[0]->__mbstate8))->set($value);
                break;
            case "_mbstateL":
                $this->data[0]->_mbstateL = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | __mbstate_t_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '__mbstate_t*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class __mbstate_t_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(__mbstate_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): __mbstate_t_ptr_ptr_ptr { return new __mbstate_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): __mbstate_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): __mbstate_t_ptr { return new __mbstate_t_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return __mbstate_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new __mbstate_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new __mbstate_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | __mbstate_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '__mbstate_t**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class __mbstate_t_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(__mbstate_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): __mbstate_t_ptr_ptr_ptr_ptr { return new __mbstate_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): __mbstate_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): __mbstate_t_ptr_ptr { return new __mbstate_t_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return __mbstate_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new __mbstate_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new __mbstate_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | __mbstate_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '__mbstate_t***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class __mbstate_t_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(__mbstate_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): __mbstate_t_ptr_ptr_ptr_ptr_ptr { return new __mbstate_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): __mbstate_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): __mbstate_t_ptr_ptr_ptr { return new __mbstate_t_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return __mbstate_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new __mbstate_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new __mbstate_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | __mbstate_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '__mbstate_t****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property function_type_ptr $__routine
 * @property void_ptr $__arg
 * @property struct___darwin_pthread_handler_rec_ptr $__next
 */
class struct___darwin_pthread_handler_rec implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_pthread_handler_rec $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_pthread_handler_rec_ptr { return new struct___darwin_pthread_handler_rec_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__routine": return new function_type_ptr($this->data->__routine, [NULL, 'void_ptr']);
            case "__arg": return new void_ptr($this->data->__arg);
            case "__next": return new struct___darwin_pthread_handler_rec_ptr($this->data->__next);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__routine":
                (new function_type_ptr($this->data->__routine, [NULL, 'void_ptr']))->set($value);
                break;
            case "__arg":
                (new void_ptr($this->data->__arg))->set($value);
                break;
            case "__next":
                (new struct___darwin_pthread_handler_rec_ptr($this->data->__next))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_pthread_handler_rec $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_pthread_handler_rec'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property function_type_ptr $__routine
 * @property void_ptr $__arg
 * @property struct___darwin_pthread_handler_rec_ptr $__next
 */
class struct___darwin_pthread_handler_rec_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_pthread_handler_rec_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_pthread_handler_rec_ptr_ptr { return new struct___darwin_pthread_handler_rec_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_pthread_handler_rec { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_pthread_handler_rec { return new struct___darwin_pthread_handler_rec($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_pthread_handler_rec[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_pthread_handler_rec($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__routine": return new function_type_ptr($this->data[0]->__routine, [NULL, 'void_ptr']);
            case "__arg": return new void_ptr($this->data[0]->__arg);
            case "__next": return new struct___darwin_pthread_handler_rec_ptr($this->data[0]->__next);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__routine":
                (new function_type_ptr($this->data[0]->__routine, [NULL, 'void_ptr']))->set($value);
                break;
            case "__arg":
                (new void_ptr($this->data[0]->__arg))->set($value);
                break;
            case "__next":
                (new struct___darwin_pthread_handler_rec_ptr($this->data[0]->__next))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_pthread_handler_rec_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_pthread_handler_rec*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_pthread_handler_rec_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_pthread_handler_rec_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_pthread_handler_rec_ptr_ptr_ptr { return new struct___darwin_pthread_handler_rec_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_pthread_handler_rec_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_pthread_handler_rec_ptr { return new struct___darwin_pthread_handler_rec_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_pthread_handler_rec_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_pthread_handler_rec_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_pthread_handler_rec_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_pthread_handler_rec_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_pthread_handler_rec**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_pthread_handler_rec_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_pthread_handler_rec_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_pthread_handler_rec_ptr_ptr_ptr_ptr { return new struct___darwin_pthread_handler_rec_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_pthread_handler_rec_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_pthread_handler_rec_ptr_ptr { return new struct___darwin_pthread_handler_rec_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_pthread_handler_rec_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_pthread_handler_rec_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_pthread_handler_rec_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_pthread_handler_rec_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_pthread_handler_rec***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_pthread_handler_rec_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_pthread_handler_rec_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_pthread_handler_rec_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_pthread_handler_rec_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_pthread_handler_rec_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_pthread_handler_rec_ptr_ptr_ptr { return new struct___darwin_pthread_handler_rec_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_pthread_handler_rec_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_pthread_handler_rec_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_pthread_handler_rec_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_pthread_handler_rec_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_pthread_handler_rec****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_attr_t implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_attr_t $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_attr_t_ptr { return new struct__opaque_pthread_attr_t_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data->__sig;
            case "__opaque": return new string_($this->data->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data->__sig = $value;
                break;
            case "__opaque":
                (new string_($this->data->__opaque))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct__opaque_pthread_attr_t $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_attr_t'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_attr_t_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_attr_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_attr_t_ptr_ptr { return new struct__opaque_pthread_attr_t_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_attr_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_attr_t { return new struct__opaque_pthread_attr_t($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_attr_t[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_attr_t($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data[0]->__sig;
            case "__opaque": return new string_($this->data[0]->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data[0]->__sig = $value;
                break;
            case "__opaque":
                (new string_($this->data[0]->__opaque))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct__opaque_pthread_attr_t_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_attr_t*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_attr_t_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_attr_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_attr_t_ptr_ptr_ptr { return new struct__opaque_pthread_attr_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_attr_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_attr_t_ptr { return new struct__opaque_pthread_attr_t_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_attr_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_attr_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_attr_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_attr_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_attr_t**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_attr_t_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_attr_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_attr_t_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_attr_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_attr_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_attr_t_ptr_ptr { return new struct__opaque_pthread_attr_t_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_attr_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_attr_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_attr_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_attr_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_attr_t***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_attr_t_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_attr_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_attr_t_ptr_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_attr_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_attr_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_attr_t_ptr_ptr_ptr { return new struct__opaque_pthread_attr_t_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_attr_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_attr_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_attr_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_attr_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_attr_t****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_cond_t implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_cond_t $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_cond_t_ptr { return new struct__opaque_pthread_cond_t_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data->__sig;
            case "__opaque": return new string_($this->data->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data->__sig = $value;
                break;
            case "__opaque":
                (new string_($this->data->__opaque))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct__opaque_pthread_cond_t $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_cond_t'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_cond_t_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_cond_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_cond_t_ptr_ptr { return new struct__opaque_pthread_cond_t_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_cond_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_cond_t { return new struct__opaque_pthread_cond_t($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_cond_t[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_cond_t($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data[0]->__sig;
            case "__opaque": return new string_($this->data[0]->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data[0]->__sig = $value;
                break;
            case "__opaque":
                (new string_($this->data[0]->__opaque))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct__opaque_pthread_cond_t_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_cond_t*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_cond_t_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_cond_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_cond_t_ptr_ptr_ptr { return new struct__opaque_pthread_cond_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_cond_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_cond_t_ptr { return new struct__opaque_pthread_cond_t_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_cond_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_cond_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_cond_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_cond_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_cond_t**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_cond_t_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_cond_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_cond_t_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_cond_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_cond_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_cond_t_ptr_ptr { return new struct__opaque_pthread_cond_t_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_cond_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_cond_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_cond_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_cond_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_cond_t***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_cond_t_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_cond_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_cond_t_ptr_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_cond_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_cond_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_cond_t_ptr_ptr_ptr { return new struct__opaque_pthread_cond_t_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_cond_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_cond_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_cond_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_cond_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_cond_t****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_condattr_t implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_condattr_t $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_condattr_t_ptr { return new struct__opaque_pthread_condattr_t_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data->__sig;
            case "__opaque": return new string_($this->data->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data->__sig = $value;
                break;
            case "__opaque":
                (new string_($this->data->__opaque))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct__opaque_pthread_condattr_t $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_condattr_t'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_condattr_t_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_condattr_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_condattr_t_ptr_ptr { return new struct__opaque_pthread_condattr_t_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_condattr_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_condattr_t { return new struct__opaque_pthread_condattr_t($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_condattr_t[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_condattr_t($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data[0]->__sig;
            case "__opaque": return new string_($this->data[0]->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data[0]->__sig = $value;
                break;
            case "__opaque":
                (new string_($this->data[0]->__opaque))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct__opaque_pthread_condattr_t_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_condattr_t*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_condattr_t_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_condattr_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_condattr_t_ptr_ptr_ptr { return new struct__opaque_pthread_condattr_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_condattr_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_condattr_t_ptr { return new struct__opaque_pthread_condattr_t_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_condattr_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_condattr_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_condattr_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_condattr_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_condattr_t**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_condattr_t_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_condattr_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_condattr_t_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_condattr_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_condattr_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_condattr_t_ptr_ptr { return new struct__opaque_pthread_condattr_t_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_condattr_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_condattr_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_condattr_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_condattr_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_condattr_t***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_condattr_t_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_condattr_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_condattr_t_ptr_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_condattr_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_condattr_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_condattr_t_ptr_ptr_ptr { return new struct__opaque_pthread_condattr_t_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_condattr_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_condattr_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_condattr_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_condattr_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_condattr_t****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_mutex_t implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_mutex_t $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_mutex_t_ptr { return new struct__opaque_pthread_mutex_t_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data->__sig;
            case "__opaque": return new string_($this->data->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data->__sig = $value;
                break;
            case "__opaque":
                (new string_($this->data->__opaque))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct__opaque_pthread_mutex_t $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_mutex_t'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_mutex_t_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_mutex_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_mutex_t_ptr_ptr { return new struct__opaque_pthread_mutex_t_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_mutex_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_mutex_t { return new struct__opaque_pthread_mutex_t($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_mutex_t[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_mutex_t($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data[0]->__sig;
            case "__opaque": return new string_($this->data[0]->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data[0]->__sig = $value;
                break;
            case "__opaque":
                (new string_($this->data[0]->__opaque))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct__opaque_pthread_mutex_t_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_mutex_t*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_mutex_t_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_mutex_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_mutex_t_ptr_ptr_ptr { return new struct__opaque_pthread_mutex_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_mutex_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_mutex_t_ptr { return new struct__opaque_pthread_mutex_t_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_mutex_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_mutex_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_mutex_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_mutex_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_mutex_t**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_mutex_t_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_mutex_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_mutex_t_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_mutex_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_mutex_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_mutex_t_ptr_ptr { return new struct__opaque_pthread_mutex_t_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_mutex_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_mutex_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_mutex_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_mutex_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_mutex_t***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_mutex_t_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_mutex_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_mutex_t_ptr_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_mutex_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_mutex_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_mutex_t_ptr_ptr_ptr { return new struct__opaque_pthread_mutex_t_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_mutex_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_mutex_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_mutex_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_mutex_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_mutex_t****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_mutexattr_t implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_mutexattr_t $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_mutexattr_t_ptr { return new struct__opaque_pthread_mutexattr_t_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data->__sig;
            case "__opaque": return new string_($this->data->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data->__sig = $value;
                break;
            case "__opaque":
                (new string_($this->data->__opaque))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct__opaque_pthread_mutexattr_t $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_mutexattr_t'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_mutexattr_t_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_mutexattr_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_mutexattr_t_ptr_ptr { return new struct__opaque_pthread_mutexattr_t_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_mutexattr_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_mutexattr_t { return new struct__opaque_pthread_mutexattr_t($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_mutexattr_t[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_mutexattr_t($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data[0]->__sig;
            case "__opaque": return new string_($this->data[0]->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data[0]->__sig = $value;
                break;
            case "__opaque":
                (new string_($this->data[0]->__opaque))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct__opaque_pthread_mutexattr_t_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_mutexattr_t*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_mutexattr_t_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_mutexattr_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr { return new struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_mutexattr_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_mutexattr_t_ptr { return new struct__opaque_pthread_mutexattr_t_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_mutexattr_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_mutexattr_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_mutexattr_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_mutexattr_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_mutexattr_t**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_mutexattr_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_mutexattr_t_ptr_ptr { return new struct__opaque_pthread_mutexattr_t_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_mutexattr_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_mutexattr_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_mutexattr_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_mutexattr_t***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr { return new struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_mutexattr_t****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_once_t implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_once_t $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_once_t_ptr { return new struct__opaque_pthread_once_t_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data->__sig;
            case "__opaque": return new string_($this->data->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data->__sig = $value;
                break;
            case "__opaque":
                (new string_($this->data->__opaque))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct__opaque_pthread_once_t $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_once_t'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_once_t_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_once_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_once_t_ptr_ptr { return new struct__opaque_pthread_once_t_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_once_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_once_t { return new struct__opaque_pthread_once_t($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_once_t[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_once_t($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data[0]->__sig;
            case "__opaque": return new string_($this->data[0]->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data[0]->__sig = $value;
                break;
            case "__opaque":
                (new string_($this->data[0]->__opaque))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct__opaque_pthread_once_t_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_once_t*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_once_t_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_once_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_once_t_ptr_ptr_ptr { return new struct__opaque_pthread_once_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_once_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_once_t_ptr { return new struct__opaque_pthread_once_t_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_once_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_once_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_once_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_once_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_once_t**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_once_t_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_once_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_once_t_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_once_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_once_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_once_t_ptr_ptr { return new struct__opaque_pthread_once_t_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_once_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_once_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_once_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_once_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_once_t***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_once_t_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_once_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_once_t_ptr_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_once_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_once_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_once_t_ptr_ptr_ptr { return new struct__opaque_pthread_once_t_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_once_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_once_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_once_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_once_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_once_t****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_rwlock_t implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_rwlock_t $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_rwlock_t_ptr { return new struct__opaque_pthread_rwlock_t_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data->__sig;
            case "__opaque": return new string_($this->data->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data->__sig = $value;
                break;
            case "__opaque":
                (new string_($this->data->__opaque))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct__opaque_pthread_rwlock_t $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_rwlock_t'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_rwlock_t_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_rwlock_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_rwlock_t_ptr_ptr { return new struct__opaque_pthread_rwlock_t_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_rwlock_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_rwlock_t { return new struct__opaque_pthread_rwlock_t($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_rwlock_t[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_rwlock_t($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data[0]->__sig;
            case "__opaque": return new string_($this->data[0]->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data[0]->__sig = $value;
                break;
            case "__opaque":
                (new string_($this->data[0]->__opaque))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct__opaque_pthread_rwlock_t_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_rwlock_t*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_rwlock_t_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_rwlock_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_rwlock_t_ptr_ptr_ptr { return new struct__opaque_pthread_rwlock_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_rwlock_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_rwlock_t_ptr { return new struct__opaque_pthread_rwlock_t_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_rwlock_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_rwlock_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_rwlock_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_rwlock_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_rwlock_t**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_rwlock_t_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_rwlock_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_rwlock_t_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_rwlock_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_rwlock_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_rwlock_t_ptr_ptr { return new struct__opaque_pthread_rwlock_t_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_rwlock_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_rwlock_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_rwlock_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_rwlock_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_rwlock_t***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_rwlock_t_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_rwlock_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_rwlock_t_ptr_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_rwlock_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_rwlock_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_rwlock_t_ptr_ptr_ptr { return new struct__opaque_pthread_rwlock_t_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_rwlock_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_rwlock_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_rwlock_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_rwlock_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_rwlock_t****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_rwlockattr_t implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_rwlockattr_t $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_rwlockattr_t_ptr { return new struct__opaque_pthread_rwlockattr_t_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data->__sig;
            case "__opaque": return new string_($this->data->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data->__sig = $value;
                break;
            case "__opaque":
                (new string_($this->data->__opaque))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct__opaque_pthread_rwlockattr_t $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_rwlockattr_t'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property string_ $__opaque
 */
class struct__opaque_pthread_rwlockattr_t_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_rwlockattr_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_rwlockattr_t_ptr_ptr { return new struct__opaque_pthread_rwlockattr_t_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_rwlockattr_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_rwlockattr_t { return new struct__opaque_pthread_rwlockattr_t($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_rwlockattr_t[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_rwlockattr_t($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data[0]->__sig;
            case "__opaque": return new string_($this->data[0]->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data[0]->__sig = $value;
                break;
            case "__opaque":
                (new string_($this->data[0]->__opaque))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct__opaque_pthread_rwlockattr_t_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_rwlockattr_t*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_rwlockattr_t_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_rwlockattr_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr { return new struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_rwlockattr_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_rwlockattr_t_ptr { return new struct__opaque_pthread_rwlockattr_t_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_rwlockattr_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_rwlockattr_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_rwlockattr_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_rwlockattr_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_rwlockattr_t**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_rwlockattr_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_rwlockattr_t_ptr_ptr { return new struct__opaque_pthread_rwlockattr_t_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_rwlockattr_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_rwlockattr_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_rwlockattr_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_rwlockattr_t***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr { return new struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_rwlockattr_t****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property struct___darwin_pthread_handler_rec_ptr $__cleanup_stack
 * @property string_ $__opaque
 */
class struct__opaque_pthread_t implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_t $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_t_ptr { return new struct__opaque_pthread_t_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data->__sig;
            case "__cleanup_stack": return new struct___darwin_pthread_handler_rec_ptr($this->data->__cleanup_stack);
            case "__opaque": return new string_($this->data->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data->__sig = $value;
                break;
            case "__cleanup_stack":
                (new struct___darwin_pthread_handler_rec_ptr($this->data->__cleanup_stack))->set($value);
                break;
            case "__opaque":
                (new string_($this->data->__opaque))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct__opaque_pthread_t $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_t'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__sig
 * @property struct___darwin_pthread_handler_rec_ptr $__cleanup_stack
 * @property string_ $__opaque
 */
class struct__opaque_pthread_t_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_t_ptr_ptr { return new struct__opaque_pthread_t_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_t { return new struct__opaque_pthread_t($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_t[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_t($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__sig": return $this->data[0]->__sig;
            case "__cleanup_stack": return new struct___darwin_pthread_handler_rec_ptr($this->data[0]->__cleanup_stack);
            case "__opaque": return new string_($this->data[0]->__opaque);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sig":
                $this->data[0]->__sig = $value;
                break;
            case "__cleanup_stack":
                (new struct___darwin_pthread_handler_rec_ptr($this->data[0]->__cleanup_stack))->set($value);
                break;
            case "__opaque":
                (new string_($this->data[0]->__opaque))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct__opaque_pthread_t_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_t*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_t_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_t_ptr_ptr_ptr { return new struct__opaque_pthread_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_t_ptr { return new struct__opaque_pthread_t_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_t**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_t_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_t_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_t_ptr_ptr { return new struct__opaque_pthread_t_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_t***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct__opaque_pthread_t_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct__opaque_pthread_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct__opaque_pthread_t_ptr_ptr_ptr_ptr_ptr { return new struct__opaque_pthread_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct__opaque_pthread_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct__opaque_pthread_t_ptr_ptr_ptr { return new struct__opaque_pthread_t_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct__opaque_pthread_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct__opaque_pthread_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct__opaque_pthread_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct__opaque_pthread_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct _opaque_pthread_t****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__eax
 * @property int $__ebx
 * @property int $__ecx
 * @property int $__edx
 * @property int $__edi
 * @property int $__esi
 * @property int $__ebp
 * @property int $__esp
 * @property int $__ss
 * @property int $__eflags
 * @property int $__eip
 * @property int $__cs
 * @property int $__ds
 * @property int $__es
 * @property int $__fs
 * @property int $__gs
 */
class struct___darwin_i386_thread_state implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_thread_state $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_thread_state_ptr { return new struct___darwin_i386_thread_state_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__eax": return $this->data->__eax;
            case "__ebx": return $this->data->__ebx;
            case "__ecx": return $this->data->__ecx;
            case "__edx": return $this->data->__edx;
            case "__edi": return $this->data->__edi;
            case "__esi": return $this->data->__esi;
            case "__ebp": return $this->data->__ebp;
            case "__esp": return $this->data->__esp;
            case "__ss": return $this->data->__ss;
            case "__eflags": return $this->data->__eflags;
            case "__eip": return $this->data->__eip;
            case "__cs": return $this->data->__cs;
            case "__ds": return $this->data->__ds;
            case "__es": return $this->data->__es;
            case "__fs": return $this->data->__fs;
            case "__gs": return $this->data->__gs;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__eax":
                $this->data->__eax = $value;
                break;
            case "__ebx":
                $this->data->__ebx = $value;
                break;
            case "__ecx":
                $this->data->__ecx = $value;
                break;
            case "__edx":
                $this->data->__edx = $value;
                break;
            case "__edi":
                $this->data->__edi = $value;
                break;
            case "__esi":
                $this->data->__esi = $value;
                break;
            case "__ebp":
                $this->data->__ebp = $value;
                break;
            case "__esp":
                $this->data->__esp = $value;
                break;
            case "__ss":
                $this->data->__ss = $value;
                break;
            case "__eflags":
                $this->data->__eflags = $value;
                break;
            case "__eip":
                $this->data->__eip = $value;
                break;
            case "__cs":
                $this->data->__cs = $value;
                break;
            case "__ds":
                $this->data->__ds = $value;
                break;
            case "__es":
                $this->data->__es = $value;
                break;
            case "__fs":
                $this->data->__fs = $value;
                break;
            case "__gs":
                $this->data->__gs = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_i386_thread_state $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_thread_state'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__eax
 * @property int $__ebx
 * @property int $__ecx
 * @property int $__edx
 * @property int $__edi
 * @property int $__esi
 * @property int $__ebp
 * @property int $__esp
 * @property int $__ss
 * @property int $__eflags
 * @property int $__eip
 * @property int $__cs
 * @property int $__ds
 * @property int $__es
 * @property int $__fs
 * @property int $__gs
 */
class struct___darwin_i386_thread_state_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_thread_state_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_thread_state_ptr_ptr { return new struct___darwin_i386_thread_state_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_i386_thread_state { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_i386_thread_state { return new struct___darwin_i386_thread_state($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_i386_thread_state[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_i386_thread_state($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__eax": return $this->data[0]->__eax;
            case "__ebx": return $this->data[0]->__ebx;
            case "__ecx": return $this->data[0]->__ecx;
            case "__edx": return $this->data[0]->__edx;
            case "__edi": return $this->data[0]->__edi;
            case "__esi": return $this->data[0]->__esi;
            case "__ebp": return $this->data[0]->__ebp;
            case "__esp": return $this->data[0]->__esp;
            case "__ss": return $this->data[0]->__ss;
            case "__eflags": return $this->data[0]->__eflags;
            case "__eip": return $this->data[0]->__eip;
            case "__cs": return $this->data[0]->__cs;
            case "__ds": return $this->data[0]->__ds;
            case "__es": return $this->data[0]->__es;
            case "__fs": return $this->data[0]->__fs;
            case "__gs": return $this->data[0]->__gs;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__eax":
                $this->data[0]->__eax = $value;
                break;
            case "__ebx":
                $this->data[0]->__ebx = $value;
                break;
            case "__ecx":
                $this->data[0]->__ecx = $value;
                break;
            case "__edx":
                $this->data[0]->__edx = $value;
                break;
            case "__edi":
                $this->data[0]->__edi = $value;
                break;
            case "__esi":
                $this->data[0]->__esi = $value;
                break;
            case "__ebp":
                $this->data[0]->__ebp = $value;
                break;
            case "__esp":
                $this->data[0]->__esp = $value;
                break;
            case "__ss":
                $this->data[0]->__ss = $value;
                break;
            case "__eflags":
                $this->data[0]->__eflags = $value;
                break;
            case "__eip":
                $this->data[0]->__eip = $value;
                break;
            case "__cs":
                $this->data[0]->__cs = $value;
                break;
            case "__ds":
                $this->data[0]->__ds = $value;
                break;
            case "__es":
                $this->data[0]->__es = $value;
                break;
            case "__fs":
                $this->data[0]->__fs = $value;
                break;
            case "__gs":
                $this->data[0]->__gs = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_i386_thread_state_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_thread_state*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_i386_thread_state_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_thread_state_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_thread_state_ptr_ptr_ptr { return new struct___darwin_i386_thread_state_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_i386_thread_state_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_i386_thread_state_ptr { return new struct___darwin_i386_thread_state_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_i386_thread_state_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_i386_thread_state_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_i386_thread_state_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_i386_thread_state_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_thread_state**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_i386_thread_state_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_thread_state_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_thread_state_ptr_ptr_ptr_ptr { return new struct___darwin_i386_thread_state_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_i386_thread_state_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_i386_thread_state_ptr_ptr { return new struct___darwin_i386_thread_state_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_i386_thread_state_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_i386_thread_state_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_i386_thread_state_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_i386_thread_state_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_thread_state***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_i386_thread_state_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_thread_state_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_thread_state_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_i386_thread_state_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_i386_thread_state_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_i386_thread_state_ptr_ptr_ptr { return new struct___darwin_i386_thread_state_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_i386_thread_state_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_i386_thread_state_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_i386_thread_state_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_i386_thread_state_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_thread_state****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__invalid
 * @property int $__denorm
 * @property int $__zdiv
 * @property int $__ovrfl
 * @property int $__undfl
 * @property int $__precis
 * @property int $__pc
 * @property int $__rc
 */
class struct___darwin_fp_control implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_fp_control $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_fp_control_ptr { return new struct___darwin_fp_control_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__invalid": return $this->data->__invalid;
            case "__denorm": return $this->data->__denorm;
            case "__zdiv": return $this->data->__zdiv;
            case "__ovrfl": return $this->data->__ovrfl;
            case "__undfl": return $this->data->__undfl;
            case "__precis": return $this->data->__precis;
            case "__pc": return $this->data->__pc;
            case "__rc": return $this->data->__rc;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__invalid":
                $this->data->__invalid = $value;
                break;
            case "__denorm":
                $this->data->__denorm = $value;
                break;
            case "__zdiv":
                $this->data->__zdiv = $value;
                break;
            case "__ovrfl":
                $this->data->__ovrfl = $value;
                break;
            case "__undfl":
                $this->data->__undfl = $value;
                break;
            case "__precis":
                $this->data->__precis = $value;
                break;
            case "__pc":
                $this->data->__pc = $value;
                break;
            case "__rc":
                $this->data->__rc = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_fp_control $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_fp_control'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__invalid
 * @property int $__denorm
 * @property int $__zdiv
 * @property int $__ovrfl
 * @property int $__undfl
 * @property int $__precis
 * @property int $__pc
 * @property int $__rc
 */
class struct___darwin_fp_control_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_fp_control_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_fp_control_ptr_ptr { return new struct___darwin_fp_control_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_fp_control { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_fp_control { return new struct___darwin_fp_control($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_fp_control[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_fp_control($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__invalid": return $this->data[0]->__invalid;
            case "__denorm": return $this->data[0]->__denorm;
            case "__zdiv": return $this->data[0]->__zdiv;
            case "__ovrfl": return $this->data[0]->__ovrfl;
            case "__undfl": return $this->data[0]->__undfl;
            case "__precis": return $this->data[0]->__precis;
            case "__pc": return $this->data[0]->__pc;
            case "__rc": return $this->data[0]->__rc;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__invalid":
                $this->data[0]->__invalid = $value;
                break;
            case "__denorm":
                $this->data[0]->__denorm = $value;
                break;
            case "__zdiv":
                $this->data[0]->__zdiv = $value;
                break;
            case "__ovrfl":
                $this->data[0]->__ovrfl = $value;
                break;
            case "__undfl":
                $this->data[0]->__undfl = $value;
                break;
            case "__precis":
                $this->data[0]->__precis = $value;
                break;
            case "__pc":
                $this->data[0]->__pc = $value;
                break;
            case "__rc":
                $this->data[0]->__rc = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_fp_control_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_fp_control*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_fp_control_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_fp_control_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_fp_control_ptr_ptr_ptr { return new struct___darwin_fp_control_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_fp_control_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_fp_control_ptr { return new struct___darwin_fp_control_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_fp_control_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_fp_control_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_fp_control_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_fp_control_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_fp_control**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_fp_control_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_fp_control_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_fp_control_ptr_ptr_ptr_ptr { return new struct___darwin_fp_control_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_fp_control_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_fp_control_ptr_ptr { return new struct___darwin_fp_control_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_fp_control_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_fp_control_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_fp_control_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_fp_control_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_fp_control***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_fp_control_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_fp_control_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_fp_control_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_fp_control_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_fp_control_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_fp_control_ptr_ptr_ptr { return new struct___darwin_fp_control_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_fp_control_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_fp_control_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_fp_control_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_fp_control_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_fp_control****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__invalid
 * @property int $__denorm
 * @property int $__zdiv
 * @property int $__ovrfl
 * @property int $__undfl
 * @property int $__precis
 * @property int $__stkflt
 * @property int $__errsumm
 * @property int $__c0
 * @property int $__c1
 * @property int $__c2
 * @property int $__tos
 * @property int $__c3
 * @property int $__busy
 */
class struct___darwin_fp_status implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_fp_status $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_fp_status_ptr { return new struct___darwin_fp_status_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__invalid": return $this->data->__invalid;
            case "__denorm": return $this->data->__denorm;
            case "__zdiv": return $this->data->__zdiv;
            case "__ovrfl": return $this->data->__ovrfl;
            case "__undfl": return $this->data->__undfl;
            case "__precis": return $this->data->__precis;
            case "__stkflt": return $this->data->__stkflt;
            case "__errsumm": return $this->data->__errsumm;
            case "__c0": return $this->data->__c0;
            case "__c1": return $this->data->__c1;
            case "__c2": return $this->data->__c2;
            case "__tos": return $this->data->__tos;
            case "__c3": return $this->data->__c3;
            case "__busy": return $this->data->__busy;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__invalid":
                $this->data->__invalid = $value;
                break;
            case "__denorm":
                $this->data->__denorm = $value;
                break;
            case "__zdiv":
                $this->data->__zdiv = $value;
                break;
            case "__ovrfl":
                $this->data->__ovrfl = $value;
                break;
            case "__undfl":
                $this->data->__undfl = $value;
                break;
            case "__precis":
                $this->data->__precis = $value;
                break;
            case "__stkflt":
                $this->data->__stkflt = $value;
                break;
            case "__errsumm":
                $this->data->__errsumm = $value;
                break;
            case "__c0":
                $this->data->__c0 = $value;
                break;
            case "__c1":
                $this->data->__c1 = $value;
                break;
            case "__c2":
                $this->data->__c2 = $value;
                break;
            case "__tos":
                $this->data->__tos = $value;
                break;
            case "__c3":
                $this->data->__c3 = $value;
                break;
            case "__busy":
                $this->data->__busy = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_fp_status $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_fp_status'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__invalid
 * @property int $__denorm
 * @property int $__zdiv
 * @property int $__ovrfl
 * @property int $__undfl
 * @property int $__precis
 * @property int $__stkflt
 * @property int $__errsumm
 * @property int $__c0
 * @property int $__c1
 * @property int $__c2
 * @property int $__tos
 * @property int $__c3
 * @property int $__busy
 */
class struct___darwin_fp_status_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_fp_status_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_fp_status_ptr_ptr { return new struct___darwin_fp_status_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_fp_status { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_fp_status { return new struct___darwin_fp_status($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_fp_status[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_fp_status($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__invalid": return $this->data[0]->__invalid;
            case "__denorm": return $this->data[0]->__denorm;
            case "__zdiv": return $this->data[0]->__zdiv;
            case "__ovrfl": return $this->data[0]->__ovrfl;
            case "__undfl": return $this->data[0]->__undfl;
            case "__precis": return $this->data[0]->__precis;
            case "__stkflt": return $this->data[0]->__stkflt;
            case "__errsumm": return $this->data[0]->__errsumm;
            case "__c0": return $this->data[0]->__c0;
            case "__c1": return $this->data[0]->__c1;
            case "__c2": return $this->data[0]->__c2;
            case "__tos": return $this->data[0]->__tos;
            case "__c3": return $this->data[0]->__c3;
            case "__busy": return $this->data[0]->__busy;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__invalid":
                $this->data[0]->__invalid = $value;
                break;
            case "__denorm":
                $this->data[0]->__denorm = $value;
                break;
            case "__zdiv":
                $this->data[0]->__zdiv = $value;
                break;
            case "__ovrfl":
                $this->data[0]->__ovrfl = $value;
                break;
            case "__undfl":
                $this->data[0]->__undfl = $value;
                break;
            case "__precis":
                $this->data[0]->__precis = $value;
                break;
            case "__stkflt":
                $this->data[0]->__stkflt = $value;
                break;
            case "__errsumm":
                $this->data[0]->__errsumm = $value;
                break;
            case "__c0":
                $this->data[0]->__c0 = $value;
                break;
            case "__c1":
                $this->data[0]->__c1 = $value;
                break;
            case "__c2":
                $this->data[0]->__c2 = $value;
                break;
            case "__tos":
                $this->data[0]->__tos = $value;
                break;
            case "__c3":
                $this->data[0]->__c3 = $value;
                break;
            case "__busy":
                $this->data[0]->__busy = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_fp_status_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_fp_status*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_fp_status_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_fp_status_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_fp_status_ptr_ptr_ptr { return new struct___darwin_fp_status_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_fp_status_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_fp_status_ptr { return new struct___darwin_fp_status_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_fp_status_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_fp_status_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_fp_status_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_fp_status_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_fp_status**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_fp_status_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_fp_status_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_fp_status_ptr_ptr_ptr_ptr { return new struct___darwin_fp_status_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_fp_status_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_fp_status_ptr_ptr { return new struct___darwin_fp_status_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_fp_status_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_fp_status_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_fp_status_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_fp_status_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_fp_status***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_fp_status_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_fp_status_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_fp_status_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_fp_status_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_fp_status_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_fp_status_ptr_ptr_ptr { return new struct___darwin_fp_status_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_fp_status_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_fp_status_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_fp_status_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_fp_status_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_fp_status****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property string_ $__mmst_reg
 * @property string_ $__mmst_rsrv
 */
class struct___darwin_mmst_reg implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mmst_reg $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mmst_reg_ptr { return new struct___darwin_mmst_reg_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__mmst_reg": return new string_($this->data->__mmst_reg);
            case "__mmst_rsrv": return new string_($this->data->__mmst_rsrv);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__mmst_reg":
                (new string_($this->data->__mmst_reg))->set($value);
                break;
            case "__mmst_rsrv":
                (new string_($this->data->__mmst_rsrv))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_mmst_reg $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mmst_reg'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property string_ $__mmst_reg
 * @property string_ $__mmst_rsrv
 */
class struct___darwin_mmst_reg_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mmst_reg_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mmst_reg_ptr_ptr { return new struct___darwin_mmst_reg_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mmst_reg { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mmst_reg { return new struct___darwin_mmst_reg($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mmst_reg[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mmst_reg($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__mmst_reg": return new string_($this->data[0]->__mmst_reg);
            case "__mmst_rsrv": return new string_($this->data[0]->__mmst_rsrv);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__mmst_reg":
                (new string_($this->data[0]->__mmst_reg))->set($value);
                break;
            case "__mmst_rsrv":
                (new string_($this->data[0]->__mmst_rsrv))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_mmst_reg_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mmst_reg*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mmst_reg_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mmst_reg_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mmst_reg_ptr_ptr_ptr { return new struct___darwin_mmst_reg_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mmst_reg_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mmst_reg_ptr { return new struct___darwin_mmst_reg_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mmst_reg_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mmst_reg_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mmst_reg_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mmst_reg_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mmst_reg**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mmst_reg_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mmst_reg_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mmst_reg_ptr_ptr_ptr_ptr { return new struct___darwin_mmst_reg_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mmst_reg_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mmst_reg_ptr_ptr { return new struct___darwin_mmst_reg_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mmst_reg_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mmst_reg_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mmst_reg_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mmst_reg_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mmst_reg***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mmst_reg_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mmst_reg_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mmst_reg_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_mmst_reg_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mmst_reg_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mmst_reg_ptr_ptr_ptr { return new struct___darwin_mmst_reg_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mmst_reg_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mmst_reg_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mmst_reg_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mmst_reg_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mmst_reg****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property string_ $__xmm_reg
 */
class struct___darwin_xmm_reg implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_xmm_reg $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_xmm_reg_ptr { return new struct___darwin_xmm_reg_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__xmm_reg": return new string_($this->data->__xmm_reg);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__xmm_reg":
                (new string_($this->data->__xmm_reg))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_xmm_reg $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_xmm_reg'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property string_ $__xmm_reg
 */
class struct___darwin_xmm_reg_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_xmm_reg_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_xmm_reg_ptr_ptr { return new struct___darwin_xmm_reg_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_xmm_reg { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_xmm_reg { return new struct___darwin_xmm_reg($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_xmm_reg[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_xmm_reg($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__xmm_reg": return new string_($this->data[0]->__xmm_reg);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__xmm_reg":
                (new string_($this->data[0]->__xmm_reg))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_xmm_reg_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_xmm_reg*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_xmm_reg_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_xmm_reg_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_xmm_reg_ptr_ptr_ptr { return new struct___darwin_xmm_reg_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_xmm_reg_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_xmm_reg_ptr { return new struct___darwin_xmm_reg_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_xmm_reg_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_xmm_reg_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_xmm_reg_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_xmm_reg_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_xmm_reg**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_xmm_reg_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_xmm_reg_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_xmm_reg_ptr_ptr_ptr_ptr { return new struct___darwin_xmm_reg_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_xmm_reg_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_xmm_reg_ptr_ptr { return new struct___darwin_xmm_reg_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_xmm_reg_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_xmm_reg_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_xmm_reg_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_xmm_reg_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_xmm_reg***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_xmm_reg_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_xmm_reg_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_xmm_reg_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_xmm_reg_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_xmm_reg_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_xmm_reg_ptr_ptr_ptr { return new struct___darwin_xmm_reg_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_xmm_reg_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_xmm_reg_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_xmm_reg_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_xmm_reg_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_xmm_reg****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property string_ $__ymm_reg
 */
class struct___darwin_ymm_reg implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_ymm_reg $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_ymm_reg_ptr { return new struct___darwin_ymm_reg_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__ymm_reg": return new string_($this->data->__ymm_reg);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__ymm_reg":
                (new string_($this->data->__ymm_reg))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_ymm_reg $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_ymm_reg'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property string_ $__ymm_reg
 */
class struct___darwin_ymm_reg_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_ymm_reg_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_ymm_reg_ptr_ptr { return new struct___darwin_ymm_reg_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_ymm_reg { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_ymm_reg { return new struct___darwin_ymm_reg($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_ymm_reg[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_ymm_reg($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__ymm_reg": return new string_($this->data[0]->__ymm_reg);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__ymm_reg":
                (new string_($this->data[0]->__ymm_reg))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_ymm_reg_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_ymm_reg*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_ymm_reg_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_ymm_reg_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_ymm_reg_ptr_ptr_ptr { return new struct___darwin_ymm_reg_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_ymm_reg_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_ymm_reg_ptr { return new struct___darwin_ymm_reg_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_ymm_reg_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_ymm_reg_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_ymm_reg_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_ymm_reg_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_ymm_reg**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_ymm_reg_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_ymm_reg_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_ymm_reg_ptr_ptr_ptr_ptr { return new struct___darwin_ymm_reg_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_ymm_reg_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_ymm_reg_ptr_ptr { return new struct___darwin_ymm_reg_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_ymm_reg_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_ymm_reg_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_ymm_reg_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_ymm_reg_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_ymm_reg***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_ymm_reg_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_ymm_reg_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_ymm_reg_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_ymm_reg_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_ymm_reg_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_ymm_reg_ptr_ptr_ptr { return new struct___darwin_ymm_reg_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_ymm_reg_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_ymm_reg_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_ymm_reg_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_ymm_reg_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_ymm_reg****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property string_ $__zmm_reg
 */
class struct___darwin_zmm_reg implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_zmm_reg $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_zmm_reg_ptr { return new struct___darwin_zmm_reg_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__zmm_reg": return new string_($this->data->__zmm_reg);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__zmm_reg":
                (new string_($this->data->__zmm_reg))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_zmm_reg $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_zmm_reg'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property string_ $__zmm_reg
 */
class struct___darwin_zmm_reg_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_zmm_reg_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_zmm_reg_ptr_ptr { return new struct___darwin_zmm_reg_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_zmm_reg { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_zmm_reg { return new struct___darwin_zmm_reg($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_zmm_reg[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_zmm_reg($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__zmm_reg": return new string_($this->data[0]->__zmm_reg);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__zmm_reg":
                (new string_($this->data[0]->__zmm_reg))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_zmm_reg_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_zmm_reg*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_zmm_reg_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_zmm_reg_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_zmm_reg_ptr_ptr_ptr { return new struct___darwin_zmm_reg_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_zmm_reg_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_zmm_reg_ptr { return new struct___darwin_zmm_reg_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_zmm_reg_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_zmm_reg_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_zmm_reg_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_zmm_reg_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_zmm_reg**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_zmm_reg_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_zmm_reg_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_zmm_reg_ptr_ptr_ptr_ptr { return new struct___darwin_zmm_reg_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_zmm_reg_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_zmm_reg_ptr_ptr { return new struct___darwin_zmm_reg_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_zmm_reg_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_zmm_reg_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_zmm_reg_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_zmm_reg_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_zmm_reg***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_zmm_reg_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_zmm_reg_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_zmm_reg_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_zmm_reg_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_zmm_reg_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_zmm_reg_ptr_ptr_ptr { return new struct___darwin_zmm_reg_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_zmm_reg_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_zmm_reg_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_zmm_reg_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_zmm_reg_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_zmm_reg****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property string_ $__opmask_reg
 */
class struct___darwin_opmask_reg implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_opmask_reg $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_opmask_reg_ptr { return new struct___darwin_opmask_reg_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__opmask_reg": return new string_($this->data->__opmask_reg);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__opmask_reg":
                (new string_($this->data->__opmask_reg))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_opmask_reg $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_opmask_reg'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property string_ $__opmask_reg
 */
class struct___darwin_opmask_reg_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_opmask_reg_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_opmask_reg_ptr_ptr { return new struct___darwin_opmask_reg_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_opmask_reg { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_opmask_reg { return new struct___darwin_opmask_reg($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_opmask_reg[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_opmask_reg($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__opmask_reg": return new string_($this->data[0]->__opmask_reg);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__opmask_reg":
                (new string_($this->data[0]->__opmask_reg))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_opmask_reg_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_opmask_reg*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_opmask_reg_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_opmask_reg_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_opmask_reg_ptr_ptr_ptr { return new struct___darwin_opmask_reg_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_opmask_reg_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_opmask_reg_ptr { return new struct___darwin_opmask_reg_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_opmask_reg_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_opmask_reg_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_opmask_reg_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_opmask_reg_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_opmask_reg**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_opmask_reg_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_opmask_reg_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_opmask_reg_ptr_ptr_ptr_ptr { return new struct___darwin_opmask_reg_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_opmask_reg_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_opmask_reg_ptr_ptr { return new struct___darwin_opmask_reg_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_opmask_reg_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_opmask_reg_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_opmask_reg_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_opmask_reg_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_opmask_reg***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_opmask_reg_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_opmask_reg_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_opmask_reg_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_opmask_reg_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_opmask_reg_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_opmask_reg_ptr_ptr_ptr { return new struct___darwin_opmask_reg_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_opmask_reg_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_opmask_reg_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_opmask_reg_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_opmask_reg_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_opmask_reg****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int_ptr $__fpu_reserved
 * @property struct___darwin_fp_control $__fpu_fcw
 * @property struct___darwin_fp_status $__fpu_fsw
 * @property int $__fpu_ftw
 * @property int $__fpu_rsrv1
 * @property int $__fpu_fop
 * @property int $__fpu_ip
 * @property int $__fpu_cs
 * @property int $__fpu_rsrv2
 * @property int $__fpu_dp
 * @property int $__fpu_ds
 * @property int $__fpu_rsrv3
 * @property int $__fpu_mxcsr
 * @property int $__fpu_mxcsrmask
 * @property struct___darwin_mmst_reg $__fpu_stmm0
 * @property struct___darwin_mmst_reg $__fpu_stmm1
 * @property struct___darwin_mmst_reg $__fpu_stmm2
 * @property struct___darwin_mmst_reg $__fpu_stmm3
 * @property struct___darwin_mmst_reg $__fpu_stmm4
 * @property struct___darwin_mmst_reg $__fpu_stmm5
 * @property struct___darwin_mmst_reg $__fpu_stmm6
 * @property struct___darwin_mmst_reg $__fpu_stmm7
 * @property struct___darwin_xmm_reg $__fpu_xmm0
 * @property struct___darwin_xmm_reg $__fpu_xmm1
 * @property struct___darwin_xmm_reg $__fpu_xmm2
 * @property struct___darwin_xmm_reg $__fpu_xmm3
 * @property struct___darwin_xmm_reg $__fpu_xmm4
 * @property struct___darwin_xmm_reg $__fpu_xmm5
 * @property struct___darwin_xmm_reg $__fpu_xmm6
 * @property struct___darwin_xmm_reg $__fpu_xmm7
 * @property string_ $__fpu_rsrv4
 * @property int $__fpu_reserved1
 */
class struct___darwin_i386_float_state implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_float_state $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_float_state_ptr { return new struct___darwin_i386_float_state_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__fpu_reserved": return new int_ptr($this->data->__fpu_reserved);
            case "__fpu_fcw": return new struct___darwin_fp_control($this->data->__fpu_fcw);
            case "__fpu_fsw": return new struct___darwin_fp_status($this->data->__fpu_fsw);
            case "__fpu_ftw": return $this->data->__fpu_ftw;
            case "__fpu_rsrv1": return $this->data->__fpu_rsrv1;
            case "__fpu_fop": return $this->data->__fpu_fop;
            case "__fpu_ip": return $this->data->__fpu_ip;
            case "__fpu_cs": return $this->data->__fpu_cs;
            case "__fpu_rsrv2": return $this->data->__fpu_rsrv2;
            case "__fpu_dp": return $this->data->__fpu_dp;
            case "__fpu_ds": return $this->data->__fpu_ds;
            case "__fpu_rsrv3": return $this->data->__fpu_rsrv3;
            case "__fpu_mxcsr": return $this->data->__fpu_mxcsr;
            case "__fpu_mxcsrmask": return $this->data->__fpu_mxcsrmask;
            case "__fpu_stmm0": return new struct___darwin_mmst_reg($this->data->__fpu_stmm0);
            case "__fpu_stmm1": return new struct___darwin_mmst_reg($this->data->__fpu_stmm1);
            case "__fpu_stmm2": return new struct___darwin_mmst_reg($this->data->__fpu_stmm2);
            case "__fpu_stmm3": return new struct___darwin_mmst_reg($this->data->__fpu_stmm3);
            case "__fpu_stmm4": return new struct___darwin_mmst_reg($this->data->__fpu_stmm4);
            case "__fpu_stmm5": return new struct___darwin_mmst_reg($this->data->__fpu_stmm5);
            case "__fpu_stmm6": return new struct___darwin_mmst_reg($this->data->__fpu_stmm6);
            case "__fpu_stmm7": return new struct___darwin_mmst_reg($this->data->__fpu_stmm7);
            case "__fpu_xmm0": return new struct___darwin_xmm_reg($this->data->__fpu_xmm0);
            case "__fpu_xmm1": return new struct___darwin_xmm_reg($this->data->__fpu_xmm1);
            case "__fpu_xmm2": return new struct___darwin_xmm_reg($this->data->__fpu_xmm2);
            case "__fpu_xmm3": return new struct___darwin_xmm_reg($this->data->__fpu_xmm3);
            case "__fpu_xmm4": return new struct___darwin_xmm_reg($this->data->__fpu_xmm4);
            case "__fpu_xmm5": return new struct___darwin_xmm_reg($this->data->__fpu_xmm5);
            case "__fpu_xmm6": return new struct___darwin_xmm_reg($this->data->__fpu_xmm6);
            case "__fpu_xmm7": return new struct___darwin_xmm_reg($this->data->__fpu_xmm7);
            case "__fpu_rsrv4": return new string_($this->data->__fpu_rsrv4);
            case "__fpu_reserved1": return $this->data->__fpu_reserved1;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__fpu_reserved":
                (new int_ptr($this->data->__fpu_reserved))->set($value);
                break;
            case "__fpu_fcw":
                (new struct___darwin_fp_control($this->data->__fpu_fcw))->set($value);
                break;
            case "__fpu_fsw":
                (new struct___darwin_fp_status($this->data->__fpu_fsw))->set($value);
                break;
            case "__fpu_ftw":
                $this->data->__fpu_ftw = $value;
                break;
            case "__fpu_rsrv1":
                $this->data->__fpu_rsrv1 = $value;
                break;
            case "__fpu_fop":
                $this->data->__fpu_fop = $value;
                break;
            case "__fpu_ip":
                $this->data->__fpu_ip = $value;
                break;
            case "__fpu_cs":
                $this->data->__fpu_cs = $value;
                break;
            case "__fpu_rsrv2":
                $this->data->__fpu_rsrv2 = $value;
                break;
            case "__fpu_dp":
                $this->data->__fpu_dp = $value;
                break;
            case "__fpu_ds":
                $this->data->__fpu_ds = $value;
                break;
            case "__fpu_rsrv3":
                $this->data->__fpu_rsrv3 = $value;
                break;
            case "__fpu_mxcsr":
                $this->data->__fpu_mxcsr = $value;
                break;
            case "__fpu_mxcsrmask":
                $this->data->__fpu_mxcsrmask = $value;
                break;
            case "__fpu_stmm0":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm0))->set($value);
                break;
            case "__fpu_stmm1":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm1))->set($value);
                break;
            case "__fpu_stmm2":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm2))->set($value);
                break;
            case "__fpu_stmm3":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm3))->set($value);
                break;
            case "__fpu_stmm4":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm4))->set($value);
                break;
            case "__fpu_stmm5":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm5))->set($value);
                break;
            case "__fpu_stmm6":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm6))->set($value);
                break;
            case "__fpu_stmm7":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm7))->set($value);
                break;
            case "__fpu_xmm0":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm0))->set($value);
                break;
            case "__fpu_xmm1":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm1))->set($value);
                break;
            case "__fpu_xmm2":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm2))->set($value);
                break;
            case "__fpu_xmm3":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm3))->set($value);
                break;
            case "__fpu_xmm4":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm4))->set($value);
                break;
            case "__fpu_xmm5":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm5))->set($value);
                break;
            case "__fpu_xmm6":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm6))->set($value);
                break;
            case "__fpu_xmm7":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm7))->set($value);
                break;
            case "__fpu_rsrv4":
                (new string_($this->data->__fpu_rsrv4))->set($value);
                break;
            case "__fpu_reserved1":
                $this->data->__fpu_reserved1 = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_i386_float_state $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_float_state'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int_ptr $__fpu_reserved
 * @property struct___darwin_fp_control $__fpu_fcw
 * @property struct___darwin_fp_status $__fpu_fsw
 * @property int $__fpu_ftw
 * @property int $__fpu_rsrv1
 * @property int $__fpu_fop
 * @property int $__fpu_ip
 * @property int $__fpu_cs
 * @property int $__fpu_rsrv2
 * @property int $__fpu_dp
 * @property int $__fpu_ds
 * @property int $__fpu_rsrv3
 * @property int $__fpu_mxcsr
 * @property int $__fpu_mxcsrmask
 * @property struct___darwin_mmst_reg $__fpu_stmm0
 * @property struct___darwin_mmst_reg $__fpu_stmm1
 * @property struct___darwin_mmst_reg $__fpu_stmm2
 * @property struct___darwin_mmst_reg $__fpu_stmm3
 * @property struct___darwin_mmst_reg $__fpu_stmm4
 * @property struct___darwin_mmst_reg $__fpu_stmm5
 * @property struct___darwin_mmst_reg $__fpu_stmm6
 * @property struct___darwin_mmst_reg $__fpu_stmm7
 * @property struct___darwin_xmm_reg $__fpu_xmm0
 * @property struct___darwin_xmm_reg $__fpu_xmm1
 * @property struct___darwin_xmm_reg $__fpu_xmm2
 * @property struct___darwin_xmm_reg $__fpu_xmm3
 * @property struct___darwin_xmm_reg $__fpu_xmm4
 * @property struct___darwin_xmm_reg $__fpu_xmm5
 * @property struct___darwin_xmm_reg $__fpu_xmm6
 * @property struct___darwin_xmm_reg $__fpu_xmm7
 * @property string_ $__fpu_rsrv4
 * @property int $__fpu_reserved1
 */
class struct___darwin_i386_float_state_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_float_state_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_float_state_ptr_ptr { return new struct___darwin_i386_float_state_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_i386_float_state { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_i386_float_state { return new struct___darwin_i386_float_state($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_i386_float_state[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_i386_float_state($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__fpu_reserved": return new int_ptr($this->data[0]->__fpu_reserved);
            case "__fpu_fcw": return new struct___darwin_fp_control($this->data[0]->__fpu_fcw);
            case "__fpu_fsw": return new struct___darwin_fp_status($this->data[0]->__fpu_fsw);
            case "__fpu_ftw": return $this->data[0]->__fpu_ftw;
            case "__fpu_rsrv1": return $this->data[0]->__fpu_rsrv1;
            case "__fpu_fop": return $this->data[0]->__fpu_fop;
            case "__fpu_ip": return $this->data[0]->__fpu_ip;
            case "__fpu_cs": return $this->data[0]->__fpu_cs;
            case "__fpu_rsrv2": return $this->data[0]->__fpu_rsrv2;
            case "__fpu_dp": return $this->data[0]->__fpu_dp;
            case "__fpu_ds": return $this->data[0]->__fpu_ds;
            case "__fpu_rsrv3": return $this->data[0]->__fpu_rsrv3;
            case "__fpu_mxcsr": return $this->data[0]->__fpu_mxcsr;
            case "__fpu_mxcsrmask": return $this->data[0]->__fpu_mxcsrmask;
            case "__fpu_stmm0": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm0);
            case "__fpu_stmm1": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm1);
            case "__fpu_stmm2": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm2);
            case "__fpu_stmm3": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm3);
            case "__fpu_stmm4": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm4);
            case "__fpu_stmm5": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm5);
            case "__fpu_stmm6": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm6);
            case "__fpu_stmm7": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm7);
            case "__fpu_xmm0": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm0);
            case "__fpu_xmm1": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm1);
            case "__fpu_xmm2": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm2);
            case "__fpu_xmm3": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm3);
            case "__fpu_xmm4": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm4);
            case "__fpu_xmm5": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm5);
            case "__fpu_xmm6": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm6);
            case "__fpu_xmm7": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm7);
            case "__fpu_rsrv4": return new string_($this->data[0]->__fpu_rsrv4);
            case "__fpu_reserved1": return $this->data[0]->__fpu_reserved1;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__fpu_reserved":
                (new int_ptr($this->data[0]->__fpu_reserved))->set($value);
                break;
            case "__fpu_fcw":
                (new struct___darwin_fp_control($this->data[0]->__fpu_fcw))->set($value);
                break;
            case "__fpu_fsw":
                (new struct___darwin_fp_status($this->data[0]->__fpu_fsw))->set($value);
                break;
            case "__fpu_ftw":
                $this->data[0]->__fpu_ftw = $value;
                break;
            case "__fpu_rsrv1":
                $this->data[0]->__fpu_rsrv1 = $value;
                break;
            case "__fpu_fop":
                $this->data[0]->__fpu_fop = $value;
                break;
            case "__fpu_ip":
                $this->data[0]->__fpu_ip = $value;
                break;
            case "__fpu_cs":
                $this->data[0]->__fpu_cs = $value;
                break;
            case "__fpu_rsrv2":
                $this->data[0]->__fpu_rsrv2 = $value;
                break;
            case "__fpu_dp":
                $this->data[0]->__fpu_dp = $value;
                break;
            case "__fpu_ds":
                $this->data[0]->__fpu_ds = $value;
                break;
            case "__fpu_rsrv3":
                $this->data[0]->__fpu_rsrv3 = $value;
                break;
            case "__fpu_mxcsr":
                $this->data[0]->__fpu_mxcsr = $value;
                break;
            case "__fpu_mxcsrmask":
                $this->data[0]->__fpu_mxcsrmask = $value;
                break;
            case "__fpu_stmm0":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm0))->set($value);
                break;
            case "__fpu_stmm1":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm1))->set($value);
                break;
            case "__fpu_stmm2":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm2))->set($value);
                break;
            case "__fpu_stmm3":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm3))->set($value);
                break;
            case "__fpu_stmm4":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm4))->set($value);
                break;
            case "__fpu_stmm5":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm5))->set($value);
                break;
            case "__fpu_stmm6":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm6))->set($value);
                break;
            case "__fpu_stmm7":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm7))->set($value);
                break;
            case "__fpu_xmm0":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm0))->set($value);
                break;
            case "__fpu_xmm1":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm1))->set($value);
                break;
            case "__fpu_xmm2":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm2))->set($value);
                break;
            case "__fpu_xmm3":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm3))->set($value);
                break;
            case "__fpu_xmm4":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm4))->set($value);
                break;
            case "__fpu_xmm5":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm5))->set($value);
                break;
            case "__fpu_xmm6":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm6))->set($value);
                break;
            case "__fpu_xmm7":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm7))->set($value);
                break;
            case "__fpu_rsrv4":
                (new string_($this->data[0]->__fpu_rsrv4))->set($value);
                break;
            case "__fpu_reserved1":
                $this->data[0]->__fpu_reserved1 = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_i386_float_state_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_float_state*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_i386_float_state_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_float_state_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_float_state_ptr_ptr_ptr { return new struct___darwin_i386_float_state_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_i386_float_state_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_i386_float_state_ptr { return new struct___darwin_i386_float_state_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_i386_float_state_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_i386_float_state_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_i386_float_state_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_i386_float_state_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_float_state**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_i386_float_state_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_float_state_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_float_state_ptr_ptr_ptr_ptr { return new struct___darwin_i386_float_state_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_i386_float_state_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_i386_float_state_ptr_ptr { return new struct___darwin_i386_float_state_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_i386_float_state_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_i386_float_state_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_i386_float_state_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_i386_float_state_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_float_state***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_i386_float_state_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_float_state_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_float_state_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_i386_float_state_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_i386_float_state_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_i386_float_state_ptr_ptr_ptr { return new struct___darwin_i386_float_state_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_i386_float_state_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_i386_float_state_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_i386_float_state_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_i386_float_state_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_float_state****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int_ptr $__fpu_reserved
 * @property struct___darwin_fp_control $__fpu_fcw
 * @property struct___darwin_fp_status $__fpu_fsw
 * @property int $__fpu_ftw
 * @property int $__fpu_rsrv1
 * @property int $__fpu_fop
 * @property int $__fpu_ip
 * @property int $__fpu_cs
 * @property int $__fpu_rsrv2
 * @property int $__fpu_dp
 * @property int $__fpu_ds
 * @property int $__fpu_rsrv3
 * @property int $__fpu_mxcsr
 * @property int $__fpu_mxcsrmask
 * @property struct___darwin_mmst_reg $__fpu_stmm0
 * @property struct___darwin_mmst_reg $__fpu_stmm1
 * @property struct___darwin_mmst_reg $__fpu_stmm2
 * @property struct___darwin_mmst_reg $__fpu_stmm3
 * @property struct___darwin_mmst_reg $__fpu_stmm4
 * @property struct___darwin_mmst_reg $__fpu_stmm5
 * @property struct___darwin_mmst_reg $__fpu_stmm6
 * @property struct___darwin_mmst_reg $__fpu_stmm7
 * @property struct___darwin_xmm_reg $__fpu_xmm0
 * @property struct___darwin_xmm_reg $__fpu_xmm1
 * @property struct___darwin_xmm_reg $__fpu_xmm2
 * @property struct___darwin_xmm_reg $__fpu_xmm3
 * @property struct___darwin_xmm_reg $__fpu_xmm4
 * @property struct___darwin_xmm_reg $__fpu_xmm5
 * @property struct___darwin_xmm_reg $__fpu_xmm6
 * @property struct___darwin_xmm_reg $__fpu_xmm7
 * @property string_ $__fpu_rsrv4
 * @property int $__fpu_reserved1
 * @property string_ $__avx_reserved1
 * @property struct___darwin_xmm_reg $__fpu_ymmh0
 * @property struct___darwin_xmm_reg $__fpu_ymmh1
 * @property struct___darwin_xmm_reg $__fpu_ymmh2
 * @property struct___darwin_xmm_reg $__fpu_ymmh3
 * @property struct___darwin_xmm_reg $__fpu_ymmh4
 * @property struct___darwin_xmm_reg $__fpu_ymmh5
 * @property struct___darwin_xmm_reg $__fpu_ymmh6
 * @property struct___darwin_xmm_reg $__fpu_ymmh7
 */
class struct___darwin_i386_avx_state implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_avx_state $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_avx_state_ptr { return new struct___darwin_i386_avx_state_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__fpu_reserved": return new int_ptr($this->data->__fpu_reserved);
            case "__fpu_fcw": return new struct___darwin_fp_control($this->data->__fpu_fcw);
            case "__fpu_fsw": return new struct___darwin_fp_status($this->data->__fpu_fsw);
            case "__fpu_ftw": return $this->data->__fpu_ftw;
            case "__fpu_rsrv1": return $this->data->__fpu_rsrv1;
            case "__fpu_fop": return $this->data->__fpu_fop;
            case "__fpu_ip": return $this->data->__fpu_ip;
            case "__fpu_cs": return $this->data->__fpu_cs;
            case "__fpu_rsrv2": return $this->data->__fpu_rsrv2;
            case "__fpu_dp": return $this->data->__fpu_dp;
            case "__fpu_ds": return $this->data->__fpu_ds;
            case "__fpu_rsrv3": return $this->data->__fpu_rsrv3;
            case "__fpu_mxcsr": return $this->data->__fpu_mxcsr;
            case "__fpu_mxcsrmask": return $this->data->__fpu_mxcsrmask;
            case "__fpu_stmm0": return new struct___darwin_mmst_reg($this->data->__fpu_stmm0);
            case "__fpu_stmm1": return new struct___darwin_mmst_reg($this->data->__fpu_stmm1);
            case "__fpu_stmm2": return new struct___darwin_mmst_reg($this->data->__fpu_stmm2);
            case "__fpu_stmm3": return new struct___darwin_mmst_reg($this->data->__fpu_stmm3);
            case "__fpu_stmm4": return new struct___darwin_mmst_reg($this->data->__fpu_stmm4);
            case "__fpu_stmm5": return new struct___darwin_mmst_reg($this->data->__fpu_stmm5);
            case "__fpu_stmm6": return new struct___darwin_mmst_reg($this->data->__fpu_stmm6);
            case "__fpu_stmm7": return new struct___darwin_mmst_reg($this->data->__fpu_stmm7);
            case "__fpu_xmm0": return new struct___darwin_xmm_reg($this->data->__fpu_xmm0);
            case "__fpu_xmm1": return new struct___darwin_xmm_reg($this->data->__fpu_xmm1);
            case "__fpu_xmm2": return new struct___darwin_xmm_reg($this->data->__fpu_xmm2);
            case "__fpu_xmm3": return new struct___darwin_xmm_reg($this->data->__fpu_xmm3);
            case "__fpu_xmm4": return new struct___darwin_xmm_reg($this->data->__fpu_xmm4);
            case "__fpu_xmm5": return new struct___darwin_xmm_reg($this->data->__fpu_xmm5);
            case "__fpu_xmm6": return new struct___darwin_xmm_reg($this->data->__fpu_xmm6);
            case "__fpu_xmm7": return new struct___darwin_xmm_reg($this->data->__fpu_xmm7);
            case "__fpu_rsrv4": return new string_($this->data->__fpu_rsrv4);
            case "__fpu_reserved1": return $this->data->__fpu_reserved1;
            case "__avx_reserved1": return new string_($this->data->__avx_reserved1);
            case "__fpu_ymmh0": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh0);
            case "__fpu_ymmh1": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh1);
            case "__fpu_ymmh2": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh2);
            case "__fpu_ymmh3": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh3);
            case "__fpu_ymmh4": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh4);
            case "__fpu_ymmh5": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh5);
            case "__fpu_ymmh6": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh6);
            case "__fpu_ymmh7": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh7);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__fpu_reserved":
                (new int_ptr($this->data->__fpu_reserved))->set($value);
                break;
            case "__fpu_fcw":
                (new struct___darwin_fp_control($this->data->__fpu_fcw))->set($value);
                break;
            case "__fpu_fsw":
                (new struct___darwin_fp_status($this->data->__fpu_fsw))->set($value);
                break;
            case "__fpu_ftw":
                $this->data->__fpu_ftw = $value;
                break;
            case "__fpu_rsrv1":
                $this->data->__fpu_rsrv1 = $value;
                break;
            case "__fpu_fop":
                $this->data->__fpu_fop = $value;
                break;
            case "__fpu_ip":
                $this->data->__fpu_ip = $value;
                break;
            case "__fpu_cs":
                $this->data->__fpu_cs = $value;
                break;
            case "__fpu_rsrv2":
                $this->data->__fpu_rsrv2 = $value;
                break;
            case "__fpu_dp":
                $this->data->__fpu_dp = $value;
                break;
            case "__fpu_ds":
                $this->data->__fpu_ds = $value;
                break;
            case "__fpu_rsrv3":
                $this->data->__fpu_rsrv3 = $value;
                break;
            case "__fpu_mxcsr":
                $this->data->__fpu_mxcsr = $value;
                break;
            case "__fpu_mxcsrmask":
                $this->data->__fpu_mxcsrmask = $value;
                break;
            case "__fpu_stmm0":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm0))->set($value);
                break;
            case "__fpu_stmm1":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm1))->set($value);
                break;
            case "__fpu_stmm2":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm2))->set($value);
                break;
            case "__fpu_stmm3":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm3))->set($value);
                break;
            case "__fpu_stmm4":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm4))->set($value);
                break;
            case "__fpu_stmm5":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm5))->set($value);
                break;
            case "__fpu_stmm6":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm6))->set($value);
                break;
            case "__fpu_stmm7":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm7))->set($value);
                break;
            case "__fpu_xmm0":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm0))->set($value);
                break;
            case "__fpu_xmm1":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm1))->set($value);
                break;
            case "__fpu_xmm2":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm2))->set($value);
                break;
            case "__fpu_xmm3":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm3))->set($value);
                break;
            case "__fpu_xmm4":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm4))->set($value);
                break;
            case "__fpu_xmm5":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm5))->set($value);
                break;
            case "__fpu_xmm6":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm6))->set($value);
                break;
            case "__fpu_xmm7":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm7))->set($value);
                break;
            case "__fpu_rsrv4":
                (new string_($this->data->__fpu_rsrv4))->set($value);
                break;
            case "__fpu_reserved1":
                $this->data->__fpu_reserved1 = $value;
                break;
            case "__avx_reserved1":
                (new string_($this->data->__avx_reserved1))->set($value);
                break;
            case "__fpu_ymmh0":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh0))->set($value);
                break;
            case "__fpu_ymmh1":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh1))->set($value);
                break;
            case "__fpu_ymmh2":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh2))->set($value);
                break;
            case "__fpu_ymmh3":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh3))->set($value);
                break;
            case "__fpu_ymmh4":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh4))->set($value);
                break;
            case "__fpu_ymmh5":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh5))->set($value);
                break;
            case "__fpu_ymmh6":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh6))->set($value);
                break;
            case "__fpu_ymmh7":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh7))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_i386_avx_state $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_avx_state'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int_ptr $__fpu_reserved
 * @property struct___darwin_fp_control $__fpu_fcw
 * @property struct___darwin_fp_status $__fpu_fsw
 * @property int $__fpu_ftw
 * @property int $__fpu_rsrv1
 * @property int $__fpu_fop
 * @property int $__fpu_ip
 * @property int $__fpu_cs
 * @property int $__fpu_rsrv2
 * @property int $__fpu_dp
 * @property int $__fpu_ds
 * @property int $__fpu_rsrv3
 * @property int $__fpu_mxcsr
 * @property int $__fpu_mxcsrmask
 * @property struct___darwin_mmst_reg $__fpu_stmm0
 * @property struct___darwin_mmst_reg $__fpu_stmm1
 * @property struct___darwin_mmst_reg $__fpu_stmm2
 * @property struct___darwin_mmst_reg $__fpu_stmm3
 * @property struct___darwin_mmst_reg $__fpu_stmm4
 * @property struct___darwin_mmst_reg $__fpu_stmm5
 * @property struct___darwin_mmst_reg $__fpu_stmm6
 * @property struct___darwin_mmst_reg $__fpu_stmm7
 * @property struct___darwin_xmm_reg $__fpu_xmm0
 * @property struct___darwin_xmm_reg $__fpu_xmm1
 * @property struct___darwin_xmm_reg $__fpu_xmm2
 * @property struct___darwin_xmm_reg $__fpu_xmm3
 * @property struct___darwin_xmm_reg $__fpu_xmm4
 * @property struct___darwin_xmm_reg $__fpu_xmm5
 * @property struct___darwin_xmm_reg $__fpu_xmm6
 * @property struct___darwin_xmm_reg $__fpu_xmm7
 * @property string_ $__fpu_rsrv4
 * @property int $__fpu_reserved1
 * @property string_ $__avx_reserved1
 * @property struct___darwin_xmm_reg $__fpu_ymmh0
 * @property struct___darwin_xmm_reg $__fpu_ymmh1
 * @property struct___darwin_xmm_reg $__fpu_ymmh2
 * @property struct___darwin_xmm_reg $__fpu_ymmh3
 * @property struct___darwin_xmm_reg $__fpu_ymmh4
 * @property struct___darwin_xmm_reg $__fpu_ymmh5
 * @property struct___darwin_xmm_reg $__fpu_ymmh6
 * @property struct___darwin_xmm_reg $__fpu_ymmh7
 */
class struct___darwin_i386_avx_state_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_avx_state_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_avx_state_ptr_ptr { return new struct___darwin_i386_avx_state_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_i386_avx_state { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_i386_avx_state { return new struct___darwin_i386_avx_state($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_i386_avx_state[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_i386_avx_state($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__fpu_reserved": return new int_ptr($this->data[0]->__fpu_reserved);
            case "__fpu_fcw": return new struct___darwin_fp_control($this->data[0]->__fpu_fcw);
            case "__fpu_fsw": return new struct___darwin_fp_status($this->data[0]->__fpu_fsw);
            case "__fpu_ftw": return $this->data[0]->__fpu_ftw;
            case "__fpu_rsrv1": return $this->data[0]->__fpu_rsrv1;
            case "__fpu_fop": return $this->data[0]->__fpu_fop;
            case "__fpu_ip": return $this->data[0]->__fpu_ip;
            case "__fpu_cs": return $this->data[0]->__fpu_cs;
            case "__fpu_rsrv2": return $this->data[0]->__fpu_rsrv2;
            case "__fpu_dp": return $this->data[0]->__fpu_dp;
            case "__fpu_ds": return $this->data[0]->__fpu_ds;
            case "__fpu_rsrv3": return $this->data[0]->__fpu_rsrv3;
            case "__fpu_mxcsr": return $this->data[0]->__fpu_mxcsr;
            case "__fpu_mxcsrmask": return $this->data[0]->__fpu_mxcsrmask;
            case "__fpu_stmm0": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm0);
            case "__fpu_stmm1": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm1);
            case "__fpu_stmm2": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm2);
            case "__fpu_stmm3": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm3);
            case "__fpu_stmm4": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm4);
            case "__fpu_stmm5": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm5);
            case "__fpu_stmm6": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm6);
            case "__fpu_stmm7": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm7);
            case "__fpu_xmm0": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm0);
            case "__fpu_xmm1": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm1);
            case "__fpu_xmm2": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm2);
            case "__fpu_xmm3": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm3);
            case "__fpu_xmm4": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm4);
            case "__fpu_xmm5": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm5);
            case "__fpu_xmm6": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm6);
            case "__fpu_xmm7": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm7);
            case "__fpu_rsrv4": return new string_($this->data[0]->__fpu_rsrv4);
            case "__fpu_reserved1": return $this->data[0]->__fpu_reserved1;
            case "__avx_reserved1": return new string_($this->data[0]->__avx_reserved1);
            case "__fpu_ymmh0": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh0);
            case "__fpu_ymmh1": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh1);
            case "__fpu_ymmh2": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh2);
            case "__fpu_ymmh3": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh3);
            case "__fpu_ymmh4": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh4);
            case "__fpu_ymmh5": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh5);
            case "__fpu_ymmh6": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh6);
            case "__fpu_ymmh7": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh7);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__fpu_reserved":
                (new int_ptr($this->data[0]->__fpu_reserved))->set($value);
                break;
            case "__fpu_fcw":
                (new struct___darwin_fp_control($this->data[0]->__fpu_fcw))->set($value);
                break;
            case "__fpu_fsw":
                (new struct___darwin_fp_status($this->data[0]->__fpu_fsw))->set($value);
                break;
            case "__fpu_ftw":
                $this->data[0]->__fpu_ftw = $value;
                break;
            case "__fpu_rsrv1":
                $this->data[0]->__fpu_rsrv1 = $value;
                break;
            case "__fpu_fop":
                $this->data[0]->__fpu_fop = $value;
                break;
            case "__fpu_ip":
                $this->data[0]->__fpu_ip = $value;
                break;
            case "__fpu_cs":
                $this->data[0]->__fpu_cs = $value;
                break;
            case "__fpu_rsrv2":
                $this->data[0]->__fpu_rsrv2 = $value;
                break;
            case "__fpu_dp":
                $this->data[0]->__fpu_dp = $value;
                break;
            case "__fpu_ds":
                $this->data[0]->__fpu_ds = $value;
                break;
            case "__fpu_rsrv3":
                $this->data[0]->__fpu_rsrv3 = $value;
                break;
            case "__fpu_mxcsr":
                $this->data[0]->__fpu_mxcsr = $value;
                break;
            case "__fpu_mxcsrmask":
                $this->data[0]->__fpu_mxcsrmask = $value;
                break;
            case "__fpu_stmm0":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm0))->set($value);
                break;
            case "__fpu_stmm1":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm1))->set($value);
                break;
            case "__fpu_stmm2":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm2))->set($value);
                break;
            case "__fpu_stmm3":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm3))->set($value);
                break;
            case "__fpu_stmm4":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm4))->set($value);
                break;
            case "__fpu_stmm5":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm5))->set($value);
                break;
            case "__fpu_stmm6":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm6))->set($value);
                break;
            case "__fpu_stmm7":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm7))->set($value);
                break;
            case "__fpu_xmm0":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm0))->set($value);
                break;
            case "__fpu_xmm1":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm1))->set($value);
                break;
            case "__fpu_xmm2":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm2))->set($value);
                break;
            case "__fpu_xmm3":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm3))->set($value);
                break;
            case "__fpu_xmm4":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm4))->set($value);
                break;
            case "__fpu_xmm5":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm5))->set($value);
                break;
            case "__fpu_xmm6":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm6))->set($value);
                break;
            case "__fpu_xmm7":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm7))->set($value);
                break;
            case "__fpu_rsrv4":
                (new string_($this->data[0]->__fpu_rsrv4))->set($value);
                break;
            case "__fpu_reserved1":
                $this->data[0]->__fpu_reserved1 = $value;
                break;
            case "__avx_reserved1":
                (new string_($this->data[0]->__avx_reserved1))->set($value);
                break;
            case "__fpu_ymmh0":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh0))->set($value);
                break;
            case "__fpu_ymmh1":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh1))->set($value);
                break;
            case "__fpu_ymmh2":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh2))->set($value);
                break;
            case "__fpu_ymmh3":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh3))->set($value);
                break;
            case "__fpu_ymmh4":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh4))->set($value);
                break;
            case "__fpu_ymmh5":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh5))->set($value);
                break;
            case "__fpu_ymmh6":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh6))->set($value);
                break;
            case "__fpu_ymmh7":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh7))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_i386_avx_state_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_avx_state*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_i386_avx_state_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_avx_state_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_avx_state_ptr_ptr_ptr { return new struct___darwin_i386_avx_state_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_i386_avx_state_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_i386_avx_state_ptr { return new struct___darwin_i386_avx_state_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_i386_avx_state_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_i386_avx_state_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_i386_avx_state_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_i386_avx_state_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_avx_state**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_i386_avx_state_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_avx_state_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_avx_state_ptr_ptr_ptr_ptr { return new struct___darwin_i386_avx_state_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_i386_avx_state_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_i386_avx_state_ptr_ptr { return new struct___darwin_i386_avx_state_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_i386_avx_state_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_i386_avx_state_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_i386_avx_state_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_i386_avx_state_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_avx_state***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_i386_avx_state_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_avx_state_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_avx_state_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_i386_avx_state_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_i386_avx_state_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_i386_avx_state_ptr_ptr_ptr { return new struct___darwin_i386_avx_state_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_i386_avx_state_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_i386_avx_state_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_i386_avx_state_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_i386_avx_state_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_avx_state****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int_ptr $__fpu_reserved
 * @property struct___darwin_fp_control $__fpu_fcw
 * @property struct___darwin_fp_status $__fpu_fsw
 * @property int $__fpu_ftw
 * @property int $__fpu_rsrv1
 * @property int $__fpu_fop
 * @property int $__fpu_ip
 * @property int $__fpu_cs
 * @property int $__fpu_rsrv2
 * @property int $__fpu_dp
 * @property int $__fpu_ds
 * @property int $__fpu_rsrv3
 * @property int $__fpu_mxcsr
 * @property int $__fpu_mxcsrmask
 * @property struct___darwin_mmst_reg $__fpu_stmm0
 * @property struct___darwin_mmst_reg $__fpu_stmm1
 * @property struct___darwin_mmst_reg $__fpu_stmm2
 * @property struct___darwin_mmst_reg $__fpu_stmm3
 * @property struct___darwin_mmst_reg $__fpu_stmm4
 * @property struct___darwin_mmst_reg $__fpu_stmm5
 * @property struct___darwin_mmst_reg $__fpu_stmm6
 * @property struct___darwin_mmst_reg $__fpu_stmm7
 * @property struct___darwin_xmm_reg $__fpu_xmm0
 * @property struct___darwin_xmm_reg $__fpu_xmm1
 * @property struct___darwin_xmm_reg $__fpu_xmm2
 * @property struct___darwin_xmm_reg $__fpu_xmm3
 * @property struct___darwin_xmm_reg $__fpu_xmm4
 * @property struct___darwin_xmm_reg $__fpu_xmm5
 * @property struct___darwin_xmm_reg $__fpu_xmm6
 * @property struct___darwin_xmm_reg $__fpu_xmm7
 * @property string_ $__fpu_rsrv4
 * @property int $__fpu_reserved1
 * @property string_ $__avx_reserved1
 * @property struct___darwin_xmm_reg $__fpu_ymmh0
 * @property struct___darwin_xmm_reg $__fpu_ymmh1
 * @property struct___darwin_xmm_reg $__fpu_ymmh2
 * @property struct___darwin_xmm_reg $__fpu_ymmh3
 * @property struct___darwin_xmm_reg $__fpu_ymmh4
 * @property struct___darwin_xmm_reg $__fpu_ymmh5
 * @property struct___darwin_xmm_reg $__fpu_ymmh6
 * @property struct___darwin_xmm_reg $__fpu_ymmh7
 * @property struct___darwin_opmask_reg $__fpu_k0
 * @property struct___darwin_opmask_reg $__fpu_k1
 * @property struct___darwin_opmask_reg $__fpu_k2
 * @property struct___darwin_opmask_reg $__fpu_k3
 * @property struct___darwin_opmask_reg $__fpu_k4
 * @property struct___darwin_opmask_reg $__fpu_k5
 * @property struct___darwin_opmask_reg $__fpu_k6
 * @property struct___darwin_opmask_reg $__fpu_k7
 * @property struct___darwin_ymm_reg $__fpu_zmmh0
 * @property struct___darwin_ymm_reg $__fpu_zmmh1
 * @property struct___darwin_ymm_reg $__fpu_zmmh2
 * @property struct___darwin_ymm_reg $__fpu_zmmh3
 * @property struct___darwin_ymm_reg $__fpu_zmmh4
 * @property struct___darwin_ymm_reg $__fpu_zmmh5
 * @property struct___darwin_ymm_reg $__fpu_zmmh6
 * @property struct___darwin_ymm_reg $__fpu_zmmh7
 */
class struct___darwin_i386_avx512_state implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_avx512_state $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_avx512_state_ptr { return new struct___darwin_i386_avx512_state_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__fpu_reserved": return new int_ptr($this->data->__fpu_reserved);
            case "__fpu_fcw": return new struct___darwin_fp_control($this->data->__fpu_fcw);
            case "__fpu_fsw": return new struct___darwin_fp_status($this->data->__fpu_fsw);
            case "__fpu_ftw": return $this->data->__fpu_ftw;
            case "__fpu_rsrv1": return $this->data->__fpu_rsrv1;
            case "__fpu_fop": return $this->data->__fpu_fop;
            case "__fpu_ip": return $this->data->__fpu_ip;
            case "__fpu_cs": return $this->data->__fpu_cs;
            case "__fpu_rsrv2": return $this->data->__fpu_rsrv2;
            case "__fpu_dp": return $this->data->__fpu_dp;
            case "__fpu_ds": return $this->data->__fpu_ds;
            case "__fpu_rsrv3": return $this->data->__fpu_rsrv3;
            case "__fpu_mxcsr": return $this->data->__fpu_mxcsr;
            case "__fpu_mxcsrmask": return $this->data->__fpu_mxcsrmask;
            case "__fpu_stmm0": return new struct___darwin_mmst_reg($this->data->__fpu_stmm0);
            case "__fpu_stmm1": return new struct___darwin_mmst_reg($this->data->__fpu_stmm1);
            case "__fpu_stmm2": return new struct___darwin_mmst_reg($this->data->__fpu_stmm2);
            case "__fpu_stmm3": return new struct___darwin_mmst_reg($this->data->__fpu_stmm3);
            case "__fpu_stmm4": return new struct___darwin_mmst_reg($this->data->__fpu_stmm4);
            case "__fpu_stmm5": return new struct___darwin_mmst_reg($this->data->__fpu_stmm5);
            case "__fpu_stmm6": return new struct___darwin_mmst_reg($this->data->__fpu_stmm6);
            case "__fpu_stmm7": return new struct___darwin_mmst_reg($this->data->__fpu_stmm7);
            case "__fpu_xmm0": return new struct___darwin_xmm_reg($this->data->__fpu_xmm0);
            case "__fpu_xmm1": return new struct___darwin_xmm_reg($this->data->__fpu_xmm1);
            case "__fpu_xmm2": return new struct___darwin_xmm_reg($this->data->__fpu_xmm2);
            case "__fpu_xmm3": return new struct___darwin_xmm_reg($this->data->__fpu_xmm3);
            case "__fpu_xmm4": return new struct___darwin_xmm_reg($this->data->__fpu_xmm4);
            case "__fpu_xmm5": return new struct___darwin_xmm_reg($this->data->__fpu_xmm5);
            case "__fpu_xmm6": return new struct___darwin_xmm_reg($this->data->__fpu_xmm6);
            case "__fpu_xmm7": return new struct___darwin_xmm_reg($this->data->__fpu_xmm7);
            case "__fpu_rsrv4": return new string_($this->data->__fpu_rsrv4);
            case "__fpu_reserved1": return $this->data->__fpu_reserved1;
            case "__avx_reserved1": return new string_($this->data->__avx_reserved1);
            case "__fpu_ymmh0": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh0);
            case "__fpu_ymmh1": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh1);
            case "__fpu_ymmh2": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh2);
            case "__fpu_ymmh3": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh3);
            case "__fpu_ymmh4": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh4);
            case "__fpu_ymmh5": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh5);
            case "__fpu_ymmh6": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh6);
            case "__fpu_ymmh7": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh7);
            case "__fpu_k0": return new struct___darwin_opmask_reg($this->data->__fpu_k0);
            case "__fpu_k1": return new struct___darwin_opmask_reg($this->data->__fpu_k1);
            case "__fpu_k2": return new struct___darwin_opmask_reg($this->data->__fpu_k2);
            case "__fpu_k3": return new struct___darwin_opmask_reg($this->data->__fpu_k3);
            case "__fpu_k4": return new struct___darwin_opmask_reg($this->data->__fpu_k4);
            case "__fpu_k5": return new struct___darwin_opmask_reg($this->data->__fpu_k5);
            case "__fpu_k6": return new struct___darwin_opmask_reg($this->data->__fpu_k6);
            case "__fpu_k7": return new struct___darwin_opmask_reg($this->data->__fpu_k7);
            case "__fpu_zmmh0": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh0);
            case "__fpu_zmmh1": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh1);
            case "__fpu_zmmh2": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh2);
            case "__fpu_zmmh3": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh3);
            case "__fpu_zmmh4": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh4);
            case "__fpu_zmmh5": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh5);
            case "__fpu_zmmh6": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh6);
            case "__fpu_zmmh7": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh7);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__fpu_reserved":
                (new int_ptr($this->data->__fpu_reserved))->set($value);
                break;
            case "__fpu_fcw":
                (new struct___darwin_fp_control($this->data->__fpu_fcw))->set($value);
                break;
            case "__fpu_fsw":
                (new struct___darwin_fp_status($this->data->__fpu_fsw))->set($value);
                break;
            case "__fpu_ftw":
                $this->data->__fpu_ftw = $value;
                break;
            case "__fpu_rsrv1":
                $this->data->__fpu_rsrv1 = $value;
                break;
            case "__fpu_fop":
                $this->data->__fpu_fop = $value;
                break;
            case "__fpu_ip":
                $this->data->__fpu_ip = $value;
                break;
            case "__fpu_cs":
                $this->data->__fpu_cs = $value;
                break;
            case "__fpu_rsrv2":
                $this->data->__fpu_rsrv2 = $value;
                break;
            case "__fpu_dp":
                $this->data->__fpu_dp = $value;
                break;
            case "__fpu_ds":
                $this->data->__fpu_ds = $value;
                break;
            case "__fpu_rsrv3":
                $this->data->__fpu_rsrv3 = $value;
                break;
            case "__fpu_mxcsr":
                $this->data->__fpu_mxcsr = $value;
                break;
            case "__fpu_mxcsrmask":
                $this->data->__fpu_mxcsrmask = $value;
                break;
            case "__fpu_stmm0":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm0))->set($value);
                break;
            case "__fpu_stmm1":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm1))->set($value);
                break;
            case "__fpu_stmm2":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm2))->set($value);
                break;
            case "__fpu_stmm3":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm3))->set($value);
                break;
            case "__fpu_stmm4":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm4))->set($value);
                break;
            case "__fpu_stmm5":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm5))->set($value);
                break;
            case "__fpu_stmm6":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm6))->set($value);
                break;
            case "__fpu_stmm7":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm7))->set($value);
                break;
            case "__fpu_xmm0":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm0))->set($value);
                break;
            case "__fpu_xmm1":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm1))->set($value);
                break;
            case "__fpu_xmm2":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm2))->set($value);
                break;
            case "__fpu_xmm3":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm3))->set($value);
                break;
            case "__fpu_xmm4":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm4))->set($value);
                break;
            case "__fpu_xmm5":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm5))->set($value);
                break;
            case "__fpu_xmm6":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm6))->set($value);
                break;
            case "__fpu_xmm7":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm7))->set($value);
                break;
            case "__fpu_rsrv4":
                (new string_($this->data->__fpu_rsrv4))->set($value);
                break;
            case "__fpu_reserved1":
                $this->data->__fpu_reserved1 = $value;
                break;
            case "__avx_reserved1":
                (new string_($this->data->__avx_reserved1))->set($value);
                break;
            case "__fpu_ymmh0":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh0))->set($value);
                break;
            case "__fpu_ymmh1":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh1))->set($value);
                break;
            case "__fpu_ymmh2":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh2))->set($value);
                break;
            case "__fpu_ymmh3":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh3))->set($value);
                break;
            case "__fpu_ymmh4":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh4))->set($value);
                break;
            case "__fpu_ymmh5":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh5))->set($value);
                break;
            case "__fpu_ymmh6":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh6))->set($value);
                break;
            case "__fpu_ymmh7":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh7))->set($value);
                break;
            case "__fpu_k0":
                (new struct___darwin_opmask_reg($this->data->__fpu_k0))->set($value);
                break;
            case "__fpu_k1":
                (new struct___darwin_opmask_reg($this->data->__fpu_k1))->set($value);
                break;
            case "__fpu_k2":
                (new struct___darwin_opmask_reg($this->data->__fpu_k2))->set($value);
                break;
            case "__fpu_k3":
                (new struct___darwin_opmask_reg($this->data->__fpu_k3))->set($value);
                break;
            case "__fpu_k4":
                (new struct___darwin_opmask_reg($this->data->__fpu_k4))->set($value);
                break;
            case "__fpu_k5":
                (new struct___darwin_opmask_reg($this->data->__fpu_k5))->set($value);
                break;
            case "__fpu_k6":
                (new struct___darwin_opmask_reg($this->data->__fpu_k6))->set($value);
                break;
            case "__fpu_k7":
                (new struct___darwin_opmask_reg($this->data->__fpu_k7))->set($value);
                break;
            case "__fpu_zmmh0":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh0))->set($value);
                break;
            case "__fpu_zmmh1":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh1))->set($value);
                break;
            case "__fpu_zmmh2":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh2))->set($value);
                break;
            case "__fpu_zmmh3":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh3))->set($value);
                break;
            case "__fpu_zmmh4":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh4))->set($value);
                break;
            case "__fpu_zmmh5":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh5))->set($value);
                break;
            case "__fpu_zmmh6":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh6))->set($value);
                break;
            case "__fpu_zmmh7":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh7))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_i386_avx512_state $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_avx512_state'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int_ptr $__fpu_reserved
 * @property struct___darwin_fp_control $__fpu_fcw
 * @property struct___darwin_fp_status $__fpu_fsw
 * @property int $__fpu_ftw
 * @property int $__fpu_rsrv1
 * @property int $__fpu_fop
 * @property int $__fpu_ip
 * @property int $__fpu_cs
 * @property int $__fpu_rsrv2
 * @property int $__fpu_dp
 * @property int $__fpu_ds
 * @property int $__fpu_rsrv3
 * @property int $__fpu_mxcsr
 * @property int $__fpu_mxcsrmask
 * @property struct___darwin_mmst_reg $__fpu_stmm0
 * @property struct___darwin_mmst_reg $__fpu_stmm1
 * @property struct___darwin_mmst_reg $__fpu_stmm2
 * @property struct___darwin_mmst_reg $__fpu_stmm3
 * @property struct___darwin_mmst_reg $__fpu_stmm4
 * @property struct___darwin_mmst_reg $__fpu_stmm5
 * @property struct___darwin_mmst_reg $__fpu_stmm6
 * @property struct___darwin_mmst_reg $__fpu_stmm7
 * @property struct___darwin_xmm_reg $__fpu_xmm0
 * @property struct___darwin_xmm_reg $__fpu_xmm1
 * @property struct___darwin_xmm_reg $__fpu_xmm2
 * @property struct___darwin_xmm_reg $__fpu_xmm3
 * @property struct___darwin_xmm_reg $__fpu_xmm4
 * @property struct___darwin_xmm_reg $__fpu_xmm5
 * @property struct___darwin_xmm_reg $__fpu_xmm6
 * @property struct___darwin_xmm_reg $__fpu_xmm7
 * @property string_ $__fpu_rsrv4
 * @property int $__fpu_reserved1
 * @property string_ $__avx_reserved1
 * @property struct___darwin_xmm_reg $__fpu_ymmh0
 * @property struct___darwin_xmm_reg $__fpu_ymmh1
 * @property struct___darwin_xmm_reg $__fpu_ymmh2
 * @property struct___darwin_xmm_reg $__fpu_ymmh3
 * @property struct___darwin_xmm_reg $__fpu_ymmh4
 * @property struct___darwin_xmm_reg $__fpu_ymmh5
 * @property struct___darwin_xmm_reg $__fpu_ymmh6
 * @property struct___darwin_xmm_reg $__fpu_ymmh7
 * @property struct___darwin_opmask_reg $__fpu_k0
 * @property struct___darwin_opmask_reg $__fpu_k1
 * @property struct___darwin_opmask_reg $__fpu_k2
 * @property struct___darwin_opmask_reg $__fpu_k3
 * @property struct___darwin_opmask_reg $__fpu_k4
 * @property struct___darwin_opmask_reg $__fpu_k5
 * @property struct___darwin_opmask_reg $__fpu_k6
 * @property struct___darwin_opmask_reg $__fpu_k7
 * @property struct___darwin_ymm_reg $__fpu_zmmh0
 * @property struct___darwin_ymm_reg $__fpu_zmmh1
 * @property struct___darwin_ymm_reg $__fpu_zmmh2
 * @property struct___darwin_ymm_reg $__fpu_zmmh3
 * @property struct___darwin_ymm_reg $__fpu_zmmh4
 * @property struct___darwin_ymm_reg $__fpu_zmmh5
 * @property struct___darwin_ymm_reg $__fpu_zmmh6
 * @property struct___darwin_ymm_reg $__fpu_zmmh7
 */
class struct___darwin_i386_avx512_state_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_avx512_state_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_avx512_state_ptr_ptr { return new struct___darwin_i386_avx512_state_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_i386_avx512_state { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_i386_avx512_state { return new struct___darwin_i386_avx512_state($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_i386_avx512_state[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_i386_avx512_state($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__fpu_reserved": return new int_ptr($this->data[0]->__fpu_reserved);
            case "__fpu_fcw": return new struct___darwin_fp_control($this->data[0]->__fpu_fcw);
            case "__fpu_fsw": return new struct___darwin_fp_status($this->data[0]->__fpu_fsw);
            case "__fpu_ftw": return $this->data[0]->__fpu_ftw;
            case "__fpu_rsrv1": return $this->data[0]->__fpu_rsrv1;
            case "__fpu_fop": return $this->data[0]->__fpu_fop;
            case "__fpu_ip": return $this->data[0]->__fpu_ip;
            case "__fpu_cs": return $this->data[0]->__fpu_cs;
            case "__fpu_rsrv2": return $this->data[0]->__fpu_rsrv2;
            case "__fpu_dp": return $this->data[0]->__fpu_dp;
            case "__fpu_ds": return $this->data[0]->__fpu_ds;
            case "__fpu_rsrv3": return $this->data[0]->__fpu_rsrv3;
            case "__fpu_mxcsr": return $this->data[0]->__fpu_mxcsr;
            case "__fpu_mxcsrmask": return $this->data[0]->__fpu_mxcsrmask;
            case "__fpu_stmm0": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm0);
            case "__fpu_stmm1": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm1);
            case "__fpu_stmm2": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm2);
            case "__fpu_stmm3": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm3);
            case "__fpu_stmm4": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm4);
            case "__fpu_stmm5": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm5);
            case "__fpu_stmm6": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm6);
            case "__fpu_stmm7": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm7);
            case "__fpu_xmm0": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm0);
            case "__fpu_xmm1": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm1);
            case "__fpu_xmm2": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm2);
            case "__fpu_xmm3": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm3);
            case "__fpu_xmm4": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm4);
            case "__fpu_xmm5": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm5);
            case "__fpu_xmm6": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm6);
            case "__fpu_xmm7": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm7);
            case "__fpu_rsrv4": return new string_($this->data[0]->__fpu_rsrv4);
            case "__fpu_reserved1": return $this->data[0]->__fpu_reserved1;
            case "__avx_reserved1": return new string_($this->data[0]->__avx_reserved1);
            case "__fpu_ymmh0": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh0);
            case "__fpu_ymmh1": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh1);
            case "__fpu_ymmh2": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh2);
            case "__fpu_ymmh3": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh3);
            case "__fpu_ymmh4": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh4);
            case "__fpu_ymmh5": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh5);
            case "__fpu_ymmh6": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh6);
            case "__fpu_ymmh7": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh7);
            case "__fpu_k0": return new struct___darwin_opmask_reg($this->data[0]->__fpu_k0);
            case "__fpu_k1": return new struct___darwin_opmask_reg($this->data[0]->__fpu_k1);
            case "__fpu_k2": return new struct___darwin_opmask_reg($this->data[0]->__fpu_k2);
            case "__fpu_k3": return new struct___darwin_opmask_reg($this->data[0]->__fpu_k3);
            case "__fpu_k4": return new struct___darwin_opmask_reg($this->data[0]->__fpu_k4);
            case "__fpu_k5": return new struct___darwin_opmask_reg($this->data[0]->__fpu_k5);
            case "__fpu_k6": return new struct___darwin_opmask_reg($this->data[0]->__fpu_k6);
            case "__fpu_k7": return new struct___darwin_opmask_reg($this->data[0]->__fpu_k7);
            case "__fpu_zmmh0": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh0);
            case "__fpu_zmmh1": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh1);
            case "__fpu_zmmh2": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh2);
            case "__fpu_zmmh3": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh3);
            case "__fpu_zmmh4": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh4);
            case "__fpu_zmmh5": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh5);
            case "__fpu_zmmh6": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh6);
            case "__fpu_zmmh7": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh7);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__fpu_reserved":
                (new int_ptr($this->data[0]->__fpu_reserved))->set($value);
                break;
            case "__fpu_fcw":
                (new struct___darwin_fp_control($this->data[0]->__fpu_fcw))->set($value);
                break;
            case "__fpu_fsw":
                (new struct___darwin_fp_status($this->data[0]->__fpu_fsw))->set($value);
                break;
            case "__fpu_ftw":
                $this->data[0]->__fpu_ftw = $value;
                break;
            case "__fpu_rsrv1":
                $this->data[0]->__fpu_rsrv1 = $value;
                break;
            case "__fpu_fop":
                $this->data[0]->__fpu_fop = $value;
                break;
            case "__fpu_ip":
                $this->data[0]->__fpu_ip = $value;
                break;
            case "__fpu_cs":
                $this->data[0]->__fpu_cs = $value;
                break;
            case "__fpu_rsrv2":
                $this->data[0]->__fpu_rsrv2 = $value;
                break;
            case "__fpu_dp":
                $this->data[0]->__fpu_dp = $value;
                break;
            case "__fpu_ds":
                $this->data[0]->__fpu_ds = $value;
                break;
            case "__fpu_rsrv3":
                $this->data[0]->__fpu_rsrv3 = $value;
                break;
            case "__fpu_mxcsr":
                $this->data[0]->__fpu_mxcsr = $value;
                break;
            case "__fpu_mxcsrmask":
                $this->data[0]->__fpu_mxcsrmask = $value;
                break;
            case "__fpu_stmm0":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm0))->set($value);
                break;
            case "__fpu_stmm1":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm1))->set($value);
                break;
            case "__fpu_stmm2":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm2))->set($value);
                break;
            case "__fpu_stmm3":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm3))->set($value);
                break;
            case "__fpu_stmm4":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm4))->set($value);
                break;
            case "__fpu_stmm5":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm5))->set($value);
                break;
            case "__fpu_stmm6":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm6))->set($value);
                break;
            case "__fpu_stmm7":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm7))->set($value);
                break;
            case "__fpu_xmm0":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm0))->set($value);
                break;
            case "__fpu_xmm1":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm1))->set($value);
                break;
            case "__fpu_xmm2":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm2))->set($value);
                break;
            case "__fpu_xmm3":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm3))->set($value);
                break;
            case "__fpu_xmm4":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm4))->set($value);
                break;
            case "__fpu_xmm5":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm5))->set($value);
                break;
            case "__fpu_xmm6":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm6))->set($value);
                break;
            case "__fpu_xmm7":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm7))->set($value);
                break;
            case "__fpu_rsrv4":
                (new string_($this->data[0]->__fpu_rsrv4))->set($value);
                break;
            case "__fpu_reserved1":
                $this->data[0]->__fpu_reserved1 = $value;
                break;
            case "__avx_reserved1":
                (new string_($this->data[0]->__avx_reserved1))->set($value);
                break;
            case "__fpu_ymmh0":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh0))->set($value);
                break;
            case "__fpu_ymmh1":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh1))->set($value);
                break;
            case "__fpu_ymmh2":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh2))->set($value);
                break;
            case "__fpu_ymmh3":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh3))->set($value);
                break;
            case "__fpu_ymmh4":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh4))->set($value);
                break;
            case "__fpu_ymmh5":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh5))->set($value);
                break;
            case "__fpu_ymmh6":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh6))->set($value);
                break;
            case "__fpu_ymmh7":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh7))->set($value);
                break;
            case "__fpu_k0":
                (new struct___darwin_opmask_reg($this->data[0]->__fpu_k0))->set($value);
                break;
            case "__fpu_k1":
                (new struct___darwin_opmask_reg($this->data[0]->__fpu_k1))->set($value);
                break;
            case "__fpu_k2":
                (new struct___darwin_opmask_reg($this->data[0]->__fpu_k2))->set($value);
                break;
            case "__fpu_k3":
                (new struct___darwin_opmask_reg($this->data[0]->__fpu_k3))->set($value);
                break;
            case "__fpu_k4":
                (new struct___darwin_opmask_reg($this->data[0]->__fpu_k4))->set($value);
                break;
            case "__fpu_k5":
                (new struct___darwin_opmask_reg($this->data[0]->__fpu_k5))->set($value);
                break;
            case "__fpu_k6":
                (new struct___darwin_opmask_reg($this->data[0]->__fpu_k6))->set($value);
                break;
            case "__fpu_k7":
                (new struct___darwin_opmask_reg($this->data[0]->__fpu_k7))->set($value);
                break;
            case "__fpu_zmmh0":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh0))->set($value);
                break;
            case "__fpu_zmmh1":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh1))->set($value);
                break;
            case "__fpu_zmmh2":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh2))->set($value);
                break;
            case "__fpu_zmmh3":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh3))->set($value);
                break;
            case "__fpu_zmmh4":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh4))->set($value);
                break;
            case "__fpu_zmmh5":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh5))->set($value);
                break;
            case "__fpu_zmmh6":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh6))->set($value);
                break;
            case "__fpu_zmmh7":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh7))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_i386_avx512_state_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_avx512_state*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_i386_avx512_state_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_avx512_state_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_avx512_state_ptr_ptr_ptr { return new struct___darwin_i386_avx512_state_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_i386_avx512_state_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_i386_avx512_state_ptr { return new struct___darwin_i386_avx512_state_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_i386_avx512_state_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_i386_avx512_state_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_i386_avx512_state_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_i386_avx512_state_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_avx512_state**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_i386_avx512_state_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_avx512_state_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_avx512_state_ptr_ptr_ptr_ptr { return new struct___darwin_i386_avx512_state_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_i386_avx512_state_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_i386_avx512_state_ptr_ptr { return new struct___darwin_i386_avx512_state_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_i386_avx512_state_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_i386_avx512_state_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_i386_avx512_state_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_i386_avx512_state_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_avx512_state***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_i386_avx512_state_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_avx512_state_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_avx512_state_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_i386_avx512_state_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_i386_avx512_state_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_i386_avx512_state_ptr_ptr_ptr { return new struct___darwin_i386_avx512_state_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_i386_avx512_state_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_i386_avx512_state_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_i386_avx512_state_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_i386_avx512_state_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_avx512_state****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__trapno
 * @property int $__cpu
 * @property int $__err
 * @property int $__faultvaddr
 */
class struct___darwin_i386_exception_state implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_exception_state $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_exception_state_ptr { return new struct___darwin_i386_exception_state_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__trapno": return $this->data->__trapno;
            case "__cpu": return $this->data->__cpu;
            case "__err": return $this->data->__err;
            case "__faultvaddr": return $this->data->__faultvaddr;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__trapno":
                $this->data->__trapno = $value;
                break;
            case "__cpu":
                $this->data->__cpu = $value;
                break;
            case "__err":
                $this->data->__err = $value;
                break;
            case "__faultvaddr":
                $this->data->__faultvaddr = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_i386_exception_state $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_exception_state'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__trapno
 * @property int $__cpu
 * @property int $__err
 * @property int $__faultvaddr
 */
class struct___darwin_i386_exception_state_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_exception_state_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_exception_state_ptr_ptr { return new struct___darwin_i386_exception_state_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_i386_exception_state { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_i386_exception_state { return new struct___darwin_i386_exception_state($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_i386_exception_state[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_i386_exception_state($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__trapno": return $this->data[0]->__trapno;
            case "__cpu": return $this->data[0]->__cpu;
            case "__err": return $this->data[0]->__err;
            case "__faultvaddr": return $this->data[0]->__faultvaddr;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__trapno":
                $this->data[0]->__trapno = $value;
                break;
            case "__cpu":
                $this->data[0]->__cpu = $value;
                break;
            case "__err":
                $this->data[0]->__err = $value;
                break;
            case "__faultvaddr":
                $this->data[0]->__faultvaddr = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_i386_exception_state_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_exception_state*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_i386_exception_state_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_exception_state_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_exception_state_ptr_ptr_ptr { return new struct___darwin_i386_exception_state_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_i386_exception_state_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_i386_exception_state_ptr { return new struct___darwin_i386_exception_state_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_i386_exception_state_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_i386_exception_state_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_i386_exception_state_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_i386_exception_state_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_exception_state**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_i386_exception_state_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_exception_state_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_exception_state_ptr_ptr_ptr_ptr { return new struct___darwin_i386_exception_state_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_i386_exception_state_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_i386_exception_state_ptr_ptr { return new struct___darwin_i386_exception_state_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_i386_exception_state_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_i386_exception_state_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_i386_exception_state_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_i386_exception_state_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_exception_state***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_i386_exception_state_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_i386_exception_state_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_i386_exception_state_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_i386_exception_state_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_i386_exception_state_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_i386_exception_state_ptr_ptr_ptr { return new struct___darwin_i386_exception_state_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_i386_exception_state_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_i386_exception_state_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_i386_exception_state_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_i386_exception_state_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_i386_exception_state****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__dr0
 * @property int $__dr1
 * @property int $__dr2
 * @property int $__dr3
 * @property int $__dr4
 * @property int $__dr5
 * @property int $__dr6
 * @property int $__dr7
 */
class struct___darwin_x86_debug_state32 implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_debug_state32 $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_debug_state32_ptr { return new struct___darwin_x86_debug_state32_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__dr0": return $this->data->__dr0;
            case "__dr1": return $this->data->__dr1;
            case "__dr2": return $this->data->__dr2;
            case "__dr3": return $this->data->__dr3;
            case "__dr4": return $this->data->__dr4;
            case "__dr5": return $this->data->__dr5;
            case "__dr6": return $this->data->__dr6;
            case "__dr7": return $this->data->__dr7;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__dr0":
                $this->data->__dr0 = $value;
                break;
            case "__dr1":
                $this->data->__dr1 = $value;
                break;
            case "__dr2":
                $this->data->__dr2 = $value;
                break;
            case "__dr3":
                $this->data->__dr3 = $value;
                break;
            case "__dr4":
                $this->data->__dr4 = $value;
                break;
            case "__dr5":
                $this->data->__dr5 = $value;
                break;
            case "__dr6":
                $this->data->__dr6 = $value;
                break;
            case "__dr7":
                $this->data->__dr7 = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_x86_debug_state32 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_debug_state32'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__dr0
 * @property int $__dr1
 * @property int $__dr2
 * @property int $__dr3
 * @property int $__dr4
 * @property int $__dr5
 * @property int $__dr6
 * @property int $__dr7
 */
class struct___darwin_x86_debug_state32_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_debug_state32_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_debug_state32_ptr_ptr { return new struct___darwin_x86_debug_state32_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_debug_state32 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_debug_state32 { return new struct___darwin_x86_debug_state32($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_debug_state32[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_debug_state32($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__dr0": return $this->data[0]->__dr0;
            case "__dr1": return $this->data[0]->__dr1;
            case "__dr2": return $this->data[0]->__dr2;
            case "__dr3": return $this->data[0]->__dr3;
            case "__dr4": return $this->data[0]->__dr4;
            case "__dr5": return $this->data[0]->__dr5;
            case "__dr6": return $this->data[0]->__dr6;
            case "__dr7": return $this->data[0]->__dr7;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__dr0":
                $this->data[0]->__dr0 = $value;
                break;
            case "__dr1":
                $this->data[0]->__dr1 = $value;
                break;
            case "__dr2":
                $this->data[0]->__dr2 = $value;
                break;
            case "__dr3":
                $this->data[0]->__dr3 = $value;
                break;
            case "__dr4":
                $this->data[0]->__dr4 = $value;
                break;
            case "__dr5":
                $this->data[0]->__dr5 = $value;
                break;
            case "__dr6":
                $this->data[0]->__dr6 = $value;
                break;
            case "__dr7":
                $this->data[0]->__dr7 = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_x86_debug_state32_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_debug_state32*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_debug_state32_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_debug_state32_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_debug_state32_ptr_ptr_ptr { return new struct___darwin_x86_debug_state32_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_debug_state32_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_debug_state32_ptr { return new struct___darwin_x86_debug_state32_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_debug_state32_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_debug_state32_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_debug_state32_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_debug_state32_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_debug_state32**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_debug_state32_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_debug_state32_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_debug_state32_ptr_ptr_ptr_ptr { return new struct___darwin_x86_debug_state32_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_debug_state32_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_debug_state32_ptr_ptr { return new struct___darwin_x86_debug_state32_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_debug_state32_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_debug_state32_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_debug_state32_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_debug_state32_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_debug_state32***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_debug_state32_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_debug_state32_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_debug_state32_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_x86_debug_state32_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_debug_state32_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_debug_state32_ptr_ptr_ptr { return new struct___darwin_x86_debug_state32_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_debug_state32_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_debug_state32_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_debug_state32_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_debug_state32_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_debug_state32****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__insn_stream_valid_bytes
 * @property int $__insn_offset
 * @property int $__out_of_synch
 * @property unsigned_char_ptr $__insn_bytes
 * @property unsigned_char_ptr $__insn_cacheline
 */
class struct___x86_instruction_state implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___x86_instruction_state $other): bool { return $this->data == $other->data; }
    public function addr(): struct___x86_instruction_state_ptr { return new struct___x86_instruction_state_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__insn_stream_valid_bytes": return $this->data->__insn_stream_valid_bytes;
            case "__insn_offset": return $this->data->__insn_offset;
            case "__out_of_synch": return $this->data->__out_of_synch;
            case "__insn_bytes": return new unsigned_char_ptr($this->data->__insn_bytes);
            case "__insn_cacheline": return new unsigned_char_ptr($this->data->__insn_cacheline);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__insn_stream_valid_bytes":
                $this->data->__insn_stream_valid_bytes = $value;
                break;
            case "__insn_offset":
                $this->data->__insn_offset = $value;
                break;
            case "__out_of_synch":
                $this->data->__out_of_synch = $value;
                break;
            case "__insn_bytes":
                (new unsigned_char_ptr($this->data->__insn_bytes))->set($value);
                break;
            case "__insn_cacheline":
                (new unsigned_char_ptr($this->data->__insn_cacheline))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___x86_instruction_state $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __x86_instruction_state'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__insn_stream_valid_bytes
 * @property int $__insn_offset
 * @property int $__out_of_synch
 * @property unsigned_char_ptr $__insn_bytes
 * @property unsigned_char_ptr $__insn_cacheline
 */
class struct___x86_instruction_state_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___x86_instruction_state_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___x86_instruction_state_ptr_ptr { return new struct___x86_instruction_state_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___x86_instruction_state { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___x86_instruction_state { return new struct___x86_instruction_state($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___x86_instruction_state[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___x86_instruction_state($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__insn_stream_valid_bytes": return $this->data[0]->__insn_stream_valid_bytes;
            case "__insn_offset": return $this->data[0]->__insn_offset;
            case "__out_of_synch": return $this->data[0]->__out_of_synch;
            case "__insn_bytes": return new unsigned_char_ptr($this->data[0]->__insn_bytes);
            case "__insn_cacheline": return new unsigned_char_ptr($this->data[0]->__insn_cacheline);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__insn_stream_valid_bytes":
                $this->data[0]->__insn_stream_valid_bytes = $value;
                break;
            case "__insn_offset":
                $this->data[0]->__insn_offset = $value;
                break;
            case "__out_of_synch":
                $this->data[0]->__out_of_synch = $value;
                break;
            case "__insn_bytes":
                (new unsigned_char_ptr($this->data[0]->__insn_bytes))->set($value);
                break;
            case "__insn_cacheline":
                (new unsigned_char_ptr($this->data[0]->__insn_cacheline))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___x86_instruction_state_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __x86_instruction_state*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___x86_instruction_state_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___x86_instruction_state_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___x86_instruction_state_ptr_ptr_ptr { return new struct___x86_instruction_state_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___x86_instruction_state_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___x86_instruction_state_ptr { return new struct___x86_instruction_state_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___x86_instruction_state_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___x86_instruction_state_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___x86_instruction_state_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___x86_instruction_state_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __x86_instruction_state**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___x86_instruction_state_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___x86_instruction_state_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___x86_instruction_state_ptr_ptr_ptr_ptr { return new struct___x86_instruction_state_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___x86_instruction_state_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___x86_instruction_state_ptr_ptr { return new struct___x86_instruction_state_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___x86_instruction_state_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___x86_instruction_state_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___x86_instruction_state_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___x86_instruction_state_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __x86_instruction_state***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___x86_instruction_state_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___x86_instruction_state_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___x86_instruction_state_ptr_ptr_ptr_ptr_ptr { return new struct___x86_instruction_state_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___x86_instruction_state_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___x86_instruction_state_ptr_ptr_ptr { return new struct___x86_instruction_state_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___x86_instruction_state_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___x86_instruction_state_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___x86_instruction_state_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___x86_instruction_state_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __x86_instruction_state****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__from_ip
 * @property int $__to_ip
 * @property int $__mispredict
 * @property int $__tsx_abort
 * @property int $__in_tsx
 * @property int $__cycle_count
 * @property int $__reserved
 */
class struct___last_branch_record implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___last_branch_record $other): bool { return $this->data == $other->data; }
    public function addr(): struct___last_branch_record_ptr { return new struct___last_branch_record_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__from_ip": return $this->data->__from_ip;
            case "__to_ip": return $this->data->__to_ip;
            case "__mispredict": return $this->data->__mispredict;
            case "__tsx_abort": return $this->data->__tsx_abort;
            case "__in_tsx": return $this->data->__in_tsx;
            case "__cycle_count": return $this->data->__cycle_count;
            case "__reserved": return $this->data->__reserved;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__from_ip":
                $this->data->__from_ip = $value;
                break;
            case "__to_ip":
                $this->data->__to_ip = $value;
                break;
            case "__mispredict":
                $this->data->__mispredict = $value;
                break;
            case "__tsx_abort":
                $this->data->__tsx_abort = $value;
                break;
            case "__in_tsx":
                $this->data->__in_tsx = $value;
                break;
            case "__cycle_count":
                $this->data->__cycle_count = $value;
                break;
            case "__reserved":
                $this->data->__reserved = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___last_branch_record $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __last_branch_record'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__from_ip
 * @property int $__to_ip
 * @property int $__mispredict
 * @property int $__tsx_abort
 * @property int $__in_tsx
 * @property int $__cycle_count
 * @property int $__reserved
 */
class struct___last_branch_record_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___last_branch_record_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___last_branch_record_ptr_ptr { return new struct___last_branch_record_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___last_branch_record { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___last_branch_record { return new struct___last_branch_record($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___last_branch_record[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___last_branch_record($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__from_ip": return $this->data[0]->__from_ip;
            case "__to_ip": return $this->data[0]->__to_ip;
            case "__mispredict": return $this->data[0]->__mispredict;
            case "__tsx_abort": return $this->data[0]->__tsx_abort;
            case "__in_tsx": return $this->data[0]->__in_tsx;
            case "__cycle_count": return $this->data[0]->__cycle_count;
            case "__reserved": return $this->data[0]->__reserved;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__from_ip":
                $this->data[0]->__from_ip = $value;
                break;
            case "__to_ip":
                $this->data[0]->__to_ip = $value;
                break;
            case "__mispredict":
                $this->data[0]->__mispredict = $value;
                break;
            case "__tsx_abort":
                $this->data[0]->__tsx_abort = $value;
                break;
            case "__in_tsx":
                $this->data[0]->__in_tsx = $value;
                break;
            case "__cycle_count":
                $this->data[0]->__cycle_count = $value;
                break;
            case "__reserved":
                $this->data[0]->__reserved = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___last_branch_record_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __last_branch_record*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___last_branch_record_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___last_branch_record_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___last_branch_record_ptr_ptr_ptr { return new struct___last_branch_record_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___last_branch_record_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___last_branch_record_ptr { return new struct___last_branch_record_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___last_branch_record_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___last_branch_record_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___last_branch_record_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___last_branch_record_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __last_branch_record**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___last_branch_record_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___last_branch_record_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___last_branch_record_ptr_ptr_ptr_ptr { return new struct___last_branch_record_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___last_branch_record_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___last_branch_record_ptr_ptr { return new struct___last_branch_record_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___last_branch_record_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___last_branch_record_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___last_branch_record_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___last_branch_record_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __last_branch_record***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___last_branch_record_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___last_branch_record_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___last_branch_record_ptr_ptr_ptr_ptr_ptr { return new struct___last_branch_record_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___last_branch_record_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___last_branch_record_ptr_ptr_ptr { return new struct___last_branch_record_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___last_branch_record_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___last_branch_record_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___last_branch_record_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___last_branch_record_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __last_branch_record****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__lbr_count
 * @property int $__lbr_supported_tsx
 * @property int $__lbr_supported_cycle_count
 * @property int $__reserved
 * @property struct___last_branch_record_ptr $__lbrs
 */
class struct___last_branch_state implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___last_branch_state $other): bool { return $this->data == $other->data; }
    public function addr(): struct___last_branch_state_ptr { return new struct___last_branch_state_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__lbr_count": return $this->data->__lbr_count;
            case "__lbr_supported_tsx": return $this->data->__lbr_supported_tsx;
            case "__lbr_supported_cycle_count": return $this->data->__lbr_supported_cycle_count;
            case "__reserved": return $this->data->__reserved;
            case "__lbrs": return new struct___last_branch_record_ptr($this->data->__lbrs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__lbr_count":
                $this->data->__lbr_count = $value;
                break;
            case "__lbr_supported_tsx":
                $this->data->__lbr_supported_tsx = $value;
                break;
            case "__lbr_supported_cycle_count":
                $this->data->__lbr_supported_cycle_count = $value;
                break;
            case "__reserved":
                $this->data->__reserved = $value;
                break;
            case "__lbrs":
                (new struct___last_branch_record_ptr($this->data->__lbrs))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___last_branch_state $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __last_branch_state'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__lbr_count
 * @property int $__lbr_supported_tsx
 * @property int $__lbr_supported_cycle_count
 * @property int $__reserved
 * @property struct___last_branch_record_ptr $__lbrs
 */
class struct___last_branch_state_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___last_branch_state_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___last_branch_state_ptr_ptr { return new struct___last_branch_state_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___last_branch_state { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___last_branch_state { return new struct___last_branch_state($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___last_branch_state[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___last_branch_state($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__lbr_count": return $this->data[0]->__lbr_count;
            case "__lbr_supported_tsx": return $this->data[0]->__lbr_supported_tsx;
            case "__lbr_supported_cycle_count": return $this->data[0]->__lbr_supported_cycle_count;
            case "__reserved": return $this->data[0]->__reserved;
            case "__lbrs": return new struct___last_branch_record_ptr($this->data[0]->__lbrs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__lbr_count":
                $this->data[0]->__lbr_count = $value;
                break;
            case "__lbr_supported_tsx":
                $this->data[0]->__lbr_supported_tsx = $value;
                break;
            case "__lbr_supported_cycle_count":
                $this->data[0]->__lbr_supported_cycle_count = $value;
                break;
            case "__reserved":
                $this->data[0]->__reserved = $value;
                break;
            case "__lbrs":
                (new struct___last_branch_record_ptr($this->data[0]->__lbrs))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___last_branch_state_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __last_branch_state*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___last_branch_state_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___last_branch_state_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___last_branch_state_ptr_ptr_ptr { return new struct___last_branch_state_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___last_branch_state_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___last_branch_state_ptr { return new struct___last_branch_state_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___last_branch_state_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___last_branch_state_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___last_branch_state_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___last_branch_state_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __last_branch_state**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___last_branch_state_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___last_branch_state_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___last_branch_state_ptr_ptr_ptr_ptr { return new struct___last_branch_state_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___last_branch_state_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___last_branch_state_ptr_ptr { return new struct___last_branch_state_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___last_branch_state_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___last_branch_state_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___last_branch_state_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___last_branch_state_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __last_branch_state***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___last_branch_state_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___last_branch_state_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___last_branch_state_ptr_ptr_ptr_ptr_ptr { return new struct___last_branch_state_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___last_branch_state_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___last_branch_state_ptr_ptr_ptr { return new struct___last_branch_state_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___last_branch_state_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___last_branch_state_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___last_branch_state_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___last_branch_state_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __last_branch_state****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__pagein_error
 */
class struct___x86_pagein_state implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___x86_pagein_state $other): bool { return $this->data == $other->data; }
    public function addr(): struct___x86_pagein_state_ptr { return new struct___x86_pagein_state_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__pagein_error": return $this->data->__pagein_error;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__pagein_error":
                $this->data->__pagein_error = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___x86_pagein_state $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __x86_pagein_state'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__pagein_error
 */
class struct___x86_pagein_state_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___x86_pagein_state_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___x86_pagein_state_ptr_ptr { return new struct___x86_pagein_state_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___x86_pagein_state { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___x86_pagein_state { return new struct___x86_pagein_state($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___x86_pagein_state[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___x86_pagein_state($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__pagein_error": return $this->data[0]->__pagein_error;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__pagein_error":
                $this->data[0]->__pagein_error = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___x86_pagein_state_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __x86_pagein_state*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___x86_pagein_state_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___x86_pagein_state_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___x86_pagein_state_ptr_ptr_ptr { return new struct___x86_pagein_state_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___x86_pagein_state_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___x86_pagein_state_ptr { return new struct___x86_pagein_state_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___x86_pagein_state_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___x86_pagein_state_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___x86_pagein_state_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___x86_pagein_state_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __x86_pagein_state**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___x86_pagein_state_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___x86_pagein_state_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___x86_pagein_state_ptr_ptr_ptr_ptr { return new struct___x86_pagein_state_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___x86_pagein_state_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___x86_pagein_state_ptr_ptr { return new struct___x86_pagein_state_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___x86_pagein_state_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___x86_pagein_state_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___x86_pagein_state_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___x86_pagein_state_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __x86_pagein_state***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___x86_pagein_state_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___x86_pagein_state_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___x86_pagein_state_ptr_ptr_ptr_ptr_ptr { return new struct___x86_pagein_state_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___x86_pagein_state_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___x86_pagein_state_ptr_ptr_ptr { return new struct___x86_pagein_state_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___x86_pagein_state_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___x86_pagein_state_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___x86_pagein_state_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___x86_pagein_state_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __x86_pagein_state****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__rax
 * @property int $__rbx
 * @property int $__rcx
 * @property int $__rdx
 * @property int $__rdi
 * @property int $__rsi
 * @property int $__rbp
 * @property int $__rsp
 * @property int $__r8
 * @property int $__r9
 * @property int $__r10
 * @property int $__r11
 * @property int $__r12
 * @property int $__r13
 * @property int $__r14
 * @property int $__r15
 * @property int $__rip
 * @property int $__rflags
 * @property int $__cs
 * @property int $__fs
 * @property int $__gs
 */
class struct___darwin_x86_thread_state64 implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_thread_state64 $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_thread_state64_ptr { return new struct___darwin_x86_thread_state64_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__rax": return $this->data->__rax;
            case "__rbx": return $this->data->__rbx;
            case "__rcx": return $this->data->__rcx;
            case "__rdx": return $this->data->__rdx;
            case "__rdi": return $this->data->__rdi;
            case "__rsi": return $this->data->__rsi;
            case "__rbp": return $this->data->__rbp;
            case "__rsp": return $this->data->__rsp;
            case "__r8": return $this->data->__r8;
            case "__r9": return $this->data->__r9;
            case "__r10": return $this->data->__r10;
            case "__r11": return $this->data->__r11;
            case "__r12": return $this->data->__r12;
            case "__r13": return $this->data->__r13;
            case "__r14": return $this->data->__r14;
            case "__r15": return $this->data->__r15;
            case "__rip": return $this->data->__rip;
            case "__rflags": return $this->data->__rflags;
            case "__cs": return $this->data->__cs;
            case "__fs": return $this->data->__fs;
            case "__gs": return $this->data->__gs;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__rax":
                $this->data->__rax = $value;
                break;
            case "__rbx":
                $this->data->__rbx = $value;
                break;
            case "__rcx":
                $this->data->__rcx = $value;
                break;
            case "__rdx":
                $this->data->__rdx = $value;
                break;
            case "__rdi":
                $this->data->__rdi = $value;
                break;
            case "__rsi":
                $this->data->__rsi = $value;
                break;
            case "__rbp":
                $this->data->__rbp = $value;
                break;
            case "__rsp":
                $this->data->__rsp = $value;
                break;
            case "__r8":
                $this->data->__r8 = $value;
                break;
            case "__r9":
                $this->data->__r9 = $value;
                break;
            case "__r10":
                $this->data->__r10 = $value;
                break;
            case "__r11":
                $this->data->__r11 = $value;
                break;
            case "__r12":
                $this->data->__r12 = $value;
                break;
            case "__r13":
                $this->data->__r13 = $value;
                break;
            case "__r14":
                $this->data->__r14 = $value;
                break;
            case "__r15":
                $this->data->__r15 = $value;
                break;
            case "__rip":
                $this->data->__rip = $value;
                break;
            case "__rflags":
                $this->data->__rflags = $value;
                break;
            case "__cs":
                $this->data->__cs = $value;
                break;
            case "__fs":
                $this->data->__fs = $value;
                break;
            case "__gs":
                $this->data->__gs = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_x86_thread_state64 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_thread_state64'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__rax
 * @property int $__rbx
 * @property int $__rcx
 * @property int $__rdx
 * @property int $__rdi
 * @property int $__rsi
 * @property int $__rbp
 * @property int $__rsp
 * @property int $__r8
 * @property int $__r9
 * @property int $__r10
 * @property int $__r11
 * @property int $__r12
 * @property int $__r13
 * @property int $__r14
 * @property int $__r15
 * @property int $__rip
 * @property int $__rflags
 * @property int $__cs
 * @property int $__fs
 * @property int $__gs
 */
class struct___darwin_x86_thread_state64_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_thread_state64_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_thread_state64_ptr_ptr { return new struct___darwin_x86_thread_state64_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_thread_state64 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_thread_state64 { return new struct___darwin_x86_thread_state64($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_thread_state64[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_thread_state64($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__rax": return $this->data[0]->__rax;
            case "__rbx": return $this->data[0]->__rbx;
            case "__rcx": return $this->data[0]->__rcx;
            case "__rdx": return $this->data[0]->__rdx;
            case "__rdi": return $this->data[0]->__rdi;
            case "__rsi": return $this->data[0]->__rsi;
            case "__rbp": return $this->data[0]->__rbp;
            case "__rsp": return $this->data[0]->__rsp;
            case "__r8": return $this->data[0]->__r8;
            case "__r9": return $this->data[0]->__r9;
            case "__r10": return $this->data[0]->__r10;
            case "__r11": return $this->data[0]->__r11;
            case "__r12": return $this->data[0]->__r12;
            case "__r13": return $this->data[0]->__r13;
            case "__r14": return $this->data[0]->__r14;
            case "__r15": return $this->data[0]->__r15;
            case "__rip": return $this->data[0]->__rip;
            case "__rflags": return $this->data[0]->__rflags;
            case "__cs": return $this->data[0]->__cs;
            case "__fs": return $this->data[0]->__fs;
            case "__gs": return $this->data[0]->__gs;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__rax":
                $this->data[0]->__rax = $value;
                break;
            case "__rbx":
                $this->data[0]->__rbx = $value;
                break;
            case "__rcx":
                $this->data[0]->__rcx = $value;
                break;
            case "__rdx":
                $this->data[0]->__rdx = $value;
                break;
            case "__rdi":
                $this->data[0]->__rdi = $value;
                break;
            case "__rsi":
                $this->data[0]->__rsi = $value;
                break;
            case "__rbp":
                $this->data[0]->__rbp = $value;
                break;
            case "__rsp":
                $this->data[0]->__rsp = $value;
                break;
            case "__r8":
                $this->data[0]->__r8 = $value;
                break;
            case "__r9":
                $this->data[0]->__r9 = $value;
                break;
            case "__r10":
                $this->data[0]->__r10 = $value;
                break;
            case "__r11":
                $this->data[0]->__r11 = $value;
                break;
            case "__r12":
                $this->data[0]->__r12 = $value;
                break;
            case "__r13":
                $this->data[0]->__r13 = $value;
                break;
            case "__r14":
                $this->data[0]->__r14 = $value;
                break;
            case "__r15":
                $this->data[0]->__r15 = $value;
                break;
            case "__rip":
                $this->data[0]->__rip = $value;
                break;
            case "__rflags":
                $this->data[0]->__rflags = $value;
                break;
            case "__cs":
                $this->data[0]->__cs = $value;
                break;
            case "__fs":
                $this->data[0]->__fs = $value;
                break;
            case "__gs":
                $this->data[0]->__gs = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_x86_thread_state64_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_thread_state64*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_thread_state64_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_thread_state64_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_thread_state64_ptr_ptr_ptr { return new struct___darwin_x86_thread_state64_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_thread_state64_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_thread_state64_ptr { return new struct___darwin_x86_thread_state64_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_thread_state64_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_thread_state64_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_thread_state64_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_thread_state64_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_thread_state64**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_thread_state64_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_thread_state64_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_thread_state64_ptr_ptr_ptr_ptr { return new struct___darwin_x86_thread_state64_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_thread_state64_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_thread_state64_ptr_ptr { return new struct___darwin_x86_thread_state64_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_thread_state64_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_thread_state64_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_thread_state64_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_thread_state64_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_thread_state64***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_thread_state64_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_thread_state64_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_thread_state64_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_x86_thread_state64_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_thread_state64_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_thread_state64_ptr_ptr_ptr { return new struct___darwin_x86_thread_state64_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_thread_state64_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_thread_state64_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_thread_state64_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_thread_state64_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_thread_state64****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct___darwin_x86_thread_state64 $__ss64
 * @property int $__ds
 * @property int $__es
 * @property int $__ss
 * @property int $__gsbase
 */
class struct___darwin_x86_thread_full_state64 implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_thread_full_state64 $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_thread_full_state64_ptr { return new struct___darwin_x86_thread_full_state64_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__ss64": return new struct___darwin_x86_thread_state64($this->data->__ss64);
            case "__ds": return $this->data->__ds;
            case "__es": return $this->data->__es;
            case "__ss": return $this->data->__ss;
            case "__gsbase": return $this->data->__gsbase;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__ss64":
                (new struct___darwin_x86_thread_state64($this->data->__ss64))->set($value);
                break;
            case "__ds":
                $this->data->__ds = $value;
                break;
            case "__es":
                $this->data->__es = $value;
                break;
            case "__ss":
                $this->data->__ss = $value;
                break;
            case "__gsbase":
                $this->data->__gsbase = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_x86_thread_full_state64 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_thread_full_state64'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct___darwin_x86_thread_state64 $__ss64
 * @property int $__ds
 * @property int $__es
 * @property int $__ss
 * @property int $__gsbase
 */
class struct___darwin_x86_thread_full_state64_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_thread_full_state64_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_thread_full_state64_ptr_ptr { return new struct___darwin_x86_thread_full_state64_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_thread_full_state64 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_thread_full_state64 { return new struct___darwin_x86_thread_full_state64($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_thread_full_state64[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_thread_full_state64($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__ss64": return new struct___darwin_x86_thread_state64($this->data[0]->__ss64);
            case "__ds": return $this->data[0]->__ds;
            case "__es": return $this->data[0]->__es;
            case "__ss": return $this->data[0]->__ss;
            case "__gsbase": return $this->data[0]->__gsbase;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__ss64":
                (new struct___darwin_x86_thread_state64($this->data[0]->__ss64))->set($value);
                break;
            case "__ds":
                $this->data[0]->__ds = $value;
                break;
            case "__es":
                $this->data[0]->__es = $value;
                break;
            case "__ss":
                $this->data[0]->__ss = $value;
                break;
            case "__gsbase":
                $this->data[0]->__gsbase = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_x86_thread_full_state64_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_thread_full_state64*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_thread_full_state64_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_thread_full_state64_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_thread_full_state64_ptr_ptr_ptr { return new struct___darwin_x86_thread_full_state64_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_thread_full_state64_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_thread_full_state64_ptr { return new struct___darwin_x86_thread_full_state64_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_thread_full_state64_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_thread_full_state64_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_thread_full_state64_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_thread_full_state64_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_thread_full_state64**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_thread_full_state64_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_thread_full_state64_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_thread_full_state64_ptr_ptr_ptr_ptr { return new struct___darwin_x86_thread_full_state64_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_thread_full_state64_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_thread_full_state64_ptr_ptr { return new struct___darwin_x86_thread_full_state64_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_thread_full_state64_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_thread_full_state64_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_thread_full_state64_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_thread_full_state64_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_thread_full_state64***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_thread_full_state64_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_thread_full_state64_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_thread_full_state64_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_x86_thread_full_state64_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_thread_full_state64_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_thread_full_state64_ptr_ptr_ptr { return new struct___darwin_x86_thread_full_state64_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_thread_full_state64_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_thread_full_state64_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_thread_full_state64_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_thread_full_state64_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_thread_full_state64****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int_ptr $__fpu_reserved
 * @property struct___darwin_fp_control $__fpu_fcw
 * @property struct___darwin_fp_status $__fpu_fsw
 * @property int $__fpu_ftw
 * @property int $__fpu_rsrv1
 * @property int $__fpu_fop
 * @property int $__fpu_ip
 * @property int $__fpu_cs
 * @property int $__fpu_rsrv2
 * @property int $__fpu_dp
 * @property int $__fpu_ds
 * @property int $__fpu_rsrv3
 * @property int $__fpu_mxcsr
 * @property int $__fpu_mxcsrmask
 * @property struct___darwin_mmst_reg $__fpu_stmm0
 * @property struct___darwin_mmst_reg $__fpu_stmm1
 * @property struct___darwin_mmst_reg $__fpu_stmm2
 * @property struct___darwin_mmst_reg $__fpu_stmm3
 * @property struct___darwin_mmst_reg $__fpu_stmm4
 * @property struct___darwin_mmst_reg $__fpu_stmm5
 * @property struct___darwin_mmst_reg $__fpu_stmm6
 * @property struct___darwin_mmst_reg $__fpu_stmm7
 * @property struct___darwin_xmm_reg $__fpu_xmm0
 * @property struct___darwin_xmm_reg $__fpu_xmm1
 * @property struct___darwin_xmm_reg $__fpu_xmm2
 * @property struct___darwin_xmm_reg $__fpu_xmm3
 * @property struct___darwin_xmm_reg $__fpu_xmm4
 * @property struct___darwin_xmm_reg $__fpu_xmm5
 * @property struct___darwin_xmm_reg $__fpu_xmm6
 * @property struct___darwin_xmm_reg $__fpu_xmm7
 * @property struct___darwin_xmm_reg $__fpu_xmm8
 * @property struct___darwin_xmm_reg $__fpu_xmm9
 * @property struct___darwin_xmm_reg $__fpu_xmm10
 * @property struct___darwin_xmm_reg $__fpu_xmm11
 * @property struct___darwin_xmm_reg $__fpu_xmm12
 * @property struct___darwin_xmm_reg $__fpu_xmm13
 * @property struct___darwin_xmm_reg $__fpu_xmm14
 * @property struct___darwin_xmm_reg $__fpu_xmm15
 * @property string_ $__fpu_rsrv4
 * @property int $__fpu_reserved1
 */
class struct___darwin_x86_float_state64 implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_float_state64 $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_float_state64_ptr { return new struct___darwin_x86_float_state64_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__fpu_reserved": return new int_ptr($this->data->__fpu_reserved);
            case "__fpu_fcw": return new struct___darwin_fp_control($this->data->__fpu_fcw);
            case "__fpu_fsw": return new struct___darwin_fp_status($this->data->__fpu_fsw);
            case "__fpu_ftw": return $this->data->__fpu_ftw;
            case "__fpu_rsrv1": return $this->data->__fpu_rsrv1;
            case "__fpu_fop": return $this->data->__fpu_fop;
            case "__fpu_ip": return $this->data->__fpu_ip;
            case "__fpu_cs": return $this->data->__fpu_cs;
            case "__fpu_rsrv2": return $this->data->__fpu_rsrv2;
            case "__fpu_dp": return $this->data->__fpu_dp;
            case "__fpu_ds": return $this->data->__fpu_ds;
            case "__fpu_rsrv3": return $this->data->__fpu_rsrv3;
            case "__fpu_mxcsr": return $this->data->__fpu_mxcsr;
            case "__fpu_mxcsrmask": return $this->data->__fpu_mxcsrmask;
            case "__fpu_stmm0": return new struct___darwin_mmst_reg($this->data->__fpu_stmm0);
            case "__fpu_stmm1": return new struct___darwin_mmst_reg($this->data->__fpu_stmm1);
            case "__fpu_stmm2": return new struct___darwin_mmst_reg($this->data->__fpu_stmm2);
            case "__fpu_stmm3": return new struct___darwin_mmst_reg($this->data->__fpu_stmm3);
            case "__fpu_stmm4": return new struct___darwin_mmst_reg($this->data->__fpu_stmm4);
            case "__fpu_stmm5": return new struct___darwin_mmst_reg($this->data->__fpu_stmm5);
            case "__fpu_stmm6": return new struct___darwin_mmst_reg($this->data->__fpu_stmm6);
            case "__fpu_stmm7": return new struct___darwin_mmst_reg($this->data->__fpu_stmm7);
            case "__fpu_xmm0": return new struct___darwin_xmm_reg($this->data->__fpu_xmm0);
            case "__fpu_xmm1": return new struct___darwin_xmm_reg($this->data->__fpu_xmm1);
            case "__fpu_xmm2": return new struct___darwin_xmm_reg($this->data->__fpu_xmm2);
            case "__fpu_xmm3": return new struct___darwin_xmm_reg($this->data->__fpu_xmm3);
            case "__fpu_xmm4": return new struct___darwin_xmm_reg($this->data->__fpu_xmm4);
            case "__fpu_xmm5": return new struct___darwin_xmm_reg($this->data->__fpu_xmm5);
            case "__fpu_xmm6": return new struct___darwin_xmm_reg($this->data->__fpu_xmm6);
            case "__fpu_xmm7": return new struct___darwin_xmm_reg($this->data->__fpu_xmm7);
            case "__fpu_xmm8": return new struct___darwin_xmm_reg($this->data->__fpu_xmm8);
            case "__fpu_xmm9": return new struct___darwin_xmm_reg($this->data->__fpu_xmm9);
            case "__fpu_xmm10": return new struct___darwin_xmm_reg($this->data->__fpu_xmm10);
            case "__fpu_xmm11": return new struct___darwin_xmm_reg($this->data->__fpu_xmm11);
            case "__fpu_xmm12": return new struct___darwin_xmm_reg($this->data->__fpu_xmm12);
            case "__fpu_xmm13": return new struct___darwin_xmm_reg($this->data->__fpu_xmm13);
            case "__fpu_xmm14": return new struct___darwin_xmm_reg($this->data->__fpu_xmm14);
            case "__fpu_xmm15": return new struct___darwin_xmm_reg($this->data->__fpu_xmm15);
            case "__fpu_rsrv4": return new string_($this->data->__fpu_rsrv4);
            case "__fpu_reserved1": return $this->data->__fpu_reserved1;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__fpu_reserved":
                (new int_ptr($this->data->__fpu_reserved))->set($value);
                break;
            case "__fpu_fcw":
                (new struct___darwin_fp_control($this->data->__fpu_fcw))->set($value);
                break;
            case "__fpu_fsw":
                (new struct___darwin_fp_status($this->data->__fpu_fsw))->set($value);
                break;
            case "__fpu_ftw":
                $this->data->__fpu_ftw = $value;
                break;
            case "__fpu_rsrv1":
                $this->data->__fpu_rsrv1 = $value;
                break;
            case "__fpu_fop":
                $this->data->__fpu_fop = $value;
                break;
            case "__fpu_ip":
                $this->data->__fpu_ip = $value;
                break;
            case "__fpu_cs":
                $this->data->__fpu_cs = $value;
                break;
            case "__fpu_rsrv2":
                $this->data->__fpu_rsrv2 = $value;
                break;
            case "__fpu_dp":
                $this->data->__fpu_dp = $value;
                break;
            case "__fpu_ds":
                $this->data->__fpu_ds = $value;
                break;
            case "__fpu_rsrv3":
                $this->data->__fpu_rsrv3 = $value;
                break;
            case "__fpu_mxcsr":
                $this->data->__fpu_mxcsr = $value;
                break;
            case "__fpu_mxcsrmask":
                $this->data->__fpu_mxcsrmask = $value;
                break;
            case "__fpu_stmm0":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm0))->set($value);
                break;
            case "__fpu_stmm1":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm1))->set($value);
                break;
            case "__fpu_stmm2":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm2))->set($value);
                break;
            case "__fpu_stmm3":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm3))->set($value);
                break;
            case "__fpu_stmm4":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm4))->set($value);
                break;
            case "__fpu_stmm5":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm5))->set($value);
                break;
            case "__fpu_stmm6":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm6))->set($value);
                break;
            case "__fpu_stmm7":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm7))->set($value);
                break;
            case "__fpu_xmm0":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm0))->set($value);
                break;
            case "__fpu_xmm1":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm1))->set($value);
                break;
            case "__fpu_xmm2":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm2))->set($value);
                break;
            case "__fpu_xmm3":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm3))->set($value);
                break;
            case "__fpu_xmm4":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm4))->set($value);
                break;
            case "__fpu_xmm5":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm5))->set($value);
                break;
            case "__fpu_xmm6":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm6))->set($value);
                break;
            case "__fpu_xmm7":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm7))->set($value);
                break;
            case "__fpu_xmm8":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm8))->set($value);
                break;
            case "__fpu_xmm9":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm9))->set($value);
                break;
            case "__fpu_xmm10":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm10))->set($value);
                break;
            case "__fpu_xmm11":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm11))->set($value);
                break;
            case "__fpu_xmm12":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm12))->set($value);
                break;
            case "__fpu_xmm13":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm13))->set($value);
                break;
            case "__fpu_xmm14":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm14))->set($value);
                break;
            case "__fpu_xmm15":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm15))->set($value);
                break;
            case "__fpu_rsrv4":
                (new string_($this->data->__fpu_rsrv4))->set($value);
                break;
            case "__fpu_reserved1":
                $this->data->__fpu_reserved1 = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_x86_float_state64 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_float_state64'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int_ptr $__fpu_reserved
 * @property struct___darwin_fp_control $__fpu_fcw
 * @property struct___darwin_fp_status $__fpu_fsw
 * @property int $__fpu_ftw
 * @property int $__fpu_rsrv1
 * @property int $__fpu_fop
 * @property int $__fpu_ip
 * @property int $__fpu_cs
 * @property int $__fpu_rsrv2
 * @property int $__fpu_dp
 * @property int $__fpu_ds
 * @property int $__fpu_rsrv3
 * @property int $__fpu_mxcsr
 * @property int $__fpu_mxcsrmask
 * @property struct___darwin_mmst_reg $__fpu_stmm0
 * @property struct___darwin_mmst_reg $__fpu_stmm1
 * @property struct___darwin_mmst_reg $__fpu_stmm2
 * @property struct___darwin_mmst_reg $__fpu_stmm3
 * @property struct___darwin_mmst_reg $__fpu_stmm4
 * @property struct___darwin_mmst_reg $__fpu_stmm5
 * @property struct___darwin_mmst_reg $__fpu_stmm6
 * @property struct___darwin_mmst_reg $__fpu_stmm7
 * @property struct___darwin_xmm_reg $__fpu_xmm0
 * @property struct___darwin_xmm_reg $__fpu_xmm1
 * @property struct___darwin_xmm_reg $__fpu_xmm2
 * @property struct___darwin_xmm_reg $__fpu_xmm3
 * @property struct___darwin_xmm_reg $__fpu_xmm4
 * @property struct___darwin_xmm_reg $__fpu_xmm5
 * @property struct___darwin_xmm_reg $__fpu_xmm6
 * @property struct___darwin_xmm_reg $__fpu_xmm7
 * @property struct___darwin_xmm_reg $__fpu_xmm8
 * @property struct___darwin_xmm_reg $__fpu_xmm9
 * @property struct___darwin_xmm_reg $__fpu_xmm10
 * @property struct___darwin_xmm_reg $__fpu_xmm11
 * @property struct___darwin_xmm_reg $__fpu_xmm12
 * @property struct___darwin_xmm_reg $__fpu_xmm13
 * @property struct___darwin_xmm_reg $__fpu_xmm14
 * @property struct___darwin_xmm_reg $__fpu_xmm15
 * @property string_ $__fpu_rsrv4
 * @property int $__fpu_reserved1
 */
class struct___darwin_x86_float_state64_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_float_state64_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_float_state64_ptr_ptr { return new struct___darwin_x86_float_state64_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_float_state64 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_float_state64 { return new struct___darwin_x86_float_state64($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_float_state64[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_float_state64($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__fpu_reserved": return new int_ptr($this->data[0]->__fpu_reserved);
            case "__fpu_fcw": return new struct___darwin_fp_control($this->data[0]->__fpu_fcw);
            case "__fpu_fsw": return new struct___darwin_fp_status($this->data[0]->__fpu_fsw);
            case "__fpu_ftw": return $this->data[0]->__fpu_ftw;
            case "__fpu_rsrv1": return $this->data[0]->__fpu_rsrv1;
            case "__fpu_fop": return $this->data[0]->__fpu_fop;
            case "__fpu_ip": return $this->data[0]->__fpu_ip;
            case "__fpu_cs": return $this->data[0]->__fpu_cs;
            case "__fpu_rsrv2": return $this->data[0]->__fpu_rsrv2;
            case "__fpu_dp": return $this->data[0]->__fpu_dp;
            case "__fpu_ds": return $this->data[0]->__fpu_ds;
            case "__fpu_rsrv3": return $this->data[0]->__fpu_rsrv3;
            case "__fpu_mxcsr": return $this->data[0]->__fpu_mxcsr;
            case "__fpu_mxcsrmask": return $this->data[0]->__fpu_mxcsrmask;
            case "__fpu_stmm0": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm0);
            case "__fpu_stmm1": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm1);
            case "__fpu_stmm2": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm2);
            case "__fpu_stmm3": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm3);
            case "__fpu_stmm4": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm4);
            case "__fpu_stmm5": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm5);
            case "__fpu_stmm6": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm6);
            case "__fpu_stmm7": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm7);
            case "__fpu_xmm0": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm0);
            case "__fpu_xmm1": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm1);
            case "__fpu_xmm2": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm2);
            case "__fpu_xmm3": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm3);
            case "__fpu_xmm4": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm4);
            case "__fpu_xmm5": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm5);
            case "__fpu_xmm6": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm6);
            case "__fpu_xmm7": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm7);
            case "__fpu_xmm8": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm8);
            case "__fpu_xmm9": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm9);
            case "__fpu_xmm10": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm10);
            case "__fpu_xmm11": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm11);
            case "__fpu_xmm12": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm12);
            case "__fpu_xmm13": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm13);
            case "__fpu_xmm14": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm14);
            case "__fpu_xmm15": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm15);
            case "__fpu_rsrv4": return new string_($this->data[0]->__fpu_rsrv4);
            case "__fpu_reserved1": return $this->data[0]->__fpu_reserved1;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__fpu_reserved":
                (new int_ptr($this->data[0]->__fpu_reserved))->set($value);
                break;
            case "__fpu_fcw":
                (new struct___darwin_fp_control($this->data[0]->__fpu_fcw))->set($value);
                break;
            case "__fpu_fsw":
                (new struct___darwin_fp_status($this->data[0]->__fpu_fsw))->set($value);
                break;
            case "__fpu_ftw":
                $this->data[0]->__fpu_ftw = $value;
                break;
            case "__fpu_rsrv1":
                $this->data[0]->__fpu_rsrv1 = $value;
                break;
            case "__fpu_fop":
                $this->data[0]->__fpu_fop = $value;
                break;
            case "__fpu_ip":
                $this->data[0]->__fpu_ip = $value;
                break;
            case "__fpu_cs":
                $this->data[0]->__fpu_cs = $value;
                break;
            case "__fpu_rsrv2":
                $this->data[0]->__fpu_rsrv2 = $value;
                break;
            case "__fpu_dp":
                $this->data[0]->__fpu_dp = $value;
                break;
            case "__fpu_ds":
                $this->data[0]->__fpu_ds = $value;
                break;
            case "__fpu_rsrv3":
                $this->data[0]->__fpu_rsrv3 = $value;
                break;
            case "__fpu_mxcsr":
                $this->data[0]->__fpu_mxcsr = $value;
                break;
            case "__fpu_mxcsrmask":
                $this->data[0]->__fpu_mxcsrmask = $value;
                break;
            case "__fpu_stmm0":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm0))->set($value);
                break;
            case "__fpu_stmm1":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm1))->set($value);
                break;
            case "__fpu_stmm2":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm2))->set($value);
                break;
            case "__fpu_stmm3":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm3))->set($value);
                break;
            case "__fpu_stmm4":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm4))->set($value);
                break;
            case "__fpu_stmm5":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm5))->set($value);
                break;
            case "__fpu_stmm6":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm6))->set($value);
                break;
            case "__fpu_stmm7":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm7))->set($value);
                break;
            case "__fpu_xmm0":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm0))->set($value);
                break;
            case "__fpu_xmm1":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm1))->set($value);
                break;
            case "__fpu_xmm2":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm2))->set($value);
                break;
            case "__fpu_xmm3":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm3))->set($value);
                break;
            case "__fpu_xmm4":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm4))->set($value);
                break;
            case "__fpu_xmm5":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm5))->set($value);
                break;
            case "__fpu_xmm6":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm6))->set($value);
                break;
            case "__fpu_xmm7":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm7))->set($value);
                break;
            case "__fpu_xmm8":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm8))->set($value);
                break;
            case "__fpu_xmm9":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm9))->set($value);
                break;
            case "__fpu_xmm10":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm10))->set($value);
                break;
            case "__fpu_xmm11":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm11))->set($value);
                break;
            case "__fpu_xmm12":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm12))->set($value);
                break;
            case "__fpu_xmm13":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm13))->set($value);
                break;
            case "__fpu_xmm14":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm14))->set($value);
                break;
            case "__fpu_xmm15":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm15))->set($value);
                break;
            case "__fpu_rsrv4":
                (new string_($this->data[0]->__fpu_rsrv4))->set($value);
                break;
            case "__fpu_reserved1":
                $this->data[0]->__fpu_reserved1 = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_x86_float_state64_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_float_state64*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_float_state64_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_float_state64_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_float_state64_ptr_ptr_ptr { return new struct___darwin_x86_float_state64_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_float_state64_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_float_state64_ptr { return new struct___darwin_x86_float_state64_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_float_state64_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_float_state64_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_float_state64_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_float_state64_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_float_state64**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_float_state64_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_float_state64_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_float_state64_ptr_ptr_ptr_ptr { return new struct___darwin_x86_float_state64_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_float_state64_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_float_state64_ptr_ptr { return new struct___darwin_x86_float_state64_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_float_state64_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_float_state64_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_float_state64_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_float_state64_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_float_state64***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_float_state64_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_float_state64_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_float_state64_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_x86_float_state64_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_float_state64_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_float_state64_ptr_ptr_ptr { return new struct___darwin_x86_float_state64_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_float_state64_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_float_state64_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_float_state64_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_float_state64_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_float_state64****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int_ptr $__fpu_reserved
 * @property struct___darwin_fp_control $__fpu_fcw
 * @property struct___darwin_fp_status $__fpu_fsw
 * @property int $__fpu_ftw
 * @property int $__fpu_rsrv1
 * @property int $__fpu_fop
 * @property int $__fpu_ip
 * @property int $__fpu_cs
 * @property int $__fpu_rsrv2
 * @property int $__fpu_dp
 * @property int $__fpu_ds
 * @property int $__fpu_rsrv3
 * @property int $__fpu_mxcsr
 * @property int $__fpu_mxcsrmask
 * @property struct___darwin_mmst_reg $__fpu_stmm0
 * @property struct___darwin_mmst_reg $__fpu_stmm1
 * @property struct___darwin_mmst_reg $__fpu_stmm2
 * @property struct___darwin_mmst_reg $__fpu_stmm3
 * @property struct___darwin_mmst_reg $__fpu_stmm4
 * @property struct___darwin_mmst_reg $__fpu_stmm5
 * @property struct___darwin_mmst_reg $__fpu_stmm6
 * @property struct___darwin_mmst_reg $__fpu_stmm7
 * @property struct___darwin_xmm_reg $__fpu_xmm0
 * @property struct___darwin_xmm_reg $__fpu_xmm1
 * @property struct___darwin_xmm_reg $__fpu_xmm2
 * @property struct___darwin_xmm_reg $__fpu_xmm3
 * @property struct___darwin_xmm_reg $__fpu_xmm4
 * @property struct___darwin_xmm_reg $__fpu_xmm5
 * @property struct___darwin_xmm_reg $__fpu_xmm6
 * @property struct___darwin_xmm_reg $__fpu_xmm7
 * @property struct___darwin_xmm_reg $__fpu_xmm8
 * @property struct___darwin_xmm_reg $__fpu_xmm9
 * @property struct___darwin_xmm_reg $__fpu_xmm10
 * @property struct___darwin_xmm_reg $__fpu_xmm11
 * @property struct___darwin_xmm_reg $__fpu_xmm12
 * @property struct___darwin_xmm_reg $__fpu_xmm13
 * @property struct___darwin_xmm_reg $__fpu_xmm14
 * @property struct___darwin_xmm_reg $__fpu_xmm15
 * @property string_ $__fpu_rsrv4
 * @property int $__fpu_reserved1
 * @property string_ $__avx_reserved1
 * @property struct___darwin_xmm_reg $__fpu_ymmh0
 * @property struct___darwin_xmm_reg $__fpu_ymmh1
 * @property struct___darwin_xmm_reg $__fpu_ymmh2
 * @property struct___darwin_xmm_reg $__fpu_ymmh3
 * @property struct___darwin_xmm_reg $__fpu_ymmh4
 * @property struct___darwin_xmm_reg $__fpu_ymmh5
 * @property struct___darwin_xmm_reg $__fpu_ymmh6
 * @property struct___darwin_xmm_reg $__fpu_ymmh7
 * @property struct___darwin_xmm_reg $__fpu_ymmh8
 * @property struct___darwin_xmm_reg $__fpu_ymmh9
 * @property struct___darwin_xmm_reg $__fpu_ymmh10
 * @property struct___darwin_xmm_reg $__fpu_ymmh11
 * @property struct___darwin_xmm_reg $__fpu_ymmh12
 * @property struct___darwin_xmm_reg $__fpu_ymmh13
 * @property struct___darwin_xmm_reg $__fpu_ymmh14
 * @property struct___darwin_xmm_reg $__fpu_ymmh15
 */
class struct___darwin_x86_avx_state64 implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_avx_state64 $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_avx_state64_ptr { return new struct___darwin_x86_avx_state64_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__fpu_reserved": return new int_ptr($this->data->__fpu_reserved);
            case "__fpu_fcw": return new struct___darwin_fp_control($this->data->__fpu_fcw);
            case "__fpu_fsw": return new struct___darwin_fp_status($this->data->__fpu_fsw);
            case "__fpu_ftw": return $this->data->__fpu_ftw;
            case "__fpu_rsrv1": return $this->data->__fpu_rsrv1;
            case "__fpu_fop": return $this->data->__fpu_fop;
            case "__fpu_ip": return $this->data->__fpu_ip;
            case "__fpu_cs": return $this->data->__fpu_cs;
            case "__fpu_rsrv2": return $this->data->__fpu_rsrv2;
            case "__fpu_dp": return $this->data->__fpu_dp;
            case "__fpu_ds": return $this->data->__fpu_ds;
            case "__fpu_rsrv3": return $this->data->__fpu_rsrv3;
            case "__fpu_mxcsr": return $this->data->__fpu_mxcsr;
            case "__fpu_mxcsrmask": return $this->data->__fpu_mxcsrmask;
            case "__fpu_stmm0": return new struct___darwin_mmst_reg($this->data->__fpu_stmm0);
            case "__fpu_stmm1": return new struct___darwin_mmst_reg($this->data->__fpu_stmm1);
            case "__fpu_stmm2": return new struct___darwin_mmst_reg($this->data->__fpu_stmm2);
            case "__fpu_stmm3": return new struct___darwin_mmst_reg($this->data->__fpu_stmm3);
            case "__fpu_stmm4": return new struct___darwin_mmst_reg($this->data->__fpu_stmm4);
            case "__fpu_stmm5": return new struct___darwin_mmst_reg($this->data->__fpu_stmm5);
            case "__fpu_stmm6": return new struct___darwin_mmst_reg($this->data->__fpu_stmm6);
            case "__fpu_stmm7": return new struct___darwin_mmst_reg($this->data->__fpu_stmm7);
            case "__fpu_xmm0": return new struct___darwin_xmm_reg($this->data->__fpu_xmm0);
            case "__fpu_xmm1": return new struct___darwin_xmm_reg($this->data->__fpu_xmm1);
            case "__fpu_xmm2": return new struct___darwin_xmm_reg($this->data->__fpu_xmm2);
            case "__fpu_xmm3": return new struct___darwin_xmm_reg($this->data->__fpu_xmm3);
            case "__fpu_xmm4": return new struct___darwin_xmm_reg($this->data->__fpu_xmm4);
            case "__fpu_xmm5": return new struct___darwin_xmm_reg($this->data->__fpu_xmm5);
            case "__fpu_xmm6": return new struct___darwin_xmm_reg($this->data->__fpu_xmm6);
            case "__fpu_xmm7": return new struct___darwin_xmm_reg($this->data->__fpu_xmm7);
            case "__fpu_xmm8": return new struct___darwin_xmm_reg($this->data->__fpu_xmm8);
            case "__fpu_xmm9": return new struct___darwin_xmm_reg($this->data->__fpu_xmm9);
            case "__fpu_xmm10": return new struct___darwin_xmm_reg($this->data->__fpu_xmm10);
            case "__fpu_xmm11": return new struct___darwin_xmm_reg($this->data->__fpu_xmm11);
            case "__fpu_xmm12": return new struct___darwin_xmm_reg($this->data->__fpu_xmm12);
            case "__fpu_xmm13": return new struct___darwin_xmm_reg($this->data->__fpu_xmm13);
            case "__fpu_xmm14": return new struct___darwin_xmm_reg($this->data->__fpu_xmm14);
            case "__fpu_xmm15": return new struct___darwin_xmm_reg($this->data->__fpu_xmm15);
            case "__fpu_rsrv4": return new string_($this->data->__fpu_rsrv4);
            case "__fpu_reserved1": return $this->data->__fpu_reserved1;
            case "__avx_reserved1": return new string_($this->data->__avx_reserved1);
            case "__fpu_ymmh0": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh0);
            case "__fpu_ymmh1": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh1);
            case "__fpu_ymmh2": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh2);
            case "__fpu_ymmh3": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh3);
            case "__fpu_ymmh4": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh4);
            case "__fpu_ymmh5": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh5);
            case "__fpu_ymmh6": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh6);
            case "__fpu_ymmh7": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh7);
            case "__fpu_ymmh8": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh8);
            case "__fpu_ymmh9": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh9);
            case "__fpu_ymmh10": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh10);
            case "__fpu_ymmh11": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh11);
            case "__fpu_ymmh12": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh12);
            case "__fpu_ymmh13": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh13);
            case "__fpu_ymmh14": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh14);
            case "__fpu_ymmh15": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh15);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__fpu_reserved":
                (new int_ptr($this->data->__fpu_reserved))->set($value);
                break;
            case "__fpu_fcw":
                (new struct___darwin_fp_control($this->data->__fpu_fcw))->set($value);
                break;
            case "__fpu_fsw":
                (new struct___darwin_fp_status($this->data->__fpu_fsw))->set($value);
                break;
            case "__fpu_ftw":
                $this->data->__fpu_ftw = $value;
                break;
            case "__fpu_rsrv1":
                $this->data->__fpu_rsrv1 = $value;
                break;
            case "__fpu_fop":
                $this->data->__fpu_fop = $value;
                break;
            case "__fpu_ip":
                $this->data->__fpu_ip = $value;
                break;
            case "__fpu_cs":
                $this->data->__fpu_cs = $value;
                break;
            case "__fpu_rsrv2":
                $this->data->__fpu_rsrv2 = $value;
                break;
            case "__fpu_dp":
                $this->data->__fpu_dp = $value;
                break;
            case "__fpu_ds":
                $this->data->__fpu_ds = $value;
                break;
            case "__fpu_rsrv3":
                $this->data->__fpu_rsrv3 = $value;
                break;
            case "__fpu_mxcsr":
                $this->data->__fpu_mxcsr = $value;
                break;
            case "__fpu_mxcsrmask":
                $this->data->__fpu_mxcsrmask = $value;
                break;
            case "__fpu_stmm0":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm0))->set($value);
                break;
            case "__fpu_stmm1":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm1))->set($value);
                break;
            case "__fpu_stmm2":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm2))->set($value);
                break;
            case "__fpu_stmm3":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm3))->set($value);
                break;
            case "__fpu_stmm4":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm4))->set($value);
                break;
            case "__fpu_stmm5":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm5))->set($value);
                break;
            case "__fpu_stmm6":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm6))->set($value);
                break;
            case "__fpu_stmm7":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm7))->set($value);
                break;
            case "__fpu_xmm0":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm0))->set($value);
                break;
            case "__fpu_xmm1":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm1))->set($value);
                break;
            case "__fpu_xmm2":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm2))->set($value);
                break;
            case "__fpu_xmm3":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm3))->set($value);
                break;
            case "__fpu_xmm4":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm4))->set($value);
                break;
            case "__fpu_xmm5":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm5))->set($value);
                break;
            case "__fpu_xmm6":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm6))->set($value);
                break;
            case "__fpu_xmm7":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm7))->set($value);
                break;
            case "__fpu_xmm8":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm8))->set($value);
                break;
            case "__fpu_xmm9":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm9))->set($value);
                break;
            case "__fpu_xmm10":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm10))->set($value);
                break;
            case "__fpu_xmm11":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm11))->set($value);
                break;
            case "__fpu_xmm12":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm12))->set($value);
                break;
            case "__fpu_xmm13":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm13))->set($value);
                break;
            case "__fpu_xmm14":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm14))->set($value);
                break;
            case "__fpu_xmm15":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm15))->set($value);
                break;
            case "__fpu_rsrv4":
                (new string_($this->data->__fpu_rsrv4))->set($value);
                break;
            case "__fpu_reserved1":
                $this->data->__fpu_reserved1 = $value;
                break;
            case "__avx_reserved1":
                (new string_($this->data->__avx_reserved1))->set($value);
                break;
            case "__fpu_ymmh0":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh0))->set($value);
                break;
            case "__fpu_ymmh1":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh1))->set($value);
                break;
            case "__fpu_ymmh2":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh2))->set($value);
                break;
            case "__fpu_ymmh3":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh3))->set($value);
                break;
            case "__fpu_ymmh4":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh4))->set($value);
                break;
            case "__fpu_ymmh5":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh5))->set($value);
                break;
            case "__fpu_ymmh6":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh6))->set($value);
                break;
            case "__fpu_ymmh7":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh7))->set($value);
                break;
            case "__fpu_ymmh8":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh8))->set($value);
                break;
            case "__fpu_ymmh9":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh9))->set($value);
                break;
            case "__fpu_ymmh10":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh10))->set($value);
                break;
            case "__fpu_ymmh11":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh11))->set($value);
                break;
            case "__fpu_ymmh12":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh12))->set($value);
                break;
            case "__fpu_ymmh13":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh13))->set($value);
                break;
            case "__fpu_ymmh14":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh14))->set($value);
                break;
            case "__fpu_ymmh15":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh15))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_x86_avx_state64 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_avx_state64'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int_ptr $__fpu_reserved
 * @property struct___darwin_fp_control $__fpu_fcw
 * @property struct___darwin_fp_status $__fpu_fsw
 * @property int $__fpu_ftw
 * @property int $__fpu_rsrv1
 * @property int $__fpu_fop
 * @property int $__fpu_ip
 * @property int $__fpu_cs
 * @property int $__fpu_rsrv2
 * @property int $__fpu_dp
 * @property int $__fpu_ds
 * @property int $__fpu_rsrv3
 * @property int $__fpu_mxcsr
 * @property int $__fpu_mxcsrmask
 * @property struct___darwin_mmst_reg $__fpu_stmm0
 * @property struct___darwin_mmst_reg $__fpu_stmm1
 * @property struct___darwin_mmst_reg $__fpu_stmm2
 * @property struct___darwin_mmst_reg $__fpu_stmm3
 * @property struct___darwin_mmst_reg $__fpu_stmm4
 * @property struct___darwin_mmst_reg $__fpu_stmm5
 * @property struct___darwin_mmst_reg $__fpu_stmm6
 * @property struct___darwin_mmst_reg $__fpu_stmm7
 * @property struct___darwin_xmm_reg $__fpu_xmm0
 * @property struct___darwin_xmm_reg $__fpu_xmm1
 * @property struct___darwin_xmm_reg $__fpu_xmm2
 * @property struct___darwin_xmm_reg $__fpu_xmm3
 * @property struct___darwin_xmm_reg $__fpu_xmm4
 * @property struct___darwin_xmm_reg $__fpu_xmm5
 * @property struct___darwin_xmm_reg $__fpu_xmm6
 * @property struct___darwin_xmm_reg $__fpu_xmm7
 * @property struct___darwin_xmm_reg $__fpu_xmm8
 * @property struct___darwin_xmm_reg $__fpu_xmm9
 * @property struct___darwin_xmm_reg $__fpu_xmm10
 * @property struct___darwin_xmm_reg $__fpu_xmm11
 * @property struct___darwin_xmm_reg $__fpu_xmm12
 * @property struct___darwin_xmm_reg $__fpu_xmm13
 * @property struct___darwin_xmm_reg $__fpu_xmm14
 * @property struct___darwin_xmm_reg $__fpu_xmm15
 * @property string_ $__fpu_rsrv4
 * @property int $__fpu_reserved1
 * @property string_ $__avx_reserved1
 * @property struct___darwin_xmm_reg $__fpu_ymmh0
 * @property struct___darwin_xmm_reg $__fpu_ymmh1
 * @property struct___darwin_xmm_reg $__fpu_ymmh2
 * @property struct___darwin_xmm_reg $__fpu_ymmh3
 * @property struct___darwin_xmm_reg $__fpu_ymmh4
 * @property struct___darwin_xmm_reg $__fpu_ymmh5
 * @property struct___darwin_xmm_reg $__fpu_ymmh6
 * @property struct___darwin_xmm_reg $__fpu_ymmh7
 * @property struct___darwin_xmm_reg $__fpu_ymmh8
 * @property struct___darwin_xmm_reg $__fpu_ymmh9
 * @property struct___darwin_xmm_reg $__fpu_ymmh10
 * @property struct___darwin_xmm_reg $__fpu_ymmh11
 * @property struct___darwin_xmm_reg $__fpu_ymmh12
 * @property struct___darwin_xmm_reg $__fpu_ymmh13
 * @property struct___darwin_xmm_reg $__fpu_ymmh14
 * @property struct___darwin_xmm_reg $__fpu_ymmh15
 */
class struct___darwin_x86_avx_state64_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_avx_state64_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_avx_state64_ptr_ptr { return new struct___darwin_x86_avx_state64_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_avx_state64 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_avx_state64 { return new struct___darwin_x86_avx_state64($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_avx_state64[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_avx_state64($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__fpu_reserved": return new int_ptr($this->data[0]->__fpu_reserved);
            case "__fpu_fcw": return new struct___darwin_fp_control($this->data[0]->__fpu_fcw);
            case "__fpu_fsw": return new struct___darwin_fp_status($this->data[0]->__fpu_fsw);
            case "__fpu_ftw": return $this->data[0]->__fpu_ftw;
            case "__fpu_rsrv1": return $this->data[0]->__fpu_rsrv1;
            case "__fpu_fop": return $this->data[0]->__fpu_fop;
            case "__fpu_ip": return $this->data[0]->__fpu_ip;
            case "__fpu_cs": return $this->data[0]->__fpu_cs;
            case "__fpu_rsrv2": return $this->data[0]->__fpu_rsrv2;
            case "__fpu_dp": return $this->data[0]->__fpu_dp;
            case "__fpu_ds": return $this->data[0]->__fpu_ds;
            case "__fpu_rsrv3": return $this->data[0]->__fpu_rsrv3;
            case "__fpu_mxcsr": return $this->data[0]->__fpu_mxcsr;
            case "__fpu_mxcsrmask": return $this->data[0]->__fpu_mxcsrmask;
            case "__fpu_stmm0": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm0);
            case "__fpu_stmm1": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm1);
            case "__fpu_stmm2": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm2);
            case "__fpu_stmm3": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm3);
            case "__fpu_stmm4": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm4);
            case "__fpu_stmm5": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm5);
            case "__fpu_stmm6": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm6);
            case "__fpu_stmm7": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm7);
            case "__fpu_xmm0": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm0);
            case "__fpu_xmm1": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm1);
            case "__fpu_xmm2": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm2);
            case "__fpu_xmm3": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm3);
            case "__fpu_xmm4": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm4);
            case "__fpu_xmm5": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm5);
            case "__fpu_xmm6": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm6);
            case "__fpu_xmm7": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm7);
            case "__fpu_xmm8": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm8);
            case "__fpu_xmm9": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm9);
            case "__fpu_xmm10": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm10);
            case "__fpu_xmm11": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm11);
            case "__fpu_xmm12": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm12);
            case "__fpu_xmm13": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm13);
            case "__fpu_xmm14": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm14);
            case "__fpu_xmm15": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm15);
            case "__fpu_rsrv4": return new string_($this->data[0]->__fpu_rsrv4);
            case "__fpu_reserved1": return $this->data[0]->__fpu_reserved1;
            case "__avx_reserved1": return new string_($this->data[0]->__avx_reserved1);
            case "__fpu_ymmh0": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh0);
            case "__fpu_ymmh1": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh1);
            case "__fpu_ymmh2": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh2);
            case "__fpu_ymmh3": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh3);
            case "__fpu_ymmh4": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh4);
            case "__fpu_ymmh5": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh5);
            case "__fpu_ymmh6": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh6);
            case "__fpu_ymmh7": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh7);
            case "__fpu_ymmh8": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh8);
            case "__fpu_ymmh9": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh9);
            case "__fpu_ymmh10": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh10);
            case "__fpu_ymmh11": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh11);
            case "__fpu_ymmh12": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh12);
            case "__fpu_ymmh13": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh13);
            case "__fpu_ymmh14": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh14);
            case "__fpu_ymmh15": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh15);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__fpu_reserved":
                (new int_ptr($this->data[0]->__fpu_reserved))->set($value);
                break;
            case "__fpu_fcw":
                (new struct___darwin_fp_control($this->data[0]->__fpu_fcw))->set($value);
                break;
            case "__fpu_fsw":
                (new struct___darwin_fp_status($this->data[0]->__fpu_fsw))->set($value);
                break;
            case "__fpu_ftw":
                $this->data[0]->__fpu_ftw = $value;
                break;
            case "__fpu_rsrv1":
                $this->data[0]->__fpu_rsrv1 = $value;
                break;
            case "__fpu_fop":
                $this->data[0]->__fpu_fop = $value;
                break;
            case "__fpu_ip":
                $this->data[0]->__fpu_ip = $value;
                break;
            case "__fpu_cs":
                $this->data[0]->__fpu_cs = $value;
                break;
            case "__fpu_rsrv2":
                $this->data[0]->__fpu_rsrv2 = $value;
                break;
            case "__fpu_dp":
                $this->data[0]->__fpu_dp = $value;
                break;
            case "__fpu_ds":
                $this->data[0]->__fpu_ds = $value;
                break;
            case "__fpu_rsrv3":
                $this->data[0]->__fpu_rsrv3 = $value;
                break;
            case "__fpu_mxcsr":
                $this->data[0]->__fpu_mxcsr = $value;
                break;
            case "__fpu_mxcsrmask":
                $this->data[0]->__fpu_mxcsrmask = $value;
                break;
            case "__fpu_stmm0":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm0))->set($value);
                break;
            case "__fpu_stmm1":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm1))->set($value);
                break;
            case "__fpu_stmm2":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm2))->set($value);
                break;
            case "__fpu_stmm3":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm3))->set($value);
                break;
            case "__fpu_stmm4":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm4))->set($value);
                break;
            case "__fpu_stmm5":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm5))->set($value);
                break;
            case "__fpu_stmm6":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm6))->set($value);
                break;
            case "__fpu_stmm7":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm7))->set($value);
                break;
            case "__fpu_xmm0":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm0))->set($value);
                break;
            case "__fpu_xmm1":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm1))->set($value);
                break;
            case "__fpu_xmm2":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm2))->set($value);
                break;
            case "__fpu_xmm3":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm3))->set($value);
                break;
            case "__fpu_xmm4":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm4))->set($value);
                break;
            case "__fpu_xmm5":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm5))->set($value);
                break;
            case "__fpu_xmm6":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm6))->set($value);
                break;
            case "__fpu_xmm7":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm7))->set($value);
                break;
            case "__fpu_xmm8":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm8))->set($value);
                break;
            case "__fpu_xmm9":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm9))->set($value);
                break;
            case "__fpu_xmm10":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm10))->set($value);
                break;
            case "__fpu_xmm11":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm11))->set($value);
                break;
            case "__fpu_xmm12":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm12))->set($value);
                break;
            case "__fpu_xmm13":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm13))->set($value);
                break;
            case "__fpu_xmm14":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm14))->set($value);
                break;
            case "__fpu_xmm15":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm15))->set($value);
                break;
            case "__fpu_rsrv4":
                (new string_($this->data[0]->__fpu_rsrv4))->set($value);
                break;
            case "__fpu_reserved1":
                $this->data[0]->__fpu_reserved1 = $value;
                break;
            case "__avx_reserved1":
                (new string_($this->data[0]->__avx_reserved1))->set($value);
                break;
            case "__fpu_ymmh0":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh0))->set($value);
                break;
            case "__fpu_ymmh1":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh1))->set($value);
                break;
            case "__fpu_ymmh2":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh2))->set($value);
                break;
            case "__fpu_ymmh3":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh3))->set($value);
                break;
            case "__fpu_ymmh4":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh4))->set($value);
                break;
            case "__fpu_ymmh5":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh5))->set($value);
                break;
            case "__fpu_ymmh6":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh6))->set($value);
                break;
            case "__fpu_ymmh7":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh7))->set($value);
                break;
            case "__fpu_ymmh8":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh8))->set($value);
                break;
            case "__fpu_ymmh9":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh9))->set($value);
                break;
            case "__fpu_ymmh10":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh10))->set($value);
                break;
            case "__fpu_ymmh11":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh11))->set($value);
                break;
            case "__fpu_ymmh12":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh12))->set($value);
                break;
            case "__fpu_ymmh13":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh13))->set($value);
                break;
            case "__fpu_ymmh14":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh14))->set($value);
                break;
            case "__fpu_ymmh15":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh15))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_x86_avx_state64_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_avx_state64*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_avx_state64_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_avx_state64_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_avx_state64_ptr_ptr_ptr { return new struct___darwin_x86_avx_state64_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_avx_state64_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_avx_state64_ptr { return new struct___darwin_x86_avx_state64_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_avx_state64_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_avx_state64_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_avx_state64_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_avx_state64_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_avx_state64**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_avx_state64_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_avx_state64_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_avx_state64_ptr_ptr_ptr_ptr { return new struct___darwin_x86_avx_state64_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_avx_state64_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_avx_state64_ptr_ptr { return new struct___darwin_x86_avx_state64_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_avx_state64_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_avx_state64_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_avx_state64_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_avx_state64_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_avx_state64***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_avx_state64_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_avx_state64_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_avx_state64_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_x86_avx_state64_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_avx_state64_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_avx_state64_ptr_ptr_ptr { return new struct___darwin_x86_avx_state64_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_avx_state64_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_avx_state64_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_avx_state64_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_avx_state64_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_avx_state64****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int_ptr $__fpu_reserved
 * @property struct___darwin_fp_control $__fpu_fcw
 * @property struct___darwin_fp_status $__fpu_fsw
 * @property int $__fpu_ftw
 * @property int $__fpu_rsrv1
 * @property int $__fpu_fop
 * @property int $__fpu_ip
 * @property int $__fpu_cs
 * @property int $__fpu_rsrv2
 * @property int $__fpu_dp
 * @property int $__fpu_ds
 * @property int $__fpu_rsrv3
 * @property int $__fpu_mxcsr
 * @property int $__fpu_mxcsrmask
 * @property struct___darwin_mmst_reg $__fpu_stmm0
 * @property struct___darwin_mmst_reg $__fpu_stmm1
 * @property struct___darwin_mmst_reg $__fpu_stmm2
 * @property struct___darwin_mmst_reg $__fpu_stmm3
 * @property struct___darwin_mmst_reg $__fpu_stmm4
 * @property struct___darwin_mmst_reg $__fpu_stmm5
 * @property struct___darwin_mmst_reg $__fpu_stmm6
 * @property struct___darwin_mmst_reg $__fpu_stmm7
 * @property struct___darwin_xmm_reg $__fpu_xmm0
 * @property struct___darwin_xmm_reg $__fpu_xmm1
 * @property struct___darwin_xmm_reg $__fpu_xmm2
 * @property struct___darwin_xmm_reg $__fpu_xmm3
 * @property struct___darwin_xmm_reg $__fpu_xmm4
 * @property struct___darwin_xmm_reg $__fpu_xmm5
 * @property struct___darwin_xmm_reg $__fpu_xmm6
 * @property struct___darwin_xmm_reg $__fpu_xmm7
 * @property struct___darwin_xmm_reg $__fpu_xmm8
 * @property struct___darwin_xmm_reg $__fpu_xmm9
 * @property struct___darwin_xmm_reg $__fpu_xmm10
 * @property struct___darwin_xmm_reg $__fpu_xmm11
 * @property struct___darwin_xmm_reg $__fpu_xmm12
 * @property struct___darwin_xmm_reg $__fpu_xmm13
 * @property struct___darwin_xmm_reg $__fpu_xmm14
 * @property struct___darwin_xmm_reg $__fpu_xmm15
 * @property string_ $__fpu_rsrv4
 * @property int $__fpu_reserved1
 * @property string_ $__avx_reserved1
 * @property struct___darwin_xmm_reg $__fpu_ymmh0
 * @property struct___darwin_xmm_reg $__fpu_ymmh1
 * @property struct___darwin_xmm_reg $__fpu_ymmh2
 * @property struct___darwin_xmm_reg $__fpu_ymmh3
 * @property struct___darwin_xmm_reg $__fpu_ymmh4
 * @property struct___darwin_xmm_reg $__fpu_ymmh5
 * @property struct___darwin_xmm_reg $__fpu_ymmh6
 * @property struct___darwin_xmm_reg $__fpu_ymmh7
 * @property struct___darwin_xmm_reg $__fpu_ymmh8
 * @property struct___darwin_xmm_reg $__fpu_ymmh9
 * @property struct___darwin_xmm_reg $__fpu_ymmh10
 * @property struct___darwin_xmm_reg $__fpu_ymmh11
 * @property struct___darwin_xmm_reg $__fpu_ymmh12
 * @property struct___darwin_xmm_reg $__fpu_ymmh13
 * @property struct___darwin_xmm_reg $__fpu_ymmh14
 * @property struct___darwin_xmm_reg $__fpu_ymmh15
 * @property struct___darwin_opmask_reg $__fpu_k0
 * @property struct___darwin_opmask_reg $__fpu_k1
 * @property struct___darwin_opmask_reg $__fpu_k2
 * @property struct___darwin_opmask_reg $__fpu_k3
 * @property struct___darwin_opmask_reg $__fpu_k4
 * @property struct___darwin_opmask_reg $__fpu_k5
 * @property struct___darwin_opmask_reg $__fpu_k6
 * @property struct___darwin_opmask_reg $__fpu_k7
 * @property struct___darwin_ymm_reg $__fpu_zmmh0
 * @property struct___darwin_ymm_reg $__fpu_zmmh1
 * @property struct___darwin_ymm_reg $__fpu_zmmh2
 * @property struct___darwin_ymm_reg $__fpu_zmmh3
 * @property struct___darwin_ymm_reg $__fpu_zmmh4
 * @property struct___darwin_ymm_reg $__fpu_zmmh5
 * @property struct___darwin_ymm_reg $__fpu_zmmh6
 * @property struct___darwin_ymm_reg $__fpu_zmmh7
 * @property struct___darwin_ymm_reg $__fpu_zmmh8
 * @property struct___darwin_ymm_reg $__fpu_zmmh9
 * @property struct___darwin_ymm_reg $__fpu_zmmh10
 * @property struct___darwin_ymm_reg $__fpu_zmmh11
 * @property struct___darwin_ymm_reg $__fpu_zmmh12
 * @property struct___darwin_ymm_reg $__fpu_zmmh13
 * @property struct___darwin_ymm_reg $__fpu_zmmh14
 * @property struct___darwin_ymm_reg $__fpu_zmmh15
 * @property struct___darwin_zmm_reg $__fpu_zmm16
 * @property struct___darwin_zmm_reg $__fpu_zmm17
 * @property struct___darwin_zmm_reg $__fpu_zmm18
 * @property struct___darwin_zmm_reg $__fpu_zmm19
 * @property struct___darwin_zmm_reg $__fpu_zmm20
 * @property struct___darwin_zmm_reg $__fpu_zmm21
 * @property struct___darwin_zmm_reg $__fpu_zmm22
 * @property struct___darwin_zmm_reg $__fpu_zmm23
 * @property struct___darwin_zmm_reg $__fpu_zmm24
 * @property struct___darwin_zmm_reg $__fpu_zmm25
 * @property struct___darwin_zmm_reg $__fpu_zmm26
 * @property struct___darwin_zmm_reg $__fpu_zmm27
 * @property struct___darwin_zmm_reg $__fpu_zmm28
 * @property struct___darwin_zmm_reg $__fpu_zmm29
 * @property struct___darwin_zmm_reg $__fpu_zmm30
 * @property struct___darwin_zmm_reg $__fpu_zmm31
 */
class struct___darwin_x86_avx512_state64 implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_avx512_state64 $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_avx512_state64_ptr { return new struct___darwin_x86_avx512_state64_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__fpu_reserved": return new int_ptr($this->data->__fpu_reserved);
            case "__fpu_fcw": return new struct___darwin_fp_control($this->data->__fpu_fcw);
            case "__fpu_fsw": return new struct___darwin_fp_status($this->data->__fpu_fsw);
            case "__fpu_ftw": return $this->data->__fpu_ftw;
            case "__fpu_rsrv1": return $this->data->__fpu_rsrv1;
            case "__fpu_fop": return $this->data->__fpu_fop;
            case "__fpu_ip": return $this->data->__fpu_ip;
            case "__fpu_cs": return $this->data->__fpu_cs;
            case "__fpu_rsrv2": return $this->data->__fpu_rsrv2;
            case "__fpu_dp": return $this->data->__fpu_dp;
            case "__fpu_ds": return $this->data->__fpu_ds;
            case "__fpu_rsrv3": return $this->data->__fpu_rsrv3;
            case "__fpu_mxcsr": return $this->data->__fpu_mxcsr;
            case "__fpu_mxcsrmask": return $this->data->__fpu_mxcsrmask;
            case "__fpu_stmm0": return new struct___darwin_mmst_reg($this->data->__fpu_stmm0);
            case "__fpu_stmm1": return new struct___darwin_mmst_reg($this->data->__fpu_stmm1);
            case "__fpu_stmm2": return new struct___darwin_mmst_reg($this->data->__fpu_stmm2);
            case "__fpu_stmm3": return new struct___darwin_mmst_reg($this->data->__fpu_stmm3);
            case "__fpu_stmm4": return new struct___darwin_mmst_reg($this->data->__fpu_stmm4);
            case "__fpu_stmm5": return new struct___darwin_mmst_reg($this->data->__fpu_stmm5);
            case "__fpu_stmm6": return new struct___darwin_mmst_reg($this->data->__fpu_stmm6);
            case "__fpu_stmm7": return new struct___darwin_mmst_reg($this->data->__fpu_stmm7);
            case "__fpu_xmm0": return new struct___darwin_xmm_reg($this->data->__fpu_xmm0);
            case "__fpu_xmm1": return new struct___darwin_xmm_reg($this->data->__fpu_xmm1);
            case "__fpu_xmm2": return new struct___darwin_xmm_reg($this->data->__fpu_xmm2);
            case "__fpu_xmm3": return new struct___darwin_xmm_reg($this->data->__fpu_xmm3);
            case "__fpu_xmm4": return new struct___darwin_xmm_reg($this->data->__fpu_xmm4);
            case "__fpu_xmm5": return new struct___darwin_xmm_reg($this->data->__fpu_xmm5);
            case "__fpu_xmm6": return new struct___darwin_xmm_reg($this->data->__fpu_xmm6);
            case "__fpu_xmm7": return new struct___darwin_xmm_reg($this->data->__fpu_xmm7);
            case "__fpu_xmm8": return new struct___darwin_xmm_reg($this->data->__fpu_xmm8);
            case "__fpu_xmm9": return new struct___darwin_xmm_reg($this->data->__fpu_xmm9);
            case "__fpu_xmm10": return new struct___darwin_xmm_reg($this->data->__fpu_xmm10);
            case "__fpu_xmm11": return new struct___darwin_xmm_reg($this->data->__fpu_xmm11);
            case "__fpu_xmm12": return new struct___darwin_xmm_reg($this->data->__fpu_xmm12);
            case "__fpu_xmm13": return new struct___darwin_xmm_reg($this->data->__fpu_xmm13);
            case "__fpu_xmm14": return new struct___darwin_xmm_reg($this->data->__fpu_xmm14);
            case "__fpu_xmm15": return new struct___darwin_xmm_reg($this->data->__fpu_xmm15);
            case "__fpu_rsrv4": return new string_($this->data->__fpu_rsrv4);
            case "__fpu_reserved1": return $this->data->__fpu_reserved1;
            case "__avx_reserved1": return new string_($this->data->__avx_reserved1);
            case "__fpu_ymmh0": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh0);
            case "__fpu_ymmh1": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh1);
            case "__fpu_ymmh2": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh2);
            case "__fpu_ymmh3": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh3);
            case "__fpu_ymmh4": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh4);
            case "__fpu_ymmh5": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh5);
            case "__fpu_ymmh6": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh6);
            case "__fpu_ymmh7": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh7);
            case "__fpu_ymmh8": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh8);
            case "__fpu_ymmh9": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh9);
            case "__fpu_ymmh10": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh10);
            case "__fpu_ymmh11": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh11);
            case "__fpu_ymmh12": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh12);
            case "__fpu_ymmh13": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh13);
            case "__fpu_ymmh14": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh14);
            case "__fpu_ymmh15": return new struct___darwin_xmm_reg($this->data->__fpu_ymmh15);
            case "__fpu_k0": return new struct___darwin_opmask_reg($this->data->__fpu_k0);
            case "__fpu_k1": return new struct___darwin_opmask_reg($this->data->__fpu_k1);
            case "__fpu_k2": return new struct___darwin_opmask_reg($this->data->__fpu_k2);
            case "__fpu_k3": return new struct___darwin_opmask_reg($this->data->__fpu_k3);
            case "__fpu_k4": return new struct___darwin_opmask_reg($this->data->__fpu_k4);
            case "__fpu_k5": return new struct___darwin_opmask_reg($this->data->__fpu_k5);
            case "__fpu_k6": return new struct___darwin_opmask_reg($this->data->__fpu_k6);
            case "__fpu_k7": return new struct___darwin_opmask_reg($this->data->__fpu_k7);
            case "__fpu_zmmh0": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh0);
            case "__fpu_zmmh1": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh1);
            case "__fpu_zmmh2": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh2);
            case "__fpu_zmmh3": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh3);
            case "__fpu_zmmh4": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh4);
            case "__fpu_zmmh5": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh5);
            case "__fpu_zmmh6": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh6);
            case "__fpu_zmmh7": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh7);
            case "__fpu_zmmh8": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh8);
            case "__fpu_zmmh9": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh9);
            case "__fpu_zmmh10": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh10);
            case "__fpu_zmmh11": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh11);
            case "__fpu_zmmh12": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh12);
            case "__fpu_zmmh13": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh13);
            case "__fpu_zmmh14": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh14);
            case "__fpu_zmmh15": return new struct___darwin_ymm_reg($this->data->__fpu_zmmh15);
            case "__fpu_zmm16": return new struct___darwin_zmm_reg($this->data->__fpu_zmm16);
            case "__fpu_zmm17": return new struct___darwin_zmm_reg($this->data->__fpu_zmm17);
            case "__fpu_zmm18": return new struct___darwin_zmm_reg($this->data->__fpu_zmm18);
            case "__fpu_zmm19": return new struct___darwin_zmm_reg($this->data->__fpu_zmm19);
            case "__fpu_zmm20": return new struct___darwin_zmm_reg($this->data->__fpu_zmm20);
            case "__fpu_zmm21": return new struct___darwin_zmm_reg($this->data->__fpu_zmm21);
            case "__fpu_zmm22": return new struct___darwin_zmm_reg($this->data->__fpu_zmm22);
            case "__fpu_zmm23": return new struct___darwin_zmm_reg($this->data->__fpu_zmm23);
            case "__fpu_zmm24": return new struct___darwin_zmm_reg($this->data->__fpu_zmm24);
            case "__fpu_zmm25": return new struct___darwin_zmm_reg($this->data->__fpu_zmm25);
            case "__fpu_zmm26": return new struct___darwin_zmm_reg($this->data->__fpu_zmm26);
            case "__fpu_zmm27": return new struct___darwin_zmm_reg($this->data->__fpu_zmm27);
            case "__fpu_zmm28": return new struct___darwin_zmm_reg($this->data->__fpu_zmm28);
            case "__fpu_zmm29": return new struct___darwin_zmm_reg($this->data->__fpu_zmm29);
            case "__fpu_zmm30": return new struct___darwin_zmm_reg($this->data->__fpu_zmm30);
            case "__fpu_zmm31": return new struct___darwin_zmm_reg($this->data->__fpu_zmm31);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__fpu_reserved":
                (new int_ptr($this->data->__fpu_reserved))->set($value);
                break;
            case "__fpu_fcw":
                (new struct___darwin_fp_control($this->data->__fpu_fcw))->set($value);
                break;
            case "__fpu_fsw":
                (new struct___darwin_fp_status($this->data->__fpu_fsw))->set($value);
                break;
            case "__fpu_ftw":
                $this->data->__fpu_ftw = $value;
                break;
            case "__fpu_rsrv1":
                $this->data->__fpu_rsrv1 = $value;
                break;
            case "__fpu_fop":
                $this->data->__fpu_fop = $value;
                break;
            case "__fpu_ip":
                $this->data->__fpu_ip = $value;
                break;
            case "__fpu_cs":
                $this->data->__fpu_cs = $value;
                break;
            case "__fpu_rsrv2":
                $this->data->__fpu_rsrv2 = $value;
                break;
            case "__fpu_dp":
                $this->data->__fpu_dp = $value;
                break;
            case "__fpu_ds":
                $this->data->__fpu_ds = $value;
                break;
            case "__fpu_rsrv3":
                $this->data->__fpu_rsrv3 = $value;
                break;
            case "__fpu_mxcsr":
                $this->data->__fpu_mxcsr = $value;
                break;
            case "__fpu_mxcsrmask":
                $this->data->__fpu_mxcsrmask = $value;
                break;
            case "__fpu_stmm0":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm0))->set($value);
                break;
            case "__fpu_stmm1":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm1))->set($value);
                break;
            case "__fpu_stmm2":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm2))->set($value);
                break;
            case "__fpu_stmm3":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm3))->set($value);
                break;
            case "__fpu_stmm4":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm4))->set($value);
                break;
            case "__fpu_stmm5":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm5))->set($value);
                break;
            case "__fpu_stmm6":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm6))->set($value);
                break;
            case "__fpu_stmm7":
                (new struct___darwin_mmst_reg($this->data->__fpu_stmm7))->set($value);
                break;
            case "__fpu_xmm0":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm0))->set($value);
                break;
            case "__fpu_xmm1":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm1))->set($value);
                break;
            case "__fpu_xmm2":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm2))->set($value);
                break;
            case "__fpu_xmm3":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm3))->set($value);
                break;
            case "__fpu_xmm4":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm4))->set($value);
                break;
            case "__fpu_xmm5":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm5))->set($value);
                break;
            case "__fpu_xmm6":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm6))->set($value);
                break;
            case "__fpu_xmm7":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm7))->set($value);
                break;
            case "__fpu_xmm8":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm8))->set($value);
                break;
            case "__fpu_xmm9":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm9))->set($value);
                break;
            case "__fpu_xmm10":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm10))->set($value);
                break;
            case "__fpu_xmm11":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm11))->set($value);
                break;
            case "__fpu_xmm12":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm12))->set($value);
                break;
            case "__fpu_xmm13":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm13))->set($value);
                break;
            case "__fpu_xmm14":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm14))->set($value);
                break;
            case "__fpu_xmm15":
                (new struct___darwin_xmm_reg($this->data->__fpu_xmm15))->set($value);
                break;
            case "__fpu_rsrv4":
                (new string_($this->data->__fpu_rsrv4))->set($value);
                break;
            case "__fpu_reserved1":
                $this->data->__fpu_reserved1 = $value;
                break;
            case "__avx_reserved1":
                (new string_($this->data->__avx_reserved1))->set($value);
                break;
            case "__fpu_ymmh0":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh0))->set($value);
                break;
            case "__fpu_ymmh1":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh1))->set($value);
                break;
            case "__fpu_ymmh2":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh2))->set($value);
                break;
            case "__fpu_ymmh3":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh3))->set($value);
                break;
            case "__fpu_ymmh4":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh4))->set($value);
                break;
            case "__fpu_ymmh5":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh5))->set($value);
                break;
            case "__fpu_ymmh6":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh6))->set($value);
                break;
            case "__fpu_ymmh7":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh7))->set($value);
                break;
            case "__fpu_ymmh8":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh8))->set($value);
                break;
            case "__fpu_ymmh9":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh9))->set($value);
                break;
            case "__fpu_ymmh10":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh10))->set($value);
                break;
            case "__fpu_ymmh11":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh11))->set($value);
                break;
            case "__fpu_ymmh12":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh12))->set($value);
                break;
            case "__fpu_ymmh13":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh13))->set($value);
                break;
            case "__fpu_ymmh14":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh14))->set($value);
                break;
            case "__fpu_ymmh15":
                (new struct___darwin_xmm_reg($this->data->__fpu_ymmh15))->set($value);
                break;
            case "__fpu_k0":
                (new struct___darwin_opmask_reg($this->data->__fpu_k0))->set($value);
                break;
            case "__fpu_k1":
                (new struct___darwin_opmask_reg($this->data->__fpu_k1))->set($value);
                break;
            case "__fpu_k2":
                (new struct___darwin_opmask_reg($this->data->__fpu_k2))->set($value);
                break;
            case "__fpu_k3":
                (new struct___darwin_opmask_reg($this->data->__fpu_k3))->set($value);
                break;
            case "__fpu_k4":
                (new struct___darwin_opmask_reg($this->data->__fpu_k4))->set($value);
                break;
            case "__fpu_k5":
                (new struct___darwin_opmask_reg($this->data->__fpu_k5))->set($value);
                break;
            case "__fpu_k6":
                (new struct___darwin_opmask_reg($this->data->__fpu_k6))->set($value);
                break;
            case "__fpu_k7":
                (new struct___darwin_opmask_reg($this->data->__fpu_k7))->set($value);
                break;
            case "__fpu_zmmh0":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh0))->set($value);
                break;
            case "__fpu_zmmh1":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh1))->set($value);
                break;
            case "__fpu_zmmh2":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh2))->set($value);
                break;
            case "__fpu_zmmh3":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh3))->set($value);
                break;
            case "__fpu_zmmh4":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh4))->set($value);
                break;
            case "__fpu_zmmh5":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh5))->set($value);
                break;
            case "__fpu_zmmh6":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh6))->set($value);
                break;
            case "__fpu_zmmh7":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh7))->set($value);
                break;
            case "__fpu_zmmh8":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh8))->set($value);
                break;
            case "__fpu_zmmh9":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh9))->set($value);
                break;
            case "__fpu_zmmh10":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh10))->set($value);
                break;
            case "__fpu_zmmh11":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh11))->set($value);
                break;
            case "__fpu_zmmh12":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh12))->set($value);
                break;
            case "__fpu_zmmh13":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh13))->set($value);
                break;
            case "__fpu_zmmh14":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh14))->set($value);
                break;
            case "__fpu_zmmh15":
                (new struct___darwin_ymm_reg($this->data->__fpu_zmmh15))->set($value);
                break;
            case "__fpu_zmm16":
                (new struct___darwin_zmm_reg($this->data->__fpu_zmm16))->set($value);
                break;
            case "__fpu_zmm17":
                (new struct___darwin_zmm_reg($this->data->__fpu_zmm17))->set($value);
                break;
            case "__fpu_zmm18":
                (new struct___darwin_zmm_reg($this->data->__fpu_zmm18))->set($value);
                break;
            case "__fpu_zmm19":
                (new struct___darwin_zmm_reg($this->data->__fpu_zmm19))->set($value);
                break;
            case "__fpu_zmm20":
                (new struct___darwin_zmm_reg($this->data->__fpu_zmm20))->set($value);
                break;
            case "__fpu_zmm21":
                (new struct___darwin_zmm_reg($this->data->__fpu_zmm21))->set($value);
                break;
            case "__fpu_zmm22":
                (new struct___darwin_zmm_reg($this->data->__fpu_zmm22))->set($value);
                break;
            case "__fpu_zmm23":
                (new struct___darwin_zmm_reg($this->data->__fpu_zmm23))->set($value);
                break;
            case "__fpu_zmm24":
                (new struct___darwin_zmm_reg($this->data->__fpu_zmm24))->set($value);
                break;
            case "__fpu_zmm25":
                (new struct___darwin_zmm_reg($this->data->__fpu_zmm25))->set($value);
                break;
            case "__fpu_zmm26":
                (new struct___darwin_zmm_reg($this->data->__fpu_zmm26))->set($value);
                break;
            case "__fpu_zmm27":
                (new struct___darwin_zmm_reg($this->data->__fpu_zmm27))->set($value);
                break;
            case "__fpu_zmm28":
                (new struct___darwin_zmm_reg($this->data->__fpu_zmm28))->set($value);
                break;
            case "__fpu_zmm29":
                (new struct___darwin_zmm_reg($this->data->__fpu_zmm29))->set($value);
                break;
            case "__fpu_zmm30":
                (new struct___darwin_zmm_reg($this->data->__fpu_zmm30))->set($value);
                break;
            case "__fpu_zmm31":
                (new struct___darwin_zmm_reg($this->data->__fpu_zmm31))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_x86_avx512_state64 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_avx512_state64'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int_ptr $__fpu_reserved
 * @property struct___darwin_fp_control $__fpu_fcw
 * @property struct___darwin_fp_status $__fpu_fsw
 * @property int $__fpu_ftw
 * @property int $__fpu_rsrv1
 * @property int $__fpu_fop
 * @property int $__fpu_ip
 * @property int $__fpu_cs
 * @property int $__fpu_rsrv2
 * @property int $__fpu_dp
 * @property int $__fpu_ds
 * @property int $__fpu_rsrv3
 * @property int $__fpu_mxcsr
 * @property int $__fpu_mxcsrmask
 * @property struct___darwin_mmst_reg $__fpu_stmm0
 * @property struct___darwin_mmst_reg $__fpu_stmm1
 * @property struct___darwin_mmst_reg $__fpu_stmm2
 * @property struct___darwin_mmst_reg $__fpu_stmm3
 * @property struct___darwin_mmst_reg $__fpu_stmm4
 * @property struct___darwin_mmst_reg $__fpu_stmm5
 * @property struct___darwin_mmst_reg $__fpu_stmm6
 * @property struct___darwin_mmst_reg $__fpu_stmm7
 * @property struct___darwin_xmm_reg $__fpu_xmm0
 * @property struct___darwin_xmm_reg $__fpu_xmm1
 * @property struct___darwin_xmm_reg $__fpu_xmm2
 * @property struct___darwin_xmm_reg $__fpu_xmm3
 * @property struct___darwin_xmm_reg $__fpu_xmm4
 * @property struct___darwin_xmm_reg $__fpu_xmm5
 * @property struct___darwin_xmm_reg $__fpu_xmm6
 * @property struct___darwin_xmm_reg $__fpu_xmm7
 * @property struct___darwin_xmm_reg $__fpu_xmm8
 * @property struct___darwin_xmm_reg $__fpu_xmm9
 * @property struct___darwin_xmm_reg $__fpu_xmm10
 * @property struct___darwin_xmm_reg $__fpu_xmm11
 * @property struct___darwin_xmm_reg $__fpu_xmm12
 * @property struct___darwin_xmm_reg $__fpu_xmm13
 * @property struct___darwin_xmm_reg $__fpu_xmm14
 * @property struct___darwin_xmm_reg $__fpu_xmm15
 * @property string_ $__fpu_rsrv4
 * @property int $__fpu_reserved1
 * @property string_ $__avx_reserved1
 * @property struct___darwin_xmm_reg $__fpu_ymmh0
 * @property struct___darwin_xmm_reg $__fpu_ymmh1
 * @property struct___darwin_xmm_reg $__fpu_ymmh2
 * @property struct___darwin_xmm_reg $__fpu_ymmh3
 * @property struct___darwin_xmm_reg $__fpu_ymmh4
 * @property struct___darwin_xmm_reg $__fpu_ymmh5
 * @property struct___darwin_xmm_reg $__fpu_ymmh6
 * @property struct___darwin_xmm_reg $__fpu_ymmh7
 * @property struct___darwin_xmm_reg $__fpu_ymmh8
 * @property struct___darwin_xmm_reg $__fpu_ymmh9
 * @property struct___darwin_xmm_reg $__fpu_ymmh10
 * @property struct___darwin_xmm_reg $__fpu_ymmh11
 * @property struct___darwin_xmm_reg $__fpu_ymmh12
 * @property struct___darwin_xmm_reg $__fpu_ymmh13
 * @property struct___darwin_xmm_reg $__fpu_ymmh14
 * @property struct___darwin_xmm_reg $__fpu_ymmh15
 * @property struct___darwin_opmask_reg $__fpu_k0
 * @property struct___darwin_opmask_reg $__fpu_k1
 * @property struct___darwin_opmask_reg $__fpu_k2
 * @property struct___darwin_opmask_reg $__fpu_k3
 * @property struct___darwin_opmask_reg $__fpu_k4
 * @property struct___darwin_opmask_reg $__fpu_k5
 * @property struct___darwin_opmask_reg $__fpu_k6
 * @property struct___darwin_opmask_reg $__fpu_k7
 * @property struct___darwin_ymm_reg $__fpu_zmmh0
 * @property struct___darwin_ymm_reg $__fpu_zmmh1
 * @property struct___darwin_ymm_reg $__fpu_zmmh2
 * @property struct___darwin_ymm_reg $__fpu_zmmh3
 * @property struct___darwin_ymm_reg $__fpu_zmmh4
 * @property struct___darwin_ymm_reg $__fpu_zmmh5
 * @property struct___darwin_ymm_reg $__fpu_zmmh6
 * @property struct___darwin_ymm_reg $__fpu_zmmh7
 * @property struct___darwin_ymm_reg $__fpu_zmmh8
 * @property struct___darwin_ymm_reg $__fpu_zmmh9
 * @property struct___darwin_ymm_reg $__fpu_zmmh10
 * @property struct___darwin_ymm_reg $__fpu_zmmh11
 * @property struct___darwin_ymm_reg $__fpu_zmmh12
 * @property struct___darwin_ymm_reg $__fpu_zmmh13
 * @property struct___darwin_ymm_reg $__fpu_zmmh14
 * @property struct___darwin_ymm_reg $__fpu_zmmh15
 * @property struct___darwin_zmm_reg $__fpu_zmm16
 * @property struct___darwin_zmm_reg $__fpu_zmm17
 * @property struct___darwin_zmm_reg $__fpu_zmm18
 * @property struct___darwin_zmm_reg $__fpu_zmm19
 * @property struct___darwin_zmm_reg $__fpu_zmm20
 * @property struct___darwin_zmm_reg $__fpu_zmm21
 * @property struct___darwin_zmm_reg $__fpu_zmm22
 * @property struct___darwin_zmm_reg $__fpu_zmm23
 * @property struct___darwin_zmm_reg $__fpu_zmm24
 * @property struct___darwin_zmm_reg $__fpu_zmm25
 * @property struct___darwin_zmm_reg $__fpu_zmm26
 * @property struct___darwin_zmm_reg $__fpu_zmm27
 * @property struct___darwin_zmm_reg $__fpu_zmm28
 * @property struct___darwin_zmm_reg $__fpu_zmm29
 * @property struct___darwin_zmm_reg $__fpu_zmm30
 * @property struct___darwin_zmm_reg $__fpu_zmm31
 */
class struct___darwin_x86_avx512_state64_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_avx512_state64_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_avx512_state64_ptr_ptr { return new struct___darwin_x86_avx512_state64_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_avx512_state64 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_avx512_state64 { return new struct___darwin_x86_avx512_state64($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_avx512_state64[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_avx512_state64($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__fpu_reserved": return new int_ptr($this->data[0]->__fpu_reserved);
            case "__fpu_fcw": return new struct___darwin_fp_control($this->data[0]->__fpu_fcw);
            case "__fpu_fsw": return new struct___darwin_fp_status($this->data[0]->__fpu_fsw);
            case "__fpu_ftw": return $this->data[0]->__fpu_ftw;
            case "__fpu_rsrv1": return $this->data[0]->__fpu_rsrv1;
            case "__fpu_fop": return $this->data[0]->__fpu_fop;
            case "__fpu_ip": return $this->data[0]->__fpu_ip;
            case "__fpu_cs": return $this->data[0]->__fpu_cs;
            case "__fpu_rsrv2": return $this->data[0]->__fpu_rsrv2;
            case "__fpu_dp": return $this->data[0]->__fpu_dp;
            case "__fpu_ds": return $this->data[0]->__fpu_ds;
            case "__fpu_rsrv3": return $this->data[0]->__fpu_rsrv3;
            case "__fpu_mxcsr": return $this->data[0]->__fpu_mxcsr;
            case "__fpu_mxcsrmask": return $this->data[0]->__fpu_mxcsrmask;
            case "__fpu_stmm0": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm0);
            case "__fpu_stmm1": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm1);
            case "__fpu_stmm2": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm2);
            case "__fpu_stmm3": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm3);
            case "__fpu_stmm4": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm4);
            case "__fpu_stmm5": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm5);
            case "__fpu_stmm6": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm6);
            case "__fpu_stmm7": return new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm7);
            case "__fpu_xmm0": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm0);
            case "__fpu_xmm1": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm1);
            case "__fpu_xmm2": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm2);
            case "__fpu_xmm3": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm3);
            case "__fpu_xmm4": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm4);
            case "__fpu_xmm5": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm5);
            case "__fpu_xmm6": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm6);
            case "__fpu_xmm7": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm7);
            case "__fpu_xmm8": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm8);
            case "__fpu_xmm9": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm9);
            case "__fpu_xmm10": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm10);
            case "__fpu_xmm11": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm11);
            case "__fpu_xmm12": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm12);
            case "__fpu_xmm13": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm13);
            case "__fpu_xmm14": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm14);
            case "__fpu_xmm15": return new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm15);
            case "__fpu_rsrv4": return new string_($this->data[0]->__fpu_rsrv4);
            case "__fpu_reserved1": return $this->data[0]->__fpu_reserved1;
            case "__avx_reserved1": return new string_($this->data[0]->__avx_reserved1);
            case "__fpu_ymmh0": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh0);
            case "__fpu_ymmh1": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh1);
            case "__fpu_ymmh2": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh2);
            case "__fpu_ymmh3": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh3);
            case "__fpu_ymmh4": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh4);
            case "__fpu_ymmh5": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh5);
            case "__fpu_ymmh6": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh6);
            case "__fpu_ymmh7": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh7);
            case "__fpu_ymmh8": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh8);
            case "__fpu_ymmh9": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh9);
            case "__fpu_ymmh10": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh10);
            case "__fpu_ymmh11": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh11);
            case "__fpu_ymmh12": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh12);
            case "__fpu_ymmh13": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh13);
            case "__fpu_ymmh14": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh14);
            case "__fpu_ymmh15": return new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh15);
            case "__fpu_k0": return new struct___darwin_opmask_reg($this->data[0]->__fpu_k0);
            case "__fpu_k1": return new struct___darwin_opmask_reg($this->data[0]->__fpu_k1);
            case "__fpu_k2": return new struct___darwin_opmask_reg($this->data[0]->__fpu_k2);
            case "__fpu_k3": return new struct___darwin_opmask_reg($this->data[0]->__fpu_k3);
            case "__fpu_k4": return new struct___darwin_opmask_reg($this->data[0]->__fpu_k4);
            case "__fpu_k5": return new struct___darwin_opmask_reg($this->data[0]->__fpu_k5);
            case "__fpu_k6": return new struct___darwin_opmask_reg($this->data[0]->__fpu_k6);
            case "__fpu_k7": return new struct___darwin_opmask_reg($this->data[0]->__fpu_k7);
            case "__fpu_zmmh0": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh0);
            case "__fpu_zmmh1": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh1);
            case "__fpu_zmmh2": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh2);
            case "__fpu_zmmh3": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh3);
            case "__fpu_zmmh4": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh4);
            case "__fpu_zmmh5": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh5);
            case "__fpu_zmmh6": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh6);
            case "__fpu_zmmh7": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh7);
            case "__fpu_zmmh8": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh8);
            case "__fpu_zmmh9": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh9);
            case "__fpu_zmmh10": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh10);
            case "__fpu_zmmh11": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh11);
            case "__fpu_zmmh12": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh12);
            case "__fpu_zmmh13": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh13);
            case "__fpu_zmmh14": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh14);
            case "__fpu_zmmh15": return new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh15);
            case "__fpu_zmm16": return new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm16);
            case "__fpu_zmm17": return new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm17);
            case "__fpu_zmm18": return new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm18);
            case "__fpu_zmm19": return new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm19);
            case "__fpu_zmm20": return new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm20);
            case "__fpu_zmm21": return new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm21);
            case "__fpu_zmm22": return new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm22);
            case "__fpu_zmm23": return new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm23);
            case "__fpu_zmm24": return new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm24);
            case "__fpu_zmm25": return new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm25);
            case "__fpu_zmm26": return new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm26);
            case "__fpu_zmm27": return new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm27);
            case "__fpu_zmm28": return new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm28);
            case "__fpu_zmm29": return new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm29);
            case "__fpu_zmm30": return new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm30);
            case "__fpu_zmm31": return new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm31);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__fpu_reserved":
                (new int_ptr($this->data[0]->__fpu_reserved))->set($value);
                break;
            case "__fpu_fcw":
                (new struct___darwin_fp_control($this->data[0]->__fpu_fcw))->set($value);
                break;
            case "__fpu_fsw":
                (new struct___darwin_fp_status($this->data[0]->__fpu_fsw))->set($value);
                break;
            case "__fpu_ftw":
                $this->data[0]->__fpu_ftw = $value;
                break;
            case "__fpu_rsrv1":
                $this->data[0]->__fpu_rsrv1 = $value;
                break;
            case "__fpu_fop":
                $this->data[0]->__fpu_fop = $value;
                break;
            case "__fpu_ip":
                $this->data[0]->__fpu_ip = $value;
                break;
            case "__fpu_cs":
                $this->data[0]->__fpu_cs = $value;
                break;
            case "__fpu_rsrv2":
                $this->data[0]->__fpu_rsrv2 = $value;
                break;
            case "__fpu_dp":
                $this->data[0]->__fpu_dp = $value;
                break;
            case "__fpu_ds":
                $this->data[0]->__fpu_ds = $value;
                break;
            case "__fpu_rsrv3":
                $this->data[0]->__fpu_rsrv3 = $value;
                break;
            case "__fpu_mxcsr":
                $this->data[0]->__fpu_mxcsr = $value;
                break;
            case "__fpu_mxcsrmask":
                $this->data[0]->__fpu_mxcsrmask = $value;
                break;
            case "__fpu_stmm0":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm0))->set($value);
                break;
            case "__fpu_stmm1":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm1))->set($value);
                break;
            case "__fpu_stmm2":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm2))->set($value);
                break;
            case "__fpu_stmm3":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm3))->set($value);
                break;
            case "__fpu_stmm4":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm4))->set($value);
                break;
            case "__fpu_stmm5":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm5))->set($value);
                break;
            case "__fpu_stmm6":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm6))->set($value);
                break;
            case "__fpu_stmm7":
                (new struct___darwin_mmst_reg($this->data[0]->__fpu_stmm7))->set($value);
                break;
            case "__fpu_xmm0":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm0))->set($value);
                break;
            case "__fpu_xmm1":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm1))->set($value);
                break;
            case "__fpu_xmm2":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm2))->set($value);
                break;
            case "__fpu_xmm3":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm3))->set($value);
                break;
            case "__fpu_xmm4":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm4))->set($value);
                break;
            case "__fpu_xmm5":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm5))->set($value);
                break;
            case "__fpu_xmm6":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm6))->set($value);
                break;
            case "__fpu_xmm7":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm7))->set($value);
                break;
            case "__fpu_xmm8":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm8))->set($value);
                break;
            case "__fpu_xmm9":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm9))->set($value);
                break;
            case "__fpu_xmm10":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm10))->set($value);
                break;
            case "__fpu_xmm11":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm11))->set($value);
                break;
            case "__fpu_xmm12":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm12))->set($value);
                break;
            case "__fpu_xmm13":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm13))->set($value);
                break;
            case "__fpu_xmm14":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm14))->set($value);
                break;
            case "__fpu_xmm15":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_xmm15))->set($value);
                break;
            case "__fpu_rsrv4":
                (new string_($this->data[0]->__fpu_rsrv4))->set($value);
                break;
            case "__fpu_reserved1":
                $this->data[0]->__fpu_reserved1 = $value;
                break;
            case "__avx_reserved1":
                (new string_($this->data[0]->__avx_reserved1))->set($value);
                break;
            case "__fpu_ymmh0":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh0))->set($value);
                break;
            case "__fpu_ymmh1":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh1))->set($value);
                break;
            case "__fpu_ymmh2":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh2))->set($value);
                break;
            case "__fpu_ymmh3":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh3))->set($value);
                break;
            case "__fpu_ymmh4":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh4))->set($value);
                break;
            case "__fpu_ymmh5":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh5))->set($value);
                break;
            case "__fpu_ymmh6":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh6))->set($value);
                break;
            case "__fpu_ymmh7":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh7))->set($value);
                break;
            case "__fpu_ymmh8":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh8))->set($value);
                break;
            case "__fpu_ymmh9":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh9))->set($value);
                break;
            case "__fpu_ymmh10":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh10))->set($value);
                break;
            case "__fpu_ymmh11":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh11))->set($value);
                break;
            case "__fpu_ymmh12":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh12))->set($value);
                break;
            case "__fpu_ymmh13":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh13))->set($value);
                break;
            case "__fpu_ymmh14":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh14))->set($value);
                break;
            case "__fpu_ymmh15":
                (new struct___darwin_xmm_reg($this->data[0]->__fpu_ymmh15))->set($value);
                break;
            case "__fpu_k0":
                (new struct___darwin_opmask_reg($this->data[0]->__fpu_k0))->set($value);
                break;
            case "__fpu_k1":
                (new struct___darwin_opmask_reg($this->data[0]->__fpu_k1))->set($value);
                break;
            case "__fpu_k2":
                (new struct___darwin_opmask_reg($this->data[0]->__fpu_k2))->set($value);
                break;
            case "__fpu_k3":
                (new struct___darwin_opmask_reg($this->data[0]->__fpu_k3))->set($value);
                break;
            case "__fpu_k4":
                (new struct___darwin_opmask_reg($this->data[0]->__fpu_k4))->set($value);
                break;
            case "__fpu_k5":
                (new struct___darwin_opmask_reg($this->data[0]->__fpu_k5))->set($value);
                break;
            case "__fpu_k6":
                (new struct___darwin_opmask_reg($this->data[0]->__fpu_k6))->set($value);
                break;
            case "__fpu_k7":
                (new struct___darwin_opmask_reg($this->data[0]->__fpu_k7))->set($value);
                break;
            case "__fpu_zmmh0":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh0))->set($value);
                break;
            case "__fpu_zmmh1":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh1))->set($value);
                break;
            case "__fpu_zmmh2":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh2))->set($value);
                break;
            case "__fpu_zmmh3":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh3))->set($value);
                break;
            case "__fpu_zmmh4":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh4))->set($value);
                break;
            case "__fpu_zmmh5":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh5))->set($value);
                break;
            case "__fpu_zmmh6":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh6))->set($value);
                break;
            case "__fpu_zmmh7":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh7))->set($value);
                break;
            case "__fpu_zmmh8":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh8))->set($value);
                break;
            case "__fpu_zmmh9":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh9))->set($value);
                break;
            case "__fpu_zmmh10":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh10))->set($value);
                break;
            case "__fpu_zmmh11":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh11))->set($value);
                break;
            case "__fpu_zmmh12":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh12))->set($value);
                break;
            case "__fpu_zmmh13":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh13))->set($value);
                break;
            case "__fpu_zmmh14":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh14))->set($value);
                break;
            case "__fpu_zmmh15":
                (new struct___darwin_ymm_reg($this->data[0]->__fpu_zmmh15))->set($value);
                break;
            case "__fpu_zmm16":
                (new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm16))->set($value);
                break;
            case "__fpu_zmm17":
                (new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm17))->set($value);
                break;
            case "__fpu_zmm18":
                (new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm18))->set($value);
                break;
            case "__fpu_zmm19":
                (new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm19))->set($value);
                break;
            case "__fpu_zmm20":
                (new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm20))->set($value);
                break;
            case "__fpu_zmm21":
                (new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm21))->set($value);
                break;
            case "__fpu_zmm22":
                (new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm22))->set($value);
                break;
            case "__fpu_zmm23":
                (new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm23))->set($value);
                break;
            case "__fpu_zmm24":
                (new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm24))->set($value);
                break;
            case "__fpu_zmm25":
                (new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm25))->set($value);
                break;
            case "__fpu_zmm26":
                (new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm26))->set($value);
                break;
            case "__fpu_zmm27":
                (new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm27))->set($value);
                break;
            case "__fpu_zmm28":
                (new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm28))->set($value);
                break;
            case "__fpu_zmm29":
                (new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm29))->set($value);
                break;
            case "__fpu_zmm30":
                (new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm30))->set($value);
                break;
            case "__fpu_zmm31":
                (new struct___darwin_zmm_reg($this->data[0]->__fpu_zmm31))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_x86_avx512_state64_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_avx512_state64*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_avx512_state64_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_avx512_state64_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_avx512_state64_ptr_ptr_ptr { return new struct___darwin_x86_avx512_state64_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_avx512_state64_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_avx512_state64_ptr { return new struct___darwin_x86_avx512_state64_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_avx512_state64_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_avx512_state64_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_avx512_state64_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_avx512_state64_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_avx512_state64**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_avx512_state64_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_avx512_state64_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_avx512_state64_ptr_ptr_ptr_ptr { return new struct___darwin_x86_avx512_state64_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_avx512_state64_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_avx512_state64_ptr_ptr { return new struct___darwin_x86_avx512_state64_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_avx512_state64_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_avx512_state64_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_avx512_state64_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_avx512_state64_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_avx512_state64***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_avx512_state64_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_avx512_state64_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_avx512_state64_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_x86_avx512_state64_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_avx512_state64_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_avx512_state64_ptr_ptr_ptr { return new struct___darwin_x86_avx512_state64_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_avx512_state64_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_avx512_state64_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_avx512_state64_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_avx512_state64_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_avx512_state64****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__trapno
 * @property int $__cpu
 * @property int $__err
 * @property int $__faultvaddr
 */
class struct___darwin_x86_exception_state64 implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_exception_state64 $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_exception_state64_ptr { return new struct___darwin_x86_exception_state64_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__trapno": return $this->data->__trapno;
            case "__cpu": return $this->data->__cpu;
            case "__err": return $this->data->__err;
            case "__faultvaddr": return $this->data->__faultvaddr;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__trapno":
                $this->data->__trapno = $value;
                break;
            case "__cpu":
                $this->data->__cpu = $value;
                break;
            case "__err":
                $this->data->__err = $value;
                break;
            case "__faultvaddr":
                $this->data->__faultvaddr = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_x86_exception_state64 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_exception_state64'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__trapno
 * @property int $__cpu
 * @property int $__err
 * @property int $__faultvaddr
 */
class struct___darwin_x86_exception_state64_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_exception_state64_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_exception_state64_ptr_ptr { return new struct___darwin_x86_exception_state64_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_exception_state64 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_exception_state64 { return new struct___darwin_x86_exception_state64($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_exception_state64[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_exception_state64($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__trapno": return $this->data[0]->__trapno;
            case "__cpu": return $this->data[0]->__cpu;
            case "__err": return $this->data[0]->__err;
            case "__faultvaddr": return $this->data[0]->__faultvaddr;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__trapno":
                $this->data[0]->__trapno = $value;
                break;
            case "__cpu":
                $this->data[0]->__cpu = $value;
                break;
            case "__err":
                $this->data[0]->__err = $value;
                break;
            case "__faultvaddr":
                $this->data[0]->__faultvaddr = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_x86_exception_state64_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_exception_state64*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_exception_state64_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_exception_state64_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_exception_state64_ptr_ptr_ptr { return new struct___darwin_x86_exception_state64_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_exception_state64_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_exception_state64_ptr { return new struct___darwin_x86_exception_state64_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_exception_state64_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_exception_state64_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_exception_state64_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_exception_state64_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_exception_state64**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_exception_state64_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_exception_state64_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_exception_state64_ptr_ptr_ptr_ptr { return new struct___darwin_x86_exception_state64_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_exception_state64_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_exception_state64_ptr_ptr { return new struct___darwin_x86_exception_state64_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_exception_state64_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_exception_state64_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_exception_state64_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_exception_state64_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_exception_state64***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_exception_state64_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_exception_state64_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_exception_state64_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_x86_exception_state64_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_exception_state64_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_exception_state64_ptr_ptr_ptr { return new struct___darwin_x86_exception_state64_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_exception_state64_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_exception_state64_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_exception_state64_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_exception_state64_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_exception_state64****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__dr0
 * @property int $__dr1
 * @property int $__dr2
 * @property int $__dr3
 * @property int $__dr4
 * @property int $__dr5
 * @property int $__dr6
 * @property int $__dr7
 */
class struct___darwin_x86_debug_state64 implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_debug_state64 $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_debug_state64_ptr { return new struct___darwin_x86_debug_state64_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__dr0": return $this->data->__dr0;
            case "__dr1": return $this->data->__dr1;
            case "__dr2": return $this->data->__dr2;
            case "__dr3": return $this->data->__dr3;
            case "__dr4": return $this->data->__dr4;
            case "__dr5": return $this->data->__dr5;
            case "__dr6": return $this->data->__dr6;
            case "__dr7": return $this->data->__dr7;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__dr0":
                $this->data->__dr0 = $value;
                break;
            case "__dr1":
                $this->data->__dr1 = $value;
                break;
            case "__dr2":
                $this->data->__dr2 = $value;
                break;
            case "__dr3":
                $this->data->__dr3 = $value;
                break;
            case "__dr4":
                $this->data->__dr4 = $value;
                break;
            case "__dr5":
                $this->data->__dr5 = $value;
                break;
            case "__dr6":
                $this->data->__dr6 = $value;
                break;
            case "__dr7":
                $this->data->__dr7 = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_x86_debug_state64 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_debug_state64'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $__dr0
 * @property int $__dr1
 * @property int $__dr2
 * @property int $__dr3
 * @property int $__dr4
 * @property int $__dr5
 * @property int $__dr6
 * @property int $__dr7
 */
class struct___darwin_x86_debug_state64_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_debug_state64_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_debug_state64_ptr_ptr { return new struct___darwin_x86_debug_state64_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_debug_state64 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_debug_state64 { return new struct___darwin_x86_debug_state64($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_debug_state64[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_debug_state64($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__dr0": return $this->data[0]->__dr0;
            case "__dr1": return $this->data[0]->__dr1;
            case "__dr2": return $this->data[0]->__dr2;
            case "__dr3": return $this->data[0]->__dr3;
            case "__dr4": return $this->data[0]->__dr4;
            case "__dr5": return $this->data[0]->__dr5;
            case "__dr6": return $this->data[0]->__dr6;
            case "__dr7": return $this->data[0]->__dr7;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__dr0":
                $this->data[0]->__dr0 = $value;
                break;
            case "__dr1":
                $this->data[0]->__dr1 = $value;
                break;
            case "__dr2":
                $this->data[0]->__dr2 = $value;
                break;
            case "__dr3":
                $this->data[0]->__dr3 = $value;
                break;
            case "__dr4":
                $this->data[0]->__dr4 = $value;
                break;
            case "__dr5":
                $this->data[0]->__dr5 = $value;
                break;
            case "__dr6":
                $this->data[0]->__dr6 = $value;
                break;
            case "__dr7":
                $this->data[0]->__dr7 = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_x86_debug_state64_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_debug_state64*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_debug_state64_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_debug_state64_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_debug_state64_ptr_ptr_ptr { return new struct___darwin_x86_debug_state64_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_debug_state64_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_debug_state64_ptr { return new struct___darwin_x86_debug_state64_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_debug_state64_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_debug_state64_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_debug_state64_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_debug_state64_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_debug_state64**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_debug_state64_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_debug_state64_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_debug_state64_ptr_ptr_ptr_ptr { return new struct___darwin_x86_debug_state64_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_debug_state64_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_debug_state64_ptr_ptr { return new struct___darwin_x86_debug_state64_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_debug_state64_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_debug_state64_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_debug_state64_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_debug_state64_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_debug_state64***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_debug_state64_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_debug_state64_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_debug_state64_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_x86_debug_state64_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_debug_state64_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_debug_state64_ptr_ptr_ptr { return new struct___darwin_x86_debug_state64_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_debug_state64_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_debug_state64_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_debug_state64_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_debug_state64_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_debug_state64****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property unsigned_long_long_ptr $__ctrs
 */
class struct___darwin_x86_cpmu_state64 implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_cpmu_state64 $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_cpmu_state64_ptr { return new struct___darwin_x86_cpmu_state64_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__ctrs": return new unsigned_long_long_ptr($this->data->__ctrs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__ctrs":
                (new unsigned_long_long_ptr($this->data->__ctrs))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_x86_cpmu_state64 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_cpmu_state64'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property unsigned_long_long_ptr $__ctrs
 */
class struct___darwin_x86_cpmu_state64_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_cpmu_state64_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_cpmu_state64_ptr_ptr { return new struct___darwin_x86_cpmu_state64_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_cpmu_state64 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_cpmu_state64 { return new struct___darwin_x86_cpmu_state64($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_cpmu_state64[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_cpmu_state64($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__ctrs": return new unsigned_long_long_ptr($this->data[0]->__ctrs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__ctrs":
                (new unsigned_long_long_ptr($this->data[0]->__ctrs))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_x86_cpmu_state64_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_cpmu_state64*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_cpmu_state64_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_cpmu_state64_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_cpmu_state64_ptr_ptr_ptr { return new struct___darwin_x86_cpmu_state64_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_cpmu_state64_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_cpmu_state64_ptr { return new struct___darwin_x86_cpmu_state64_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_cpmu_state64_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_cpmu_state64_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_cpmu_state64_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_cpmu_state64_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_cpmu_state64**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_cpmu_state64_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_cpmu_state64_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_cpmu_state64_ptr_ptr_ptr_ptr { return new struct___darwin_x86_cpmu_state64_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_cpmu_state64_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_cpmu_state64_ptr_ptr { return new struct___darwin_x86_cpmu_state64_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_cpmu_state64_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_cpmu_state64_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_cpmu_state64_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_cpmu_state64_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_cpmu_state64***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_x86_cpmu_state64_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_x86_cpmu_state64_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_x86_cpmu_state64_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_x86_cpmu_state64_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_x86_cpmu_state64_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_x86_cpmu_state64_ptr_ptr_ptr { return new struct___darwin_x86_cpmu_state64_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_x86_cpmu_state64_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_x86_cpmu_state64_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_x86_cpmu_state64_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_x86_cpmu_state64_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_x86_cpmu_state64****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct___darwin_i386_exception_state $__es
 * @property struct___darwin_i386_thread_state $__ss
 * @property struct___darwin_i386_float_state $__fs
 */
class struct___darwin_mcontext32 implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext32 $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext32_ptr { return new struct___darwin_mcontext32_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__es": return new struct___darwin_i386_exception_state($this->data->__es);
            case "__ss": return new struct___darwin_i386_thread_state($this->data->__ss);
            case "__fs": return new struct___darwin_i386_float_state($this->data->__fs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__es":
                (new struct___darwin_i386_exception_state($this->data->__es))->set($value);
                break;
            case "__ss":
                (new struct___darwin_i386_thread_state($this->data->__ss))->set($value);
                break;
            case "__fs":
                (new struct___darwin_i386_float_state($this->data->__fs))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_mcontext32 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext32'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct___darwin_i386_exception_state $__es
 * @property struct___darwin_i386_thread_state $__ss
 * @property struct___darwin_i386_float_state $__fs
 */
class struct___darwin_mcontext32_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext32_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext32_ptr_ptr { return new struct___darwin_mcontext32_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext32 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext32 { return new struct___darwin_mcontext32($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext32[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext32($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__es": return new struct___darwin_i386_exception_state($this->data[0]->__es);
            case "__ss": return new struct___darwin_i386_thread_state($this->data[0]->__ss);
            case "__fs": return new struct___darwin_i386_float_state($this->data[0]->__fs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__es":
                (new struct___darwin_i386_exception_state($this->data[0]->__es))->set($value);
                break;
            case "__ss":
                (new struct___darwin_i386_thread_state($this->data[0]->__ss))->set($value);
                break;
            case "__fs":
                (new struct___darwin_i386_float_state($this->data[0]->__fs))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_mcontext32_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext32*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext32_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext32_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext32_ptr_ptr_ptr { return new struct___darwin_mcontext32_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext32_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext32_ptr { return new struct___darwin_mcontext32_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext32_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext32_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext32_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext32_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext32**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext32_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext32_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext32_ptr_ptr_ptr_ptr { return new struct___darwin_mcontext32_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext32_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext32_ptr_ptr { return new struct___darwin_mcontext32_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext32_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext32_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext32_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext32_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext32***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext32_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext32_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext32_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_mcontext32_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext32_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext32_ptr_ptr_ptr { return new struct___darwin_mcontext32_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext32_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext32_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext32_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext32_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext32****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct___darwin_i386_exception_state $__es
 * @property struct___darwin_i386_thread_state $__ss
 * @property struct___darwin_i386_avx_state $__fs
 */
class struct___darwin_mcontext_avx32 implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx32 $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx32_ptr { return new struct___darwin_mcontext_avx32_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__es": return new struct___darwin_i386_exception_state($this->data->__es);
            case "__ss": return new struct___darwin_i386_thread_state($this->data->__ss);
            case "__fs": return new struct___darwin_i386_avx_state($this->data->__fs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__es":
                (new struct___darwin_i386_exception_state($this->data->__es))->set($value);
                break;
            case "__ss":
                (new struct___darwin_i386_thread_state($this->data->__ss))->set($value);
                break;
            case "__fs":
                (new struct___darwin_i386_avx_state($this->data->__fs))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_mcontext_avx32 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx32'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct___darwin_i386_exception_state $__es
 * @property struct___darwin_i386_thread_state $__ss
 * @property struct___darwin_i386_avx_state $__fs
 */
class struct___darwin_mcontext_avx32_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx32_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx32_ptr_ptr { return new struct___darwin_mcontext_avx32_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx32 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx32 { return new struct___darwin_mcontext_avx32($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx32[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx32($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__es": return new struct___darwin_i386_exception_state($this->data[0]->__es);
            case "__ss": return new struct___darwin_i386_thread_state($this->data[0]->__ss);
            case "__fs": return new struct___darwin_i386_avx_state($this->data[0]->__fs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__es":
                (new struct___darwin_i386_exception_state($this->data[0]->__es))->set($value);
                break;
            case "__ss":
                (new struct___darwin_i386_thread_state($this->data[0]->__ss))->set($value);
                break;
            case "__fs":
                (new struct___darwin_i386_avx_state($this->data[0]->__fs))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_mcontext_avx32_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx32*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext_avx32_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx32_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx32_ptr_ptr_ptr { return new struct___darwin_mcontext_avx32_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx32_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx32_ptr { return new struct___darwin_mcontext_avx32_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx32_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext_avx32_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx32_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext_avx32_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx32**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext_avx32_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx32_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx32_ptr_ptr_ptr_ptr { return new struct___darwin_mcontext_avx32_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx32_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx32_ptr_ptr { return new struct___darwin_mcontext_avx32_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx32_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext_avx32_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx32_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext_avx32_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx32***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext_avx32_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx32_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx32_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_mcontext_avx32_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx32_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx32_ptr_ptr_ptr { return new struct___darwin_mcontext_avx32_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx32_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext_avx32_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx32_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext_avx32_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx32****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct___darwin_i386_exception_state $__es
 * @property struct___darwin_i386_thread_state $__ss
 * @property struct___darwin_i386_avx512_state $__fs
 */
class struct___darwin_mcontext_avx512_32 implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx512_32 $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx512_32_ptr { return new struct___darwin_mcontext_avx512_32_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__es": return new struct___darwin_i386_exception_state($this->data->__es);
            case "__ss": return new struct___darwin_i386_thread_state($this->data->__ss);
            case "__fs": return new struct___darwin_i386_avx512_state($this->data->__fs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__es":
                (new struct___darwin_i386_exception_state($this->data->__es))->set($value);
                break;
            case "__ss":
                (new struct___darwin_i386_thread_state($this->data->__ss))->set($value);
                break;
            case "__fs":
                (new struct___darwin_i386_avx512_state($this->data->__fs))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_mcontext_avx512_32 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx512_32'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct___darwin_i386_exception_state $__es
 * @property struct___darwin_i386_thread_state $__ss
 * @property struct___darwin_i386_avx512_state $__fs
 */
class struct___darwin_mcontext_avx512_32_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx512_32_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx512_32_ptr_ptr { return new struct___darwin_mcontext_avx512_32_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx512_32 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx512_32 { return new struct___darwin_mcontext_avx512_32($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx512_32[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx512_32($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__es": return new struct___darwin_i386_exception_state($this->data[0]->__es);
            case "__ss": return new struct___darwin_i386_thread_state($this->data[0]->__ss);
            case "__fs": return new struct___darwin_i386_avx512_state($this->data[0]->__fs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__es":
                (new struct___darwin_i386_exception_state($this->data[0]->__es))->set($value);
                break;
            case "__ss":
                (new struct___darwin_i386_thread_state($this->data[0]->__ss))->set($value);
                break;
            case "__fs":
                (new struct___darwin_i386_avx512_state($this->data[0]->__fs))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_mcontext_avx512_32_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx512_32*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext_avx512_32_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx512_32_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx512_32_ptr_ptr_ptr { return new struct___darwin_mcontext_avx512_32_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx512_32_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx512_32_ptr { return new struct___darwin_mcontext_avx512_32_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx512_32_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext_avx512_32_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx512_32_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext_avx512_32_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx512_32**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext_avx512_32_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx512_32_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx512_32_ptr_ptr_ptr_ptr { return new struct___darwin_mcontext_avx512_32_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx512_32_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx512_32_ptr_ptr { return new struct___darwin_mcontext_avx512_32_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx512_32_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext_avx512_32_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx512_32_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext_avx512_32_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx512_32***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext_avx512_32_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx512_32_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx512_32_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_mcontext_avx512_32_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx512_32_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx512_32_ptr_ptr_ptr { return new struct___darwin_mcontext_avx512_32_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx512_32_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext_avx512_32_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx512_32_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext_avx512_32_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx512_32****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct___darwin_x86_exception_state64 $__es
 * @property struct___darwin_x86_thread_state64 $__ss
 * @property struct___darwin_x86_float_state64 $__fs
 */
class struct___darwin_mcontext64 implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext64 $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext64_ptr { return new struct___darwin_mcontext64_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__es": return new struct___darwin_x86_exception_state64($this->data->__es);
            case "__ss": return new struct___darwin_x86_thread_state64($this->data->__ss);
            case "__fs": return new struct___darwin_x86_float_state64($this->data->__fs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__es":
                (new struct___darwin_x86_exception_state64($this->data->__es))->set($value);
                break;
            case "__ss":
                (new struct___darwin_x86_thread_state64($this->data->__ss))->set($value);
                break;
            case "__fs":
                (new struct___darwin_x86_float_state64($this->data->__fs))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_mcontext64 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext64'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct___darwin_x86_exception_state64 $__es
 * @property struct___darwin_x86_thread_state64 $__ss
 * @property struct___darwin_x86_float_state64 $__fs
 */
class struct___darwin_mcontext64_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext64_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext64_ptr_ptr { return new struct___darwin_mcontext64_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext64 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext64 { return new struct___darwin_mcontext64($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext64[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext64($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__es": return new struct___darwin_x86_exception_state64($this->data[0]->__es);
            case "__ss": return new struct___darwin_x86_thread_state64($this->data[0]->__ss);
            case "__fs": return new struct___darwin_x86_float_state64($this->data[0]->__fs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__es":
                (new struct___darwin_x86_exception_state64($this->data[0]->__es))->set($value);
                break;
            case "__ss":
                (new struct___darwin_x86_thread_state64($this->data[0]->__ss))->set($value);
                break;
            case "__fs":
                (new struct___darwin_x86_float_state64($this->data[0]->__fs))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_mcontext64_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext64*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext64_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext64_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext64_ptr_ptr_ptr { return new struct___darwin_mcontext64_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext64_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext64_ptr { return new struct___darwin_mcontext64_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext64_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext64_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext64_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext64_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext64**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext64_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext64_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext64_ptr_ptr_ptr_ptr { return new struct___darwin_mcontext64_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext64_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext64_ptr_ptr { return new struct___darwin_mcontext64_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext64_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext64_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext64_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext64_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext64***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext64_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext64_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext64_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_mcontext64_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext64_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext64_ptr_ptr_ptr { return new struct___darwin_mcontext64_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext64_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext64_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext64_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext64_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext64****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct___darwin_x86_exception_state64 $__es
 * @property struct___darwin_x86_thread_full_state64 $__ss
 * @property struct___darwin_x86_float_state64 $__fs
 */
class struct___darwin_mcontext64_full implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext64_full $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext64_full_ptr { return new struct___darwin_mcontext64_full_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__es": return new struct___darwin_x86_exception_state64($this->data->__es);
            case "__ss": return new struct___darwin_x86_thread_full_state64($this->data->__ss);
            case "__fs": return new struct___darwin_x86_float_state64($this->data->__fs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__es":
                (new struct___darwin_x86_exception_state64($this->data->__es))->set($value);
                break;
            case "__ss":
                (new struct___darwin_x86_thread_full_state64($this->data->__ss))->set($value);
                break;
            case "__fs":
                (new struct___darwin_x86_float_state64($this->data->__fs))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_mcontext64_full $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext64_full'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct___darwin_x86_exception_state64 $__es
 * @property struct___darwin_x86_thread_full_state64 $__ss
 * @property struct___darwin_x86_float_state64 $__fs
 */
class struct___darwin_mcontext64_full_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext64_full_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext64_full_ptr_ptr { return new struct___darwin_mcontext64_full_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext64_full { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext64_full { return new struct___darwin_mcontext64_full($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext64_full[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext64_full($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__es": return new struct___darwin_x86_exception_state64($this->data[0]->__es);
            case "__ss": return new struct___darwin_x86_thread_full_state64($this->data[0]->__ss);
            case "__fs": return new struct___darwin_x86_float_state64($this->data[0]->__fs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__es":
                (new struct___darwin_x86_exception_state64($this->data[0]->__es))->set($value);
                break;
            case "__ss":
                (new struct___darwin_x86_thread_full_state64($this->data[0]->__ss))->set($value);
                break;
            case "__fs":
                (new struct___darwin_x86_float_state64($this->data[0]->__fs))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_mcontext64_full_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext64_full*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext64_full_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext64_full_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext64_full_ptr_ptr_ptr { return new struct___darwin_mcontext64_full_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext64_full_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext64_full_ptr { return new struct___darwin_mcontext64_full_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext64_full_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext64_full_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext64_full_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext64_full_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext64_full**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext64_full_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext64_full_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext64_full_ptr_ptr_ptr_ptr { return new struct___darwin_mcontext64_full_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext64_full_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext64_full_ptr_ptr { return new struct___darwin_mcontext64_full_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext64_full_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext64_full_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext64_full_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext64_full_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext64_full***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext64_full_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext64_full_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext64_full_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_mcontext64_full_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext64_full_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext64_full_ptr_ptr_ptr { return new struct___darwin_mcontext64_full_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext64_full_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext64_full_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext64_full_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext64_full_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext64_full****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct___darwin_x86_exception_state64 $__es
 * @property struct___darwin_x86_thread_state64 $__ss
 * @property struct___darwin_x86_avx_state64 $__fs
 */
class struct___darwin_mcontext_avx64 implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx64 $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx64_ptr { return new struct___darwin_mcontext_avx64_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__es": return new struct___darwin_x86_exception_state64($this->data->__es);
            case "__ss": return new struct___darwin_x86_thread_state64($this->data->__ss);
            case "__fs": return new struct___darwin_x86_avx_state64($this->data->__fs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__es":
                (new struct___darwin_x86_exception_state64($this->data->__es))->set($value);
                break;
            case "__ss":
                (new struct___darwin_x86_thread_state64($this->data->__ss))->set($value);
                break;
            case "__fs":
                (new struct___darwin_x86_avx_state64($this->data->__fs))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_mcontext_avx64 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx64'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct___darwin_x86_exception_state64 $__es
 * @property struct___darwin_x86_thread_state64 $__ss
 * @property struct___darwin_x86_avx_state64 $__fs
 */
class struct___darwin_mcontext_avx64_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx64_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx64_ptr_ptr { return new struct___darwin_mcontext_avx64_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx64 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx64 { return new struct___darwin_mcontext_avx64($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx64[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx64($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__es": return new struct___darwin_x86_exception_state64($this->data[0]->__es);
            case "__ss": return new struct___darwin_x86_thread_state64($this->data[0]->__ss);
            case "__fs": return new struct___darwin_x86_avx_state64($this->data[0]->__fs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__es":
                (new struct___darwin_x86_exception_state64($this->data[0]->__es))->set($value);
                break;
            case "__ss":
                (new struct___darwin_x86_thread_state64($this->data[0]->__ss))->set($value);
                break;
            case "__fs":
                (new struct___darwin_x86_avx_state64($this->data[0]->__fs))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_mcontext_avx64_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx64*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext_avx64_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx64_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx64_ptr_ptr_ptr { return new struct___darwin_mcontext_avx64_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx64_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx64_ptr { return new struct___darwin_mcontext_avx64_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx64_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext_avx64_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx64_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext_avx64_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx64**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext_avx64_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx64_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx64_ptr_ptr_ptr_ptr { return new struct___darwin_mcontext_avx64_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx64_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx64_ptr_ptr { return new struct___darwin_mcontext_avx64_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx64_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext_avx64_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx64_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext_avx64_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx64***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext_avx64_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx64_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx64_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_mcontext_avx64_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx64_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx64_ptr_ptr_ptr { return new struct___darwin_mcontext_avx64_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx64_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext_avx64_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx64_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext_avx64_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx64****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct___darwin_x86_exception_state64 $__es
 * @property struct___darwin_x86_thread_full_state64 $__ss
 * @property struct___darwin_x86_avx_state64 $__fs
 */
class struct___darwin_mcontext_avx64_full implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx64_full $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx64_full_ptr { return new struct___darwin_mcontext_avx64_full_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__es": return new struct___darwin_x86_exception_state64($this->data->__es);
            case "__ss": return new struct___darwin_x86_thread_full_state64($this->data->__ss);
            case "__fs": return new struct___darwin_x86_avx_state64($this->data->__fs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__es":
                (new struct___darwin_x86_exception_state64($this->data->__es))->set($value);
                break;
            case "__ss":
                (new struct___darwin_x86_thread_full_state64($this->data->__ss))->set($value);
                break;
            case "__fs":
                (new struct___darwin_x86_avx_state64($this->data->__fs))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_mcontext_avx64_full $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx64_full'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct___darwin_x86_exception_state64 $__es
 * @property struct___darwin_x86_thread_full_state64 $__ss
 * @property struct___darwin_x86_avx_state64 $__fs
 */
class struct___darwin_mcontext_avx64_full_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx64_full_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx64_full_ptr_ptr { return new struct___darwin_mcontext_avx64_full_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx64_full { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx64_full { return new struct___darwin_mcontext_avx64_full($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx64_full[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx64_full($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__es": return new struct___darwin_x86_exception_state64($this->data[0]->__es);
            case "__ss": return new struct___darwin_x86_thread_full_state64($this->data[0]->__ss);
            case "__fs": return new struct___darwin_x86_avx_state64($this->data[0]->__fs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__es":
                (new struct___darwin_x86_exception_state64($this->data[0]->__es))->set($value);
                break;
            case "__ss":
                (new struct___darwin_x86_thread_full_state64($this->data[0]->__ss))->set($value);
                break;
            case "__fs":
                (new struct___darwin_x86_avx_state64($this->data[0]->__fs))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_mcontext_avx64_full_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx64_full*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext_avx64_full_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx64_full_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx64_full_ptr_ptr_ptr { return new struct___darwin_mcontext_avx64_full_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx64_full_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx64_full_ptr { return new struct___darwin_mcontext_avx64_full_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx64_full_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext_avx64_full_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx64_full_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext_avx64_full_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx64_full**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext_avx64_full_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx64_full_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx64_full_ptr_ptr_ptr_ptr { return new struct___darwin_mcontext_avx64_full_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx64_full_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx64_full_ptr_ptr { return new struct___darwin_mcontext_avx64_full_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx64_full_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext_avx64_full_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx64_full_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext_avx64_full_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx64_full***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext_avx64_full_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx64_full_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx64_full_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_mcontext_avx64_full_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx64_full_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx64_full_ptr_ptr_ptr { return new struct___darwin_mcontext_avx64_full_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx64_full_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext_avx64_full_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx64_full_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext_avx64_full_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx64_full****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct___darwin_x86_exception_state64 $__es
 * @property struct___darwin_x86_thread_state64 $__ss
 * @property struct___darwin_x86_avx512_state64 $__fs
 */
class struct___darwin_mcontext_avx512_64 implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx512_64 $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx512_64_ptr { return new struct___darwin_mcontext_avx512_64_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__es": return new struct___darwin_x86_exception_state64($this->data->__es);
            case "__ss": return new struct___darwin_x86_thread_state64($this->data->__ss);
            case "__fs": return new struct___darwin_x86_avx512_state64($this->data->__fs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__es":
                (new struct___darwin_x86_exception_state64($this->data->__es))->set($value);
                break;
            case "__ss":
                (new struct___darwin_x86_thread_state64($this->data->__ss))->set($value);
                break;
            case "__fs":
                (new struct___darwin_x86_avx512_state64($this->data->__fs))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_mcontext_avx512_64 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx512_64'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct___darwin_x86_exception_state64 $__es
 * @property struct___darwin_x86_thread_state64 $__ss
 * @property struct___darwin_x86_avx512_state64 $__fs
 */
class struct___darwin_mcontext_avx512_64_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx512_64_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx512_64_ptr_ptr { return new struct___darwin_mcontext_avx512_64_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx512_64 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx512_64 { return new struct___darwin_mcontext_avx512_64($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx512_64[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx512_64($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__es": return new struct___darwin_x86_exception_state64($this->data[0]->__es);
            case "__ss": return new struct___darwin_x86_thread_state64($this->data[0]->__ss);
            case "__fs": return new struct___darwin_x86_avx512_state64($this->data[0]->__fs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__es":
                (new struct___darwin_x86_exception_state64($this->data[0]->__es))->set($value);
                break;
            case "__ss":
                (new struct___darwin_x86_thread_state64($this->data[0]->__ss))->set($value);
                break;
            case "__fs":
                (new struct___darwin_x86_avx512_state64($this->data[0]->__fs))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_mcontext_avx512_64_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx512_64*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext_avx512_64_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx512_64_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx512_64_ptr_ptr_ptr { return new struct___darwin_mcontext_avx512_64_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx512_64_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx512_64_ptr { return new struct___darwin_mcontext_avx512_64_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx512_64_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext_avx512_64_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx512_64_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext_avx512_64_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx512_64**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext_avx512_64_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx512_64_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx512_64_ptr_ptr_ptr_ptr { return new struct___darwin_mcontext_avx512_64_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx512_64_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx512_64_ptr_ptr { return new struct___darwin_mcontext_avx512_64_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx512_64_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext_avx512_64_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx512_64_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext_avx512_64_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx512_64***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext_avx512_64_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx512_64_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx512_64_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_mcontext_avx512_64_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx512_64_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx512_64_ptr_ptr_ptr { return new struct___darwin_mcontext_avx512_64_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx512_64_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext_avx512_64_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx512_64_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext_avx512_64_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx512_64****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct___darwin_x86_exception_state64 $__es
 * @property struct___darwin_x86_thread_full_state64 $__ss
 * @property struct___darwin_x86_avx512_state64 $__fs
 */
class struct___darwin_mcontext_avx512_64_full implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx512_64_full $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx512_64_full_ptr { return new struct___darwin_mcontext_avx512_64_full_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__es": return new struct___darwin_x86_exception_state64($this->data->__es);
            case "__ss": return new struct___darwin_x86_thread_full_state64($this->data->__ss);
            case "__fs": return new struct___darwin_x86_avx512_state64($this->data->__fs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__es":
                (new struct___darwin_x86_exception_state64($this->data->__es))->set($value);
                break;
            case "__ss":
                (new struct___darwin_x86_thread_full_state64($this->data->__ss))->set($value);
                break;
            case "__fs":
                (new struct___darwin_x86_avx512_state64($this->data->__fs))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_mcontext_avx512_64_full $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx512_64_full'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct___darwin_x86_exception_state64 $__es
 * @property struct___darwin_x86_thread_full_state64 $__ss
 * @property struct___darwin_x86_avx512_state64 $__fs
 */
class struct___darwin_mcontext_avx512_64_full_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx512_64_full_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx512_64_full_ptr_ptr { return new struct___darwin_mcontext_avx512_64_full_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx512_64_full { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx512_64_full { return new struct___darwin_mcontext_avx512_64_full($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx512_64_full[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx512_64_full($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__es": return new struct___darwin_x86_exception_state64($this->data[0]->__es);
            case "__ss": return new struct___darwin_x86_thread_full_state64($this->data[0]->__ss);
            case "__fs": return new struct___darwin_x86_avx512_state64($this->data[0]->__fs);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__es":
                (new struct___darwin_x86_exception_state64($this->data[0]->__es))->set($value);
                break;
            case "__ss":
                (new struct___darwin_x86_thread_full_state64($this->data[0]->__ss))->set($value);
                break;
            case "__fs":
                (new struct___darwin_x86_avx512_state64($this->data[0]->__fs))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_mcontext_avx512_64_full_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx512_64_full*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext_avx512_64_full_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx512_64_full_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx512_64_full_ptr_ptr_ptr { return new struct___darwin_mcontext_avx512_64_full_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx512_64_full_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx512_64_full_ptr { return new struct___darwin_mcontext_avx512_64_full_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx512_64_full_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext_avx512_64_full_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx512_64_full_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext_avx512_64_full_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx512_64_full**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext_avx512_64_full_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx512_64_full_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx512_64_full_ptr_ptr_ptr_ptr { return new struct___darwin_mcontext_avx512_64_full_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx512_64_full_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx512_64_full_ptr_ptr { return new struct___darwin_mcontext_avx512_64_full_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx512_64_full_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext_avx512_64_full_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx512_64_full_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext_avx512_64_full_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx512_64_full***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_mcontext_avx512_64_full_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_mcontext_avx512_64_full_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_mcontext_avx512_64_full_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_mcontext_avx512_64_full_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_mcontext_avx512_64_full_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_mcontext_avx512_64_full_ptr_ptr_ptr { return new struct___darwin_mcontext_avx512_64_full_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_mcontext_avx512_64_full_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_mcontext_avx512_64_full_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_mcontext_avx512_64_full_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_mcontext_avx512_64_full_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_mcontext_avx512_64_full****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property void_ptr $ss_sp
 * @property int $ss_size
 * @property int $ss_flags
 */
class struct___darwin_sigaltstack implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_sigaltstack $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_sigaltstack_ptr { return new struct___darwin_sigaltstack_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "ss_sp": return new void_ptr($this->data->ss_sp);
            case "ss_size": return $this->data->ss_size;
            case "ss_flags": return $this->data->ss_flags;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ss_sp":
                (new void_ptr($this->data->ss_sp))->set($value);
                break;
            case "ss_size":
                $this->data->ss_size = $value;
                break;
            case "ss_flags":
                $this->data->ss_flags = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_sigaltstack $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_sigaltstack'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property void_ptr $ss_sp
 * @property int $ss_size
 * @property int $ss_flags
 */
class struct___darwin_sigaltstack_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_sigaltstack_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_sigaltstack_ptr_ptr { return new struct___darwin_sigaltstack_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_sigaltstack { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_sigaltstack { return new struct___darwin_sigaltstack($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_sigaltstack[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_sigaltstack($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "ss_sp": return new void_ptr($this->data[0]->ss_sp);
            case "ss_size": return $this->data[0]->ss_size;
            case "ss_flags": return $this->data[0]->ss_flags;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ss_sp":
                (new void_ptr($this->data[0]->ss_sp))->set($value);
                break;
            case "ss_size":
                $this->data[0]->ss_size = $value;
                break;
            case "ss_flags":
                $this->data[0]->ss_flags = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_sigaltstack_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_sigaltstack*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_sigaltstack_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_sigaltstack_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_sigaltstack_ptr_ptr_ptr { return new struct___darwin_sigaltstack_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_sigaltstack_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_sigaltstack_ptr { return new struct___darwin_sigaltstack_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_sigaltstack_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_sigaltstack_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_sigaltstack_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_sigaltstack_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_sigaltstack**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_sigaltstack_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_sigaltstack_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_sigaltstack_ptr_ptr_ptr_ptr { return new struct___darwin_sigaltstack_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_sigaltstack_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_sigaltstack_ptr_ptr { return new struct___darwin_sigaltstack_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_sigaltstack_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_sigaltstack_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_sigaltstack_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_sigaltstack_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_sigaltstack***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_sigaltstack_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_sigaltstack_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_sigaltstack_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_sigaltstack_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_sigaltstack_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_sigaltstack_ptr_ptr_ptr { return new struct___darwin_sigaltstack_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_sigaltstack_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_sigaltstack_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_sigaltstack_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_sigaltstack_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_sigaltstack****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $uc_onstack
 * @property int $uc_sigmask
 * @property struct___darwin_sigaltstack $uc_stack
 * @property struct___darwin_ucontext_ptr $uc_link
 * @property int $uc_mcsize
 * @property struct___darwin_mcontext64_ptr $uc_mcontext
 */
class struct___darwin_ucontext implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_ucontext $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_ucontext_ptr { return new struct___darwin_ucontext_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "uc_onstack": return $this->data->uc_onstack;
            case "uc_sigmask": return $this->data->uc_sigmask;
            case "uc_stack": return new struct___darwin_sigaltstack($this->data->uc_stack);
            case "uc_link": return new struct___darwin_ucontext_ptr($this->data->uc_link);
            case "uc_mcsize": return $this->data->uc_mcsize;
            case "uc_mcontext": return new struct___darwin_mcontext64_ptr($this->data->uc_mcontext);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "uc_onstack":
                $this->data->uc_onstack = $value;
                break;
            case "uc_sigmask":
                $this->data->uc_sigmask = $value;
                break;
            case "uc_stack":
                (new struct___darwin_sigaltstack($this->data->uc_stack))->set($value);
                break;
            case "uc_link":
                (new struct___darwin_ucontext_ptr($this->data->uc_link))->set($value);
                break;
            case "uc_mcsize":
                $this->data->uc_mcsize = $value;
                break;
            case "uc_mcontext":
                (new struct___darwin_mcontext64_ptr($this->data->uc_mcontext))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___darwin_ucontext $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_ucontext'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $uc_onstack
 * @property int $uc_sigmask
 * @property struct___darwin_sigaltstack $uc_stack
 * @property struct___darwin_ucontext_ptr $uc_link
 * @property int $uc_mcsize
 * @property struct___darwin_mcontext64_ptr $uc_mcontext
 */
class struct___darwin_ucontext_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_ucontext_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_ucontext_ptr_ptr { return new struct___darwin_ucontext_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_ucontext { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_ucontext { return new struct___darwin_ucontext($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_ucontext[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_ucontext($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "uc_onstack": return $this->data[0]->uc_onstack;
            case "uc_sigmask": return $this->data[0]->uc_sigmask;
            case "uc_stack": return new struct___darwin_sigaltstack($this->data[0]->uc_stack);
            case "uc_link": return new struct___darwin_ucontext_ptr($this->data[0]->uc_link);
            case "uc_mcsize": return $this->data[0]->uc_mcsize;
            case "uc_mcontext": return new struct___darwin_mcontext64_ptr($this->data[0]->uc_mcontext);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "uc_onstack":
                $this->data[0]->uc_onstack = $value;
                break;
            case "uc_sigmask":
                $this->data[0]->uc_sigmask = $value;
                break;
            case "uc_stack":
                (new struct___darwin_sigaltstack($this->data[0]->uc_stack))->set($value);
                break;
            case "uc_link":
                (new struct___darwin_ucontext_ptr($this->data[0]->uc_link))->set($value);
                break;
            case "uc_mcsize":
                $this->data[0]->uc_mcsize = $value;
                break;
            case "uc_mcontext":
                (new struct___darwin_mcontext64_ptr($this->data[0]->uc_mcontext))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___darwin_ucontext_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_ucontext*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_ucontext_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_ucontext_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_ucontext_ptr_ptr_ptr { return new struct___darwin_ucontext_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_ucontext_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_ucontext_ptr { return new struct___darwin_ucontext_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_ucontext_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_ucontext_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_ucontext_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_ucontext_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_ucontext**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_ucontext_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_ucontext_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_ucontext_ptr_ptr_ptr_ptr { return new struct___darwin_ucontext_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_ucontext_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_ucontext_ptr_ptr { return new struct___darwin_ucontext_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_ucontext_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_ucontext_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_ucontext_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_ucontext_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_ucontext***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___darwin_ucontext_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___darwin_ucontext_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___darwin_ucontext_ptr_ptr_ptr_ptr_ptr { return new struct___darwin_ucontext_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___darwin_ucontext_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___darwin_ucontext_ptr_ptr_ptr { return new struct___darwin_ucontext_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___darwin_ucontext_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___darwin_ucontext_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___darwin_ucontext_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___darwin_ucontext_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __darwin_ucontext****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $sival_int
 * @property void_ptr $sival_ptr
 */
class union_sigval implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(union_sigval $other): bool { return $this->data == $other->data; }
    public function addr(): union_sigval_ptr { return new union_sigval_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "sival_int": return $this->data->sival_int;
            case "sival_ptr": return new void_ptr($this->data->sival_ptr);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "sival_int":
                $this->data->sival_int = $value;
                break;
            case "sival_ptr":
                (new void_ptr($this->data->sival_ptr))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(union_sigval $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'union sigval'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $sival_int
 * @property void_ptr $sival_ptr
 */
class union_sigval_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(union_sigval_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): union_sigval_ptr_ptr { return new union_sigval_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): union_sigval { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): union_sigval { return new union_sigval($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return union_sigval[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new union_sigval($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "sival_int": return $this->data[0]->sival_int;
            case "sival_ptr": return new void_ptr($this->data[0]->sival_ptr);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "sival_int":
                $this->data[0]->sival_int = $value;
                break;
            case "sival_ptr":
                (new void_ptr($this->data[0]->sival_ptr))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | union_sigval_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'union sigval*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class union_sigval_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(union_sigval_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): union_sigval_ptr_ptr_ptr { return new union_sigval_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): union_sigval_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): union_sigval_ptr { return new union_sigval_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return union_sigval_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new union_sigval_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new union_sigval_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | union_sigval_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'union sigval**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class union_sigval_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(union_sigval_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): union_sigval_ptr_ptr_ptr_ptr { return new union_sigval_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): union_sigval_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): union_sigval_ptr_ptr { return new union_sigval_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return union_sigval_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new union_sigval_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new union_sigval_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | union_sigval_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'union sigval***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class union_sigval_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(union_sigval_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): union_sigval_ptr_ptr_ptr_ptr_ptr { return new union_sigval_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): union_sigval_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): union_sigval_ptr_ptr_ptr { return new union_sigval_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return union_sigval_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new union_sigval_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new union_sigval_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | union_sigval_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'union sigval****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $sigev_notify
 * @property int $sigev_signo
 * @property union_sigval $sigev_value
 * @property function_type_ptr $sigev_notify_function
 * @property struct__opaque_pthread_attr_t_ptr $sigev_notify_attributes
 */
class struct_sigevent implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sigevent $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sigevent_ptr { return new struct_sigevent_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "sigev_notify": return $this->data->sigev_notify;
            case "sigev_signo": return $this->data->sigev_signo;
            case "sigev_value": return new union_sigval($this->data->sigev_value);
            case "sigev_notify_function": return new function_type_ptr($this->data->sigev_notify_function, [NULL, 'union_sigval']);
            case "sigev_notify_attributes": return new struct__opaque_pthread_attr_t_ptr($this->data->sigev_notify_attributes);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "sigev_notify":
                $this->data->sigev_notify = $value;
                break;
            case "sigev_signo":
                $this->data->sigev_signo = $value;
                break;
            case "sigev_value":
                (new union_sigval($this->data->sigev_value))->set($value);
                break;
            case "sigev_notify_function":
                (new function_type_ptr($this->data->sigev_notify_function, [NULL, 'union_sigval']))->set($value);
                break;
            case "sigev_notify_attributes":
                (new struct__opaque_pthread_attr_t_ptr($this->data->sigev_notify_attributes))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_sigevent $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sigevent'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $sigev_notify
 * @property int $sigev_signo
 * @property union_sigval $sigev_value
 * @property function_type_ptr $sigev_notify_function
 * @property struct__opaque_pthread_attr_t_ptr $sigev_notify_attributes
 */
class struct_sigevent_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sigevent_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sigevent_ptr_ptr { return new struct_sigevent_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sigevent { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_sigevent { return new struct_sigevent($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_sigevent[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sigevent($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "sigev_notify": return $this->data[0]->sigev_notify;
            case "sigev_signo": return $this->data[0]->sigev_signo;
            case "sigev_value": return new union_sigval($this->data[0]->sigev_value);
            case "sigev_notify_function": return new function_type_ptr($this->data[0]->sigev_notify_function, [NULL, 'union_sigval']);
            case "sigev_notify_attributes": return new struct__opaque_pthread_attr_t_ptr($this->data[0]->sigev_notify_attributes);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "sigev_notify":
                $this->data[0]->sigev_notify = $value;
                break;
            case "sigev_signo":
                $this->data[0]->sigev_signo = $value;
                break;
            case "sigev_value":
                (new union_sigval($this->data[0]->sigev_value))->set($value);
                break;
            case "sigev_notify_function":
                (new function_type_ptr($this->data[0]->sigev_notify_function, [NULL, 'union_sigval']))->set($value);
                break;
            case "sigev_notify_attributes":
                (new struct__opaque_pthread_attr_t_ptr($this->data[0]->sigev_notify_attributes))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_sigevent_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sigevent*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sigevent_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sigevent_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sigevent_ptr_ptr_ptr { return new struct_sigevent_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sigevent_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_sigevent_ptr { return new struct_sigevent_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_sigevent_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sigevent_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sigevent_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sigevent_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sigevent**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sigevent_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sigevent_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sigevent_ptr_ptr_ptr_ptr { return new struct_sigevent_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sigevent_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_sigevent_ptr_ptr { return new struct_sigevent_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_sigevent_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sigevent_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sigevent_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sigevent_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sigevent***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sigevent_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sigevent_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sigevent_ptr_ptr_ptr_ptr_ptr { return new struct_sigevent_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sigevent_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_sigevent_ptr_ptr_ptr { return new struct_sigevent_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_sigevent_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sigevent_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sigevent_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sigevent_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sigevent****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $si_signo
 * @property int $si_errno
 * @property int $si_code
 * @property int $si_pid
 * @property int $si_uid
 * @property int $si_status
 * @property void_ptr $si_addr
 * @property union_sigval $si_value
 * @property int $si_band
 * @property unsigned_long_ptr $__pad
 */
class struct___siginfo implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___siginfo $other): bool { return $this->data == $other->data; }
    public function addr(): struct___siginfo_ptr { return new struct___siginfo_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "si_signo": return $this->data->si_signo;
            case "si_errno": return $this->data->si_errno;
            case "si_code": return $this->data->si_code;
            case "si_pid": return $this->data->si_pid;
            case "si_uid": return $this->data->si_uid;
            case "si_status": return $this->data->si_status;
            case "si_addr": return new void_ptr($this->data->si_addr);
            case "si_value": return new union_sigval($this->data->si_value);
            case "si_band": return $this->data->si_band;
            case "__pad": return new unsigned_long_ptr($this->data->__pad);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "si_signo":
                $this->data->si_signo = $value;
                break;
            case "si_errno":
                $this->data->si_errno = $value;
                break;
            case "si_code":
                $this->data->si_code = $value;
                break;
            case "si_pid":
                $this->data->si_pid = $value;
                break;
            case "si_uid":
                $this->data->si_uid = $value;
                break;
            case "si_status":
                $this->data->si_status = $value;
                break;
            case "si_addr":
                (new void_ptr($this->data->si_addr))->set($value);
                break;
            case "si_value":
                (new union_sigval($this->data->si_value))->set($value);
                break;
            case "si_band":
                $this->data->si_band = $value;
                break;
            case "__pad":
                (new unsigned_long_ptr($this->data->__pad))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___siginfo $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __siginfo'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $si_signo
 * @property int $si_errno
 * @property int $si_code
 * @property int $si_pid
 * @property int $si_uid
 * @property int $si_status
 * @property void_ptr $si_addr
 * @property union_sigval $si_value
 * @property int $si_band
 * @property unsigned_long_ptr $__pad
 */
class struct___siginfo_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___siginfo_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___siginfo_ptr_ptr { return new struct___siginfo_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___siginfo { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___siginfo { return new struct___siginfo($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___siginfo[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___siginfo($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "si_signo": return $this->data[0]->si_signo;
            case "si_errno": return $this->data[0]->si_errno;
            case "si_code": return $this->data[0]->si_code;
            case "si_pid": return $this->data[0]->si_pid;
            case "si_uid": return $this->data[0]->si_uid;
            case "si_status": return $this->data[0]->si_status;
            case "si_addr": return new void_ptr($this->data[0]->si_addr);
            case "si_value": return new union_sigval($this->data[0]->si_value);
            case "si_band": return $this->data[0]->si_band;
            case "__pad": return new unsigned_long_ptr($this->data[0]->__pad);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "si_signo":
                $this->data[0]->si_signo = $value;
                break;
            case "si_errno":
                $this->data[0]->si_errno = $value;
                break;
            case "si_code":
                $this->data[0]->si_code = $value;
                break;
            case "si_pid":
                $this->data[0]->si_pid = $value;
                break;
            case "si_uid":
                $this->data[0]->si_uid = $value;
                break;
            case "si_status":
                $this->data[0]->si_status = $value;
                break;
            case "si_addr":
                (new void_ptr($this->data[0]->si_addr))->set($value);
                break;
            case "si_value":
                (new union_sigval($this->data[0]->si_value))->set($value);
                break;
            case "si_band":
                $this->data[0]->si_band = $value;
                break;
            case "__pad":
                (new unsigned_long_ptr($this->data[0]->__pad))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___siginfo_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __siginfo*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___siginfo_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___siginfo_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___siginfo_ptr_ptr_ptr { return new struct___siginfo_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___siginfo_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___siginfo_ptr { return new struct___siginfo_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___siginfo_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___siginfo_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___siginfo_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___siginfo_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __siginfo**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___siginfo_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___siginfo_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___siginfo_ptr_ptr_ptr_ptr { return new struct___siginfo_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___siginfo_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___siginfo_ptr_ptr { return new struct___siginfo_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___siginfo_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___siginfo_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___siginfo_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___siginfo_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __siginfo***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___siginfo_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___siginfo_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___siginfo_ptr_ptr_ptr_ptr_ptr { return new struct___siginfo_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___siginfo_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___siginfo_ptr_ptr_ptr { return new struct___siginfo_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___siginfo_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___siginfo_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___siginfo_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___siginfo_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __siginfo****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property function_type_ptr $__sa_handler
 * @property function_type_ptr $__sa_sigaction
 */
class union___sigaction_u implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(union___sigaction_u $other): bool { return $this->data == $other->data; }
    public function addr(): union___sigaction_u_ptr { return new union___sigaction_u_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__sa_handler": return new function_type_ptr($this->data->__sa_handler, [NULL, 'int']);
            case "__sa_sigaction": return new function_type_ptr($this->data->__sa_sigaction, [NULL, 'int', 'struct___siginfo_ptr', 'void_ptr']);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sa_handler":
                (new function_type_ptr($this->data->__sa_handler, [NULL, 'int']))->set($value);
                break;
            case "__sa_sigaction":
                (new function_type_ptr($this->data->__sa_sigaction, [NULL, 'int', 'struct___siginfo_ptr', 'void_ptr']))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(union___sigaction_u $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'union __sigaction_u'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property function_type_ptr $__sa_handler
 * @property function_type_ptr $__sa_sigaction
 */
class union___sigaction_u_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(union___sigaction_u_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): union___sigaction_u_ptr_ptr { return new union___sigaction_u_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): union___sigaction_u { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): union___sigaction_u { return new union___sigaction_u($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return union___sigaction_u[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new union___sigaction_u($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__sa_handler": return new function_type_ptr($this->data[0]->__sa_handler, [NULL, 'int']);
            case "__sa_sigaction": return new function_type_ptr($this->data[0]->__sa_sigaction, [NULL, 'int', 'struct___siginfo_ptr', 'void_ptr']);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sa_handler":
                (new function_type_ptr($this->data[0]->__sa_handler, [NULL, 'int']))->set($value);
                break;
            case "__sa_sigaction":
                (new function_type_ptr($this->data[0]->__sa_sigaction, [NULL, 'int', 'struct___siginfo_ptr', 'void_ptr']))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | union___sigaction_u_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'union __sigaction_u*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class union___sigaction_u_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(union___sigaction_u_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): union___sigaction_u_ptr_ptr_ptr { return new union___sigaction_u_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): union___sigaction_u_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): union___sigaction_u_ptr { return new union___sigaction_u_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return union___sigaction_u_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new union___sigaction_u_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new union___sigaction_u_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | union___sigaction_u_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'union __sigaction_u**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class union___sigaction_u_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(union___sigaction_u_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): union___sigaction_u_ptr_ptr_ptr_ptr { return new union___sigaction_u_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): union___sigaction_u_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): union___sigaction_u_ptr_ptr { return new union___sigaction_u_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return union___sigaction_u_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new union___sigaction_u_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new union___sigaction_u_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | union___sigaction_u_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'union __sigaction_u***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class union___sigaction_u_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(union___sigaction_u_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): union___sigaction_u_ptr_ptr_ptr_ptr_ptr { return new union___sigaction_u_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): union___sigaction_u_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): union___sigaction_u_ptr_ptr_ptr { return new union___sigaction_u_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return union___sigaction_u_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new union___sigaction_u_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new union___sigaction_u_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | union___sigaction_u_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'union __sigaction_u****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property union___sigaction_u $__sigaction_u
 * @property function_type_ptr $sa_tramp
 * @property int $sa_mask
 * @property int $sa_flags
 */
class struct___sigaction implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___sigaction $other): bool { return $this->data == $other->data; }
    public function addr(): struct___sigaction_ptr { return new struct___sigaction_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__sigaction_u": return new union___sigaction_u($this->data->__sigaction_u);
            case "sa_tramp": return new function_type_ptr($this->data->sa_tramp, [NULL, 'void_ptr', 'int', 'int', 'struct___siginfo_ptr', 'void_ptr']);
            case "sa_mask": return $this->data->sa_mask;
            case "sa_flags": return $this->data->sa_flags;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sigaction_u":
                (new union___sigaction_u($this->data->__sigaction_u))->set($value);
                break;
            case "sa_tramp":
                (new function_type_ptr($this->data->sa_tramp, [NULL, 'void_ptr', 'int', 'int', 'struct___siginfo_ptr', 'void_ptr']))->set($value);
                break;
            case "sa_mask":
                $this->data->sa_mask = $value;
                break;
            case "sa_flags":
                $this->data->sa_flags = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct___sigaction $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __sigaction'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property union___sigaction_u $__sigaction_u
 * @property function_type_ptr $sa_tramp
 * @property int $sa_mask
 * @property int $sa_flags
 */
class struct___sigaction_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___sigaction_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___sigaction_ptr_ptr { return new struct___sigaction_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___sigaction { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___sigaction { return new struct___sigaction($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___sigaction[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___sigaction($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__sigaction_u": return new union___sigaction_u($this->data[0]->__sigaction_u);
            case "sa_tramp": return new function_type_ptr($this->data[0]->sa_tramp, [NULL, 'void_ptr', 'int', 'int', 'struct___siginfo_ptr', 'void_ptr']);
            case "sa_mask": return $this->data[0]->sa_mask;
            case "sa_flags": return $this->data[0]->sa_flags;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sigaction_u":
                (new union___sigaction_u($this->data[0]->__sigaction_u))->set($value);
                break;
            case "sa_tramp":
                (new function_type_ptr($this->data[0]->sa_tramp, [NULL, 'void_ptr', 'int', 'int', 'struct___siginfo_ptr', 'void_ptr']))->set($value);
                break;
            case "sa_mask":
                $this->data[0]->sa_mask = $value;
                break;
            case "sa_flags":
                $this->data[0]->sa_flags = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct___sigaction_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __sigaction*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___sigaction_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___sigaction_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___sigaction_ptr_ptr_ptr { return new struct___sigaction_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___sigaction_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___sigaction_ptr { return new struct___sigaction_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___sigaction_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___sigaction_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___sigaction_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___sigaction_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __sigaction**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___sigaction_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___sigaction_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___sigaction_ptr_ptr_ptr_ptr { return new struct___sigaction_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___sigaction_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___sigaction_ptr_ptr { return new struct___sigaction_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___sigaction_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___sigaction_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___sigaction_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___sigaction_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __sigaction***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct___sigaction_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct___sigaction_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct___sigaction_ptr_ptr_ptr_ptr_ptr { return new struct___sigaction_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct___sigaction_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct___sigaction_ptr_ptr_ptr { return new struct___sigaction_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct___sigaction_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct___sigaction_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct___sigaction_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct___sigaction_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct __sigaction****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property union___sigaction_u $__sigaction_u
 * @property int $sa_mask
 * @property int $sa_flags
 */
class struct_sigaction implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sigaction $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sigaction_ptr { return new struct_sigaction_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "__sigaction_u": return new union___sigaction_u($this->data->__sigaction_u);
            case "sa_mask": return $this->data->sa_mask;
            case "sa_flags": return $this->data->sa_flags;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sigaction_u":
                (new union___sigaction_u($this->data->__sigaction_u))->set($value);
                break;
            case "sa_mask":
                $this->data->sa_mask = $value;
                break;
            case "sa_flags":
                $this->data->sa_flags = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_sigaction $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sigaction'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property union___sigaction_u $__sigaction_u
 * @property int $sa_mask
 * @property int $sa_flags
 */
class struct_sigaction_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sigaction_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sigaction_ptr_ptr { return new struct_sigaction_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sigaction { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_sigaction { return new struct_sigaction($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_sigaction[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sigaction($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "__sigaction_u": return new union___sigaction_u($this->data[0]->__sigaction_u);
            case "sa_mask": return $this->data[0]->sa_mask;
            case "sa_flags": return $this->data[0]->sa_flags;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "__sigaction_u":
                (new union___sigaction_u($this->data[0]->__sigaction_u))->set($value);
                break;
            case "sa_mask":
                $this->data[0]->sa_mask = $value;
                break;
            case "sa_flags":
                $this->data[0]->sa_flags = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_sigaction_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sigaction*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sigaction_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sigaction_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sigaction_ptr_ptr_ptr { return new struct_sigaction_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sigaction_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_sigaction_ptr { return new struct_sigaction_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_sigaction_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sigaction_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sigaction_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sigaction_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sigaction**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sigaction_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sigaction_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sigaction_ptr_ptr_ptr_ptr { return new struct_sigaction_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sigaction_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_sigaction_ptr_ptr { return new struct_sigaction_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_sigaction_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sigaction_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sigaction_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sigaction_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sigaction***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sigaction_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sigaction_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sigaction_ptr_ptr_ptr_ptr_ptr { return new struct_sigaction_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sigaction_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_sigaction_ptr_ptr_ptr { return new struct_sigaction_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_sigaction_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sigaction_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sigaction_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sigaction_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sigaction****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property function_type_ptr $sv_handler
 * @property int $sv_mask
 * @property int $sv_flags
 */
class struct_sigvec implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sigvec $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sigvec_ptr { return new struct_sigvec_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "sv_handler": return new function_type_ptr($this->data->sv_handler, [NULL, 'int']);
            case "sv_mask": return $this->data->sv_mask;
            case "sv_flags": return $this->data->sv_flags;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "sv_handler":
                (new function_type_ptr($this->data->sv_handler, [NULL, 'int']))->set($value);
                break;
            case "sv_mask":
                $this->data->sv_mask = $value;
                break;
            case "sv_flags":
                $this->data->sv_flags = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_sigvec $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sigvec'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property function_type_ptr $sv_handler
 * @property int $sv_mask
 * @property int $sv_flags
 */
class struct_sigvec_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sigvec_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sigvec_ptr_ptr { return new struct_sigvec_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sigvec { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_sigvec { return new struct_sigvec($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_sigvec[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sigvec($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "sv_handler": return new function_type_ptr($this->data[0]->sv_handler, [NULL, 'int']);
            case "sv_mask": return $this->data[0]->sv_mask;
            case "sv_flags": return $this->data[0]->sv_flags;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "sv_handler":
                (new function_type_ptr($this->data[0]->sv_handler, [NULL, 'int']))->set($value);
                break;
            case "sv_mask":
                $this->data[0]->sv_mask = $value;
                break;
            case "sv_flags":
                $this->data[0]->sv_flags = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_sigvec_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sigvec*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sigvec_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sigvec_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sigvec_ptr_ptr_ptr { return new struct_sigvec_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sigvec_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_sigvec_ptr { return new struct_sigvec_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_sigvec_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sigvec_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sigvec_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sigvec_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sigvec**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sigvec_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sigvec_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sigvec_ptr_ptr_ptr_ptr { return new struct_sigvec_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sigvec_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_sigvec_ptr_ptr { return new struct_sigvec_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_sigvec_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sigvec_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sigvec_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sigvec_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sigvec***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sigvec_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sigvec_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sigvec_ptr_ptr_ptr_ptr_ptr { return new struct_sigvec_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sigvec_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_sigvec_ptr_ptr_ptr { return new struct_sigvec_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_sigvec_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sigvec_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sigvec_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sigvec_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sigvec****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property string_ $ss_sp
 * @property int $ss_onstack
 */
class struct_sigstack implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sigstack $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sigstack_ptr { return new struct_sigstack_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "ss_sp": return new string_($this->data->ss_sp);
            case "ss_onstack": return $this->data->ss_onstack;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ss_sp":
                (new string_($this->data->ss_sp))->set($value);
                break;
            case "ss_onstack":
                $this->data->ss_onstack = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_sigstack $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sigstack'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property string_ $ss_sp
 * @property int $ss_onstack
 */
class struct_sigstack_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sigstack_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sigstack_ptr_ptr { return new struct_sigstack_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sigstack { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_sigstack { return new struct_sigstack($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_sigstack[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sigstack($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "ss_sp": return new string_($this->data[0]->ss_sp);
            case "ss_onstack": return $this->data[0]->ss_onstack;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ss_sp":
                (new string_($this->data[0]->ss_sp))->set($value);
                break;
            case "ss_onstack":
                $this->data[0]->ss_onstack = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_sigstack_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sigstack*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sigstack_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sigstack_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sigstack_ptr_ptr_ptr { return new struct_sigstack_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sigstack_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_sigstack_ptr { return new struct_sigstack_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_sigstack_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sigstack_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sigstack_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sigstack_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sigstack**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sigstack_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sigstack_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sigstack_ptr_ptr_ptr_ptr { return new struct_sigstack_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sigstack_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_sigstack_ptr_ptr { return new struct_sigstack_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_sigstack_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sigstack_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sigstack_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sigstack_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sigstack***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_sigstack_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_sigstack_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_sigstack_ptr_ptr_ptr_ptr_ptr { return new struct_sigstack_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_sigstack_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_sigstack_ptr_ptr_ptr { return new struct_sigstack_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_sigstack_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_sigstack_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_sigstack_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_sigstack_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct sigstack****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $tv_sec
 * @property int $tv_usec
 */
class struct_timeval implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timeval $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timeval_ptr { return new struct_timeval_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "tv_sec": return $this->data->tv_sec;
            case "tv_usec": return $this->data->tv_usec;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "tv_sec":
                $this->data->tv_sec = $value;
                break;
            case "tv_usec":
                $this->data->tv_usec = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_timeval $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timeval'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $tv_sec
 * @property int $tv_usec
 */
class struct_timeval_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timeval_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timeval_ptr_ptr { return new struct_timeval_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_timeval { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_timeval { return new struct_timeval($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_timeval[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_timeval($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "tv_sec": return $this->data[0]->tv_sec;
            case "tv_usec": return $this->data[0]->tv_usec;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "tv_sec":
                $this->data[0]->tv_sec = $value;
                break;
            case "tv_usec":
                $this->data[0]->tv_usec = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_timeval_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timeval*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_timeval_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timeval_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timeval_ptr_ptr_ptr { return new struct_timeval_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_timeval_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_timeval_ptr { return new struct_timeval_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_timeval_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_timeval_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_timeval_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_timeval_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timeval**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_timeval_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timeval_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timeval_ptr_ptr_ptr_ptr { return new struct_timeval_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_timeval_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_timeval_ptr_ptr { return new struct_timeval_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_timeval_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_timeval_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_timeval_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_timeval_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timeval***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_timeval_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_timeval_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_timeval_ptr_ptr_ptr_ptr_ptr { return new struct_timeval_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_timeval_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_timeval_ptr_ptr_ptr { return new struct_timeval_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_timeval_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_timeval_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_timeval_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_timeval_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct timeval****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_timeval $ru_utime
 * @property struct_timeval $ru_stime
 * @property int $ru_maxrss
 * @property int $ru_ixrss
 * @property int $ru_idrss
 * @property int $ru_isrss
 * @property int $ru_minflt
 * @property int $ru_majflt
 * @property int $ru_nswap
 * @property int $ru_inblock
 * @property int $ru_oublock
 * @property int $ru_msgsnd
 * @property int $ru_msgrcv
 * @property int $ru_nsignals
 * @property int $ru_nvcsw
 * @property int $ru_nivcsw
 */
class struct_rusage implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_ptr { return new struct_rusage_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "ru_utime": return new struct_timeval($this->data->ru_utime);
            case "ru_stime": return new struct_timeval($this->data->ru_stime);
            case "ru_maxrss": return $this->data->ru_maxrss;
            case "ru_ixrss": return $this->data->ru_ixrss;
            case "ru_idrss": return $this->data->ru_idrss;
            case "ru_isrss": return $this->data->ru_isrss;
            case "ru_minflt": return $this->data->ru_minflt;
            case "ru_majflt": return $this->data->ru_majflt;
            case "ru_nswap": return $this->data->ru_nswap;
            case "ru_inblock": return $this->data->ru_inblock;
            case "ru_oublock": return $this->data->ru_oublock;
            case "ru_msgsnd": return $this->data->ru_msgsnd;
            case "ru_msgrcv": return $this->data->ru_msgrcv;
            case "ru_nsignals": return $this->data->ru_nsignals;
            case "ru_nvcsw": return $this->data->ru_nvcsw;
            case "ru_nivcsw": return $this->data->ru_nivcsw;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ru_utime":
                (new struct_timeval($this->data->ru_utime))->set($value);
                break;
            case "ru_stime":
                (new struct_timeval($this->data->ru_stime))->set($value);
                break;
            case "ru_maxrss":
                $this->data->ru_maxrss = $value;
                break;
            case "ru_ixrss":
                $this->data->ru_ixrss = $value;
                break;
            case "ru_idrss":
                $this->data->ru_idrss = $value;
                break;
            case "ru_isrss":
                $this->data->ru_isrss = $value;
                break;
            case "ru_minflt":
                $this->data->ru_minflt = $value;
                break;
            case "ru_majflt":
                $this->data->ru_majflt = $value;
                break;
            case "ru_nswap":
                $this->data->ru_nswap = $value;
                break;
            case "ru_inblock":
                $this->data->ru_inblock = $value;
                break;
            case "ru_oublock":
                $this->data->ru_oublock = $value;
                break;
            case "ru_msgsnd":
                $this->data->ru_msgsnd = $value;
                break;
            case "ru_msgrcv":
                $this->data->ru_msgrcv = $value;
                break;
            case "ru_nsignals":
                $this->data->ru_nsignals = $value;
                break;
            case "ru_nvcsw":
                $this->data->ru_nvcsw = $value;
                break;
            case "ru_nivcsw":
                $this->data->ru_nivcsw = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_rusage $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property struct_timeval $ru_utime
 * @property struct_timeval $ru_stime
 * @property int $ru_maxrss
 * @property int $ru_ixrss
 * @property int $ru_idrss
 * @property int $ru_isrss
 * @property int $ru_minflt
 * @property int $ru_majflt
 * @property int $ru_nswap
 * @property int $ru_inblock
 * @property int $ru_oublock
 * @property int $ru_msgsnd
 * @property int $ru_msgrcv
 * @property int $ru_nsignals
 * @property int $ru_nvcsw
 * @property int $ru_nivcsw
 */
class struct_rusage_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_ptr_ptr { return new struct_rusage_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage { return new struct_rusage($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "ru_utime": return new struct_timeval($this->data[0]->ru_utime);
            case "ru_stime": return new struct_timeval($this->data[0]->ru_stime);
            case "ru_maxrss": return $this->data[0]->ru_maxrss;
            case "ru_ixrss": return $this->data[0]->ru_ixrss;
            case "ru_idrss": return $this->data[0]->ru_idrss;
            case "ru_isrss": return $this->data[0]->ru_isrss;
            case "ru_minflt": return $this->data[0]->ru_minflt;
            case "ru_majflt": return $this->data[0]->ru_majflt;
            case "ru_nswap": return $this->data[0]->ru_nswap;
            case "ru_inblock": return $this->data[0]->ru_inblock;
            case "ru_oublock": return $this->data[0]->ru_oublock;
            case "ru_msgsnd": return $this->data[0]->ru_msgsnd;
            case "ru_msgrcv": return $this->data[0]->ru_msgrcv;
            case "ru_nsignals": return $this->data[0]->ru_nsignals;
            case "ru_nvcsw": return $this->data[0]->ru_nvcsw;
            case "ru_nivcsw": return $this->data[0]->ru_nivcsw;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ru_utime":
                (new struct_timeval($this->data[0]->ru_utime))->set($value);
                break;
            case "ru_stime":
                (new struct_timeval($this->data[0]->ru_stime))->set($value);
                break;
            case "ru_maxrss":
                $this->data[0]->ru_maxrss = $value;
                break;
            case "ru_ixrss":
                $this->data[0]->ru_ixrss = $value;
                break;
            case "ru_idrss":
                $this->data[0]->ru_idrss = $value;
                break;
            case "ru_isrss":
                $this->data[0]->ru_isrss = $value;
                break;
            case "ru_minflt":
                $this->data[0]->ru_minflt = $value;
                break;
            case "ru_majflt":
                $this->data[0]->ru_majflt = $value;
                break;
            case "ru_nswap":
                $this->data[0]->ru_nswap = $value;
                break;
            case "ru_inblock":
                $this->data[0]->ru_inblock = $value;
                break;
            case "ru_oublock":
                $this->data[0]->ru_oublock = $value;
                break;
            case "ru_msgsnd":
                $this->data[0]->ru_msgsnd = $value;
                break;
            case "ru_msgrcv":
                $this->data[0]->ru_msgrcv = $value;
                break;
            case "ru_nsignals":
                $this->data[0]->ru_nsignals = $value;
                break;
            case "ru_nvcsw":
                $this->data[0]->ru_nvcsw = $value;
                break;
            case "ru_nivcsw":
                $this->data[0]->ru_nivcsw = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_rusage_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rusage_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_ptr_ptr_ptr { return new struct_rusage_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_ptr { return new struct_rusage_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rusage_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rusage_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rusage_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_ptr_ptr_ptr_ptr { return new struct_rusage_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_ptr_ptr { return new struct_rusage_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rusage_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rusage_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rusage_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_ptr_ptr_ptr_ptr_ptr { return new struct_rusage_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_ptr_ptr_ptr { return new struct_rusage_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rusage_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rusage_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property uint8_t_ptr $ri_uuid
 * @property int $ri_user_time
 * @property int $ri_system_time
 * @property int $ri_pkg_idle_wkups
 * @property int $ri_interrupt_wkups
 * @property int $ri_pageins
 * @property int $ri_wired_size
 * @property int $ri_resident_size
 * @property int $ri_phys_footprint
 * @property int $ri_proc_start_abstime
 * @property int $ri_proc_exit_abstime
 */
class struct_rusage_info_v0 implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v0 $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v0_ptr { return new struct_rusage_info_v0_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "ri_uuid": return new uint8_t_ptr($this->data->ri_uuid);
            case "ri_user_time": return $this->data->ri_user_time;
            case "ri_system_time": return $this->data->ri_system_time;
            case "ri_pkg_idle_wkups": return $this->data->ri_pkg_idle_wkups;
            case "ri_interrupt_wkups": return $this->data->ri_interrupt_wkups;
            case "ri_pageins": return $this->data->ri_pageins;
            case "ri_wired_size": return $this->data->ri_wired_size;
            case "ri_resident_size": return $this->data->ri_resident_size;
            case "ri_phys_footprint": return $this->data->ri_phys_footprint;
            case "ri_proc_start_abstime": return $this->data->ri_proc_start_abstime;
            case "ri_proc_exit_abstime": return $this->data->ri_proc_exit_abstime;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ri_uuid":
                (new uint8_t_ptr($this->data->ri_uuid))->set($value);
                break;
            case "ri_user_time":
                $this->data->ri_user_time = $value;
                break;
            case "ri_system_time":
                $this->data->ri_system_time = $value;
                break;
            case "ri_pkg_idle_wkups":
                $this->data->ri_pkg_idle_wkups = $value;
                break;
            case "ri_interrupt_wkups":
                $this->data->ri_interrupt_wkups = $value;
                break;
            case "ri_pageins":
                $this->data->ri_pageins = $value;
                break;
            case "ri_wired_size":
                $this->data->ri_wired_size = $value;
                break;
            case "ri_resident_size":
                $this->data->ri_resident_size = $value;
                break;
            case "ri_phys_footprint":
                $this->data->ri_phys_footprint = $value;
                break;
            case "ri_proc_start_abstime":
                $this->data->ri_proc_start_abstime = $value;
                break;
            case "ri_proc_exit_abstime":
                $this->data->ri_proc_exit_abstime = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_rusage_info_v0 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v0'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property uint8_t_ptr $ri_uuid
 * @property int $ri_user_time
 * @property int $ri_system_time
 * @property int $ri_pkg_idle_wkups
 * @property int $ri_interrupt_wkups
 * @property int $ri_pageins
 * @property int $ri_wired_size
 * @property int $ri_resident_size
 * @property int $ri_phys_footprint
 * @property int $ri_proc_start_abstime
 * @property int $ri_proc_exit_abstime
 */
class struct_rusage_info_v0_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v0_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v0_ptr_ptr { return new struct_rusage_info_v0_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v0 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v0 { return new struct_rusage_info_v0($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v0[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v0($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "ri_uuid": return new uint8_t_ptr($this->data[0]->ri_uuid);
            case "ri_user_time": return $this->data[0]->ri_user_time;
            case "ri_system_time": return $this->data[0]->ri_system_time;
            case "ri_pkg_idle_wkups": return $this->data[0]->ri_pkg_idle_wkups;
            case "ri_interrupt_wkups": return $this->data[0]->ri_interrupt_wkups;
            case "ri_pageins": return $this->data[0]->ri_pageins;
            case "ri_wired_size": return $this->data[0]->ri_wired_size;
            case "ri_resident_size": return $this->data[0]->ri_resident_size;
            case "ri_phys_footprint": return $this->data[0]->ri_phys_footprint;
            case "ri_proc_start_abstime": return $this->data[0]->ri_proc_start_abstime;
            case "ri_proc_exit_abstime": return $this->data[0]->ri_proc_exit_abstime;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ri_uuid":
                (new uint8_t_ptr($this->data[0]->ri_uuid))->set($value);
                break;
            case "ri_user_time":
                $this->data[0]->ri_user_time = $value;
                break;
            case "ri_system_time":
                $this->data[0]->ri_system_time = $value;
                break;
            case "ri_pkg_idle_wkups":
                $this->data[0]->ri_pkg_idle_wkups = $value;
                break;
            case "ri_interrupt_wkups":
                $this->data[0]->ri_interrupt_wkups = $value;
                break;
            case "ri_pageins":
                $this->data[0]->ri_pageins = $value;
                break;
            case "ri_wired_size":
                $this->data[0]->ri_wired_size = $value;
                break;
            case "ri_resident_size":
                $this->data[0]->ri_resident_size = $value;
                break;
            case "ri_phys_footprint":
                $this->data[0]->ri_phys_footprint = $value;
                break;
            case "ri_proc_start_abstime":
                $this->data[0]->ri_proc_start_abstime = $value;
                break;
            case "ri_proc_exit_abstime":
                $this->data[0]->ri_proc_exit_abstime = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_rusage_info_v0_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v0*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rusage_info_v0_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v0_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v0_ptr_ptr_ptr { return new struct_rusage_info_v0_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v0_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v0_ptr { return new struct_rusage_info_v0_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v0_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rusage_info_v0_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v0_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rusage_info_v0_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v0**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rusage_info_v0_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v0_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v0_ptr_ptr_ptr_ptr { return new struct_rusage_info_v0_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v0_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v0_ptr_ptr { return new struct_rusage_info_v0_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v0_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rusage_info_v0_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v0_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rusage_info_v0_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v0***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rusage_info_v0_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v0_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v0_ptr_ptr_ptr_ptr_ptr { return new struct_rusage_info_v0_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v0_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v0_ptr_ptr_ptr { return new struct_rusage_info_v0_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v0_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rusage_info_v0_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v0_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rusage_info_v0_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v0****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property uint8_t_ptr $ri_uuid
 * @property int $ri_user_time
 * @property int $ri_system_time
 * @property int $ri_pkg_idle_wkups
 * @property int $ri_interrupt_wkups
 * @property int $ri_pageins
 * @property int $ri_wired_size
 * @property int $ri_resident_size
 * @property int $ri_phys_footprint
 * @property int $ri_proc_start_abstime
 * @property int $ri_proc_exit_abstime
 * @property int $ri_child_user_time
 * @property int $ri_child_system_time
 * @property int $ri_child_pkg_idle_wkups
 * @property int $ri_child_interrupt_wkups
 * @property int $ri_child_pageins
 * @property int $ri_child_elapsed_abstime
 */
class struct_rusage_info_v1 implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v1 $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v1_ptr { return new struct_rusage_info_v1_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "ri_uuid": return new uint8_t_ptr($this->data->ri_uuid);
            case "ri_user_time": return $this->data->ri_user_time;
            case "ri_system_time": return $this->data->ri_system_time;
            case "ri_pkg_idle_wkups": return $this->data->ri_pkg_idle_wkups;
            case "ri_interrupt_wkups": return $this->data->ri_interrupt_wkups;
            case "ri_pageins": return $this->data->ri_pageins;
            case "ri_wired_size": return $this->data->ri_wired_size;
            case "ri_resident_size": return $this->data->ri_resident_size;
            case "ri_phys_footprint": return $this->data->ri_phys_footprint;
            case "ri_proc_start_abstime": return $this->data->ri_proc_start_abstime;
            case "ri_proc_exit_abstime": return $this->data->ri_proc_exit_abstime;
            case "ri_child_user_time": return $this->data->ri_child_user_time;
            case "ri_child_system_time": return $this->data->ri_child_system_time;
            case "ri_child_pkg_idle_wkups": return $this->data->ri_child_pkg_idle_wkups;
            case "ri_child_interrupt_wkups": return $this->data->ri_child_interrupt_wkups;
            case "ri_child_pageins": return $this->data->ri_child_pageins;
            case "ri_child_elapsed_abstime": return $this->data->ri_child_elapsed_abstime;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ri_uuid":
                (new uint8_t_ptr($this->data->ri_uuid))->set($value);
                break;
            case "ri_user_time":
                $this->data->ri_user_time = $value;
                break;
            case "ri_system_time":
                $this->data->ri_system_time = $value;
                break;
            case "ri_pkg_idle_wkups":
                $this->data->ri_pkg_idle_wkups = $value;
                break;
            case "ri_interrupt_wkups":
                $this->data->ri_interrupt_wkups = $value;
                break;
            case "ri_pageins":
                $this->data->ri_pageins = $value;
                break;
            case "ri_wired_size":
                $this->data->ri_wired_size = $value;
                break;
            case "ri_resident_size":
                $this->data->ri_resident_size = $value;
                break;
            case "ri_phys_footprint":
                $this->data->ri_phys_footprint = $value;
                break;
            case "ri_proc_start_abstime":
                $this->data->ri_proc_start_abstime = $value;
                break;
            case "ri_proc_exit_abstime":
                $this->data->ri_proc_exit_abstime = $value;
                break;
            case "ri_child_user_time":
                $this->data->ri_child_user_time = $value;
                break;
            case "ri_child_system_time":
                $this->data->ri_child_system_time = $value;
                break;
            case "ri_child_pkg_idle_wkups":
                $this->data->ri_child_pkg_idle_wkups = $value;
                break;
            case "ri_child_interrupt_wkups":
                $this->data->ri_child_interrupt_wkups = $value;
                break;
            case "ri_child_pageins":
                $this->data->ri_child_pageins = $value;
                break;
            case "ri_child_elapsed_abstime":
                $this->data->ri_child_elapsed_abstime = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_rusage_info_v1 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v1'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property uint8_t_ptr $ri_uuid
 * @property int $ri_user_time
 * @property int $ri_system_time
 * @property int $ri_pkg_idle_wkups
 * @property int $ri_interrupt_wkups
 * @property int $ri_pageins
 * @property int $ri_wired_size
 * @property int $ri_resident_size
 * @property int $ri_phys_footprint
 * @property int $ri_proc_start_abstime
 * @property int $ri_proc_exit_abstime
 * @property int $ri_child_user_time
 * @property int $ri_child_system_time
 * @property int $ri_child_pkg_idle_wkups
 * @property int $ri_child_interrupt_wkups
 * @property int $ri_child_pageins
 * @property int $ri_child_elapsed_abstime
 */
class struct_rusage_info_v1_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v1_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v1_ptr_ptr { return new struct_rusage_info_v1_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v1 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v1 { return new struct_rusage_info_v1($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v1[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v1($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "ri_uuid": return new uint8_t_ptr($this->data[0]->ri_uuid);
            case "ri_user_time": return $this->data[0]->ri_user_time;
            case "ri_system_time": return $this->data[0]->ri_system_time;
            case "ri_pkg_idle_wkups": return $this->data[0]->ri_pkg_idle_wkups;
            case "ri_interrupt_wkups": return $this->data[0]->ri_interrupt_wkups;
            case "ri_pageins": return $this->data[0]->ri_pageins;
            case "ri_wired_size": return $this->data[0]->ri_wired_size;
            case "ri_resident_size": return $this->data[0]->ri_resident_size;
            case "ri_phys_footprint": return $this->data[0]->ri_phys_footprint;
            case "ri_proc_start_abstime": return $this->data[0]->ri_proc_start_abstime;
            case "ri_proc_exit_abstime": return $this->data[0]->ri_proc_exit_abstime;
            case "ri_child_user_time": return $this->data[0]->ri_child_user_time;
            case "ri_child_system_time": return $this->data[0]->ri_child_system_time;
            case "ri_child_pkg_idle_wkups": return $this->data[0]->ri_child_pkg_idle_wkups;
            case "ri_child_interrupt_wkups": return $this->data[0]->ri_child_interrupt_wkups;
            case "ri_child_pageins": return $this->data[0]->ri_child_pageins;
            case "ri_child_elapsed_abstime": return $this->data[0]->ri_child_elapsed_abstime;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ri_uuid":
                (new uint8_t_ptr($this->data[0]->ri_uuid))->set($value);
                break;
            case "ri_user_time":
                $this->data[0]->ri_user_time = $value;
                break;
            case "ri_system_time":
                $this->data[0]->ri_system_time = $value;
                break;
            case "ri_pkg_idle_wkups":
                $this->data[0]->ri_pkg_idle_wkups = $value;
                break;
            case "ri_interrupt_wkups":
                $this->data[0]->ri_interrupt_wkups = $value;
                break;
            case "ri_pageins":
                $this->data[0]->ri_pageins = $value;
                break;
            case "ri_wired_size":
                $this->data[0]->ri_wired_size = $value;
                break;
            case "ri_resident_size":
                $this->data[0]->ri_resident_size = $value;
                break;
            case "ri_phys_footprint":
                $this->data[0]->ri_phys_footprint = $value;
                break;
            case "ri_proc_start_abstime":
                $this->data[0]->ri_proc_start_abstime = $value;
                break;
            case "ri_proc_exit_abstime":
                $this->data[0]->ri_proc_exit_abstime = $value;
                break;
            case "ri_child_user_time":
                $this->data[0]->ri_child_user_time = $value;
                break;
            case "ri_child_system_time":
                $this->data[0]->ri_child_system_time = $value;
                break;
            case "ri_child_pkg_idle_wkups":
                $this->data[0]->ri_child_pkg_idle_wkups = $value;
                break;
            case "ri_child_interrupt_wkups":
                $this->data[0]->ri_child_interrupt_wkups = $value;
                break;
            case "ri_child_pageins":
                $this->data[0]->ri_child_pageins = $value;
                break;
            case "ri_child_elapsed_abstime":
                $this->data[0]->ri_child_elapsed_abstime = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_rusage_info_v1_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v1*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rusage_info_v1_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v1_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v1_ptr_ptr_ptr { return new struct_rusage_info_v1_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v1_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v1_ptr { return new struct_rusage_info_v1_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v1_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rusage_info_v1_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v1_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rusage_info_v1_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v1**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rusage_info_v1_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v1_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v1_ptr_ptr_ptr_ptr { return new struct_rusage_info_v1_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v1_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v1_ptr_ptr { return new struct_rusage_info_v1_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v1_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rusage_info_v1_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v1_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rusage_info_v1_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v1***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rusage_info_v1_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v1_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v1_ptr_ptr_ptr_ptr_ptr { return new struct_rusage_info_v1_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v1_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v1_ptr_ptr_ptr { return new struct_rusage_info_v1_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v1_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rusage_info_v1_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v1_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rusage_info_v1_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v1****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property uint8_t_ptr $ri_uuid
 * @property int $ri_user_time
 * @property int $ri_system_time
 * @property int $ri_pkg_idle_wkups
 * @property int $ri_interrupt_wkups
 * @property int $ri_pageins
 * @property int $ri_wired_size
 * @property int $ri_resident_size
 * @property int $ri_phys_footprint
 * @property int $ri_proc_start_abstime
 * @property int $ri_proc_exit_abstime
 * @property int $ri_child_user_time
 * @property int $ri_child_system_time
 * @property int $ri_child_pkg_idle_wkups
 * @property int $ri_child_interrupt_wkups
 * @property int $ri_child_pageins
 * @property int $ri_child_elapsed_abstime
 * @property int $ri_diskio_bytesread
 * @property int $ri_diskio_byteswritten
 */
class struct_rusage_info_v2 implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v2 $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v2_ptr { return new struct_rusage_info_v2_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "ri_uuid": return new uint8_t_ptr($this->data->ri_uuid);
            case "ri_user_time": return $this->data->ri_user_time;
            case "ri_system_time": return $this->data->ri_system_time;
            case "ri_pkg_idle_wkups": return $this->data->ri_pkg_idle_wkups;
            case "ri_interrupt_wkups": return $this->data->ri_interrupt_wkups;
            case "ri_pageins": return $this->data->ri_pageins;
            case "ri_wired_size": return $this->data->ri_wired_size;
            case "ri_resident_size": return $this->data->ri_resident_size;
            case "ri_phys_footprint": return $this->data->ri_phys_footprint;
            case "ri_proc_start_abstime": return $this->data->ri_proc_start_abstime;
            case "ri_proc_exit_abstime": return $this->data->ri_proc_exit_abstime;
            case "ri_child_user_time": return $this->data->ri_child_user_time;
            case "ri_child_system_time": return $this->data->ri_child_system_time;
            case "ri_child_pkg_idle_wkups": return $this->data->ri_child_pkg_idle_wkups;
            case "ri_child_interrupt_wkups": return $this->data->ri_child_interrupt_wkups;
            case "ri_child_pageins": return $this->data->ri_child_pageins;
            case "ri_child_elapsed_abstime": return $this->data->ri_child_elapsed_abstime;
            case "ri_diskio_bytesread": return $this->data->ri_diskio_bytesread;
            case "ri_diskio_byteswritten": return $this->data->ri_diskio_byteswritten;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ri_uuid":
                (new uint8_t_ptr($this->data->ri_uuid))->set($value);
                break;
            case "ri_user_time":
                $this->data->ri_user_time = $value;
                break;
            case "ri_system_time":
                $this->data->ri_system_time = $value;
                break;
            case "ri_pkg_idle_wkups":
                $this->data->ri_pkg_idle_wkups = $value;
                break;
            case "ri_interrupt_wkups":
                $this->data->ri_interrupt_wkups = $value;
                break;
            case "ri_pageins":
                $this->data->ri_pageins = $value;
                break;
            case "ri_wired_size":
                $this->data->ri_wired_size = $value;
                break;
            case "ri_resident_size":
                $this->data->ri_resident_size = $value;
                break;
            case "ri_phys_footprint":
                $this->data->ri_phys_footprint = $value;
                break;
            case "ri_proc_start_abstime":
                $this->data->ri_proc_start_abstime = $value;
                break;
            case "ri_proc_exit_abstime":
                $this->data->ri_proc_exit_abstime = $value;
                break;
            case "ri_child_user_time":
                $this->data->ri_child_user_time = $value;
                break;
            case "ri_child_system_time":
                $this->data->ri_child_system_time = $value;
                break;
            case "ri_child_pkg_idle_wkups":
                $this->data->ri_child_pkg_idle_wkups = $value;
                break;
            case "ri_child_interrupt_wkups":
                $this->data->ri_child_interrupt_wkups = $value;
                break;
            case "ri_child_pageins":
                $this->data->ri_child_pageins = $value;
                break;
            case "ri_child_elapsed_abstime":
                $this->data->ri_child_elapsed_abstime = $value;
                break;
            case "ri_diskio_bytesread":
                $this->data->ri_diskio_bytesread = $value;
                break;
            case "ri_diskio_byteswritten":
                $this->data->ri_diskio_byteswritten = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_rusage_info_v2 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v2'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property uint8_t_ptr $ri_uuid
 * @property int $ri_user_time
 * @property int $ri_system_time
 * @property int $ri_pkg_idle_wkups
 * @property int $ri_interrupt_wkups
 * @property int $ri_pageins
 * @property int $ri_wired_size
 * @property int $ri_resident_size
 * @property int $ri_phys_footprint
 * @property int $ri_proc_start_abstime
 * @property int $ri_proc_exit_abstime
 * @property int $ri_child_user_time
 * @property int $ri_child_system_time
 * @property int $ri_child_pkg_idle_wkups
 * @property int $ri_child_interrupt_wkups
 * @property int $ri_child_pageins
 * @property int $ri_child_elapsed_abstime
 * @property int $ri_diskio_bytesread
 * @property int $ri_diskio_byteswritten
 */
class struct_rusage_info_v2_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v2_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v2_ptr_ptr { return new struct_rusage_info_v2_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v2 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v2 { return new struct_rusage_info_v2($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v2[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v2($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "ri_uuid": return new uint8_t_ptr($this->data[0]->ri_uuid);
            case "ri_user_time": return $this->data[0]->ri_user_time;
            case "ri_system_time": return $this->data[0]->ri_system_time;
            case "ri_pkg_idle_wkups": return $this->data[0]->ri_pkg_idle_wkups;
            case "ri_interrupt_wkups": return $this->data[0]->ri_interrupt_wkups;
            case "ri_pageins": return $this->data[0]->ri_pageins;
            case "ri_wired_size": return $this->data[0]->ri_wired_size;
            case "ri_resident_size": return $this->data[0]->ri_resident_size;
            case "ri_phys_footprint": return $this->data[0]->ri_phys_footprint;
            case "ri_proc_start_abstime": return $this->data[0]->ri_proc_start_abstime;
            case "ri_proc_exit_abstime": return $this->data[0]->ri_proc_exit_abstime;
            case "ri_child_user_time": return $this->data[0]->ri_child_user_time;
            case "ri_child_system_time": return $this->data[0]->ri_child_system_time;
            case "ri_child_pkg_idle_wkups": return $this->data[0]->ri_child_pkg_idle_wkups;
            case "ri_child_interrupt_wkups": return $this->data[0]->ri_child_interrupt_wkups;
            case "ri_child_pageins": return $this->data[0]->ri_child_pageins;
            case "ri_child_elapsed_abstime": return $this->data[0]->ri_child_elapsed_abstime;
            case "ri_diskio_bytesread": return $this->data[0]->ri_diskio_bytesread;
            case "ri_diskio_byteswritten": return $this->data[0]->ri_diskio_byteswritten;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ri_uuid":
                (new uint8_t_ptr($this->data[0]->ri_uuid))->set($value);
                break;
            case "ri_user_time":
                $this->data[0]->ri_user_time = $value;
                break;
            case "ri_system_time":
                $this->data[0]->ri_system_time = $value;
                break;
            case "ri_pkg_idle_wkups":
                $this->data[0]->ri_pkg_idle_wkups = $value;
                break;
            case "ri_interrupt_wkups":
                $this->data[0]->ri_interrupt_wkups = $value;
                break;
            case "ri_pageins":
                $this->data[0]->ri_pageins = $value;
                break;
            case "ri_wired_size":
                $this->data[0]->ri_wired_size = $value;
                break;
            case "ri_resident_size":
                $this->data[0]->ri_resident_size = $value;
                break;
            case "ri_phys_footprint":
                $this->data[0]->ri_phys_footprint = $value;
                break;
            case "ri_proc_start_abstime":
                $this->data[0]->ri_proc_start_abstime = $value;
                break;
            case "ri_proc_exit_abstime":
                $this->data[0]->ri_proc_exit_abstime = $value;
                break;
            case "ri_child_user_time":
                $this->data[0]->ri_child_user_time = $value;
                break;
            case "ri_child_system_time":
                $this->data[0]->ri_child_system_time = $value;
                break;
            case "ri_child_pkg_idle_wkups":
                $this->data[0]->ri_child_pkg_idle_wkups = $value;
                break;
            case "ri_child_interrupt_wkups":
                $this->data[0]->ri_child_interrupt_wkups = $value;
                break;
            case "ri_child_pageins":
                $this->data[0]->ri_child_pageins = $value;
                break;
            case "ri_child_elapsed_abstime":
                $this->data[0]->ri_child_elapsed_abstime = $value;
                break;
            case "ri_diskio_bytesread":
                $this->data[0]->ri_diskio_bytesread = $value;
                break;
            case "ri_diskio_byteswritten":
                $this->data[0]->ri_diskio_byteswritten = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_rusage_info_v2_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v2*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rusage_info_v2_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v2_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v2_ptr_ptr_ptr { return new struct_rusage_info_v2_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v2_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v2_ptr { return new struct_rusage_info_v2_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v2_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rusage_info_v2_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v2_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rusage_info_v2_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v2**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rusage_info_v2_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v2_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v2_ptr_ptr_ptr_ptr { return new struct_rusage_info_v2_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v2_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v2_ptr_ptr { return new struct_rusage_info_v2_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v2_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rusage_info_v2_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v2_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rusage_info_v2_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v2***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rusage_info_v2_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v2_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v2_ptr_ptr_ptr_ptr_ptr { return new struct_rusage_info_v2_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v2_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v2_ptr_ptr_ptr { return new struct_rusage_info_v2_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v2_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rusage_info_v2_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v2_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rusage_info_v2_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v2****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property uint8_t_ptr $ri_uuid
 * @property int $ri_user_time
 * @property int $ri_system_time
 * @property int $ri_pkg_idle_wkups
 * @property int $ri_interrupt_wkups
 * @property int $ri_pageins
 * @property int $ri_wired_size
 * @property int $ri_resident_size
 * @property int $ri_phys_footprint
 * @property int $ri_proc_start_abstime
 * @property int $ri_proc_exit_abstime
 * @property int $ri_child_user_time
 * @property int $ri_child_system_time
 * @property int $ri_child_pkg_idle_wkups
 * @property int $ri_child_interrupt_wkups
 * @property int $ri_child_pageins
 * @property int $ri_child_elapsed_abstime
 * @property int $ri_diskio_bytesread
 * @property int $ri_diskio_byteswritten
 * @property int $ri_cpu_time_qos_default
 * @property int $ri_cpu_time_qos_maintenance
 * @property int $ri_cpu_time_qos_background
 * @property int $ri_cpu_time_qos_utility
 * @property int $ri_cpu_time_qos_legacy
 * @property int $ri_cpu_time_qos_user_initiated
 * @property int $ri_cpu_time_qos_user_interactive
 * @property int $ri_billed_system_time
 * @property int $ri_serviced_system_time
 */
class struct_rusage_info_v3 implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v3 $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v3_ptr { return new struct_rusage_info_v3_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "ri_uuid": return new uint8_t_ptr($this->data->ri_uuid);
            case "ri_user_time": return $this->data->ri_user_time;
            case "ri_system_time": return $this->data->ri_system_time;
            case "ri_pkg_idle_wkups": return $this->data->ri_pkg_idle_wkups;
            case "ri_interrupt_wkups": return $this->data->ri_interrupt_wkups;
            case "ri_pageins": return $this->data->ri_pageins;
            case "ri_wired_size": return $this->data->ri_wired_size;
            case "ri_resident_size": return $this->data->ri_resident_size;
            case "ri_phys_footprint": return $this->data->ri_phys_footprint;
            case "ri_proc_start_abstime": return $this->data->ri_proc_start_abstime;
            case "ri_proc_exit_abstime": return $this->data->ri_proc_exit_abstime;
            case "ri_child_user_time": return $this->data->ri_child_user_time;
            case "ri_child_system_time": return $this->data->ri_child_system_time;
            case "ri_child_pkg_idle_wkups": return $this->data->ri_child_pkg_idle_wkups;
            case "ri_child_interrupt_wkups": return $this->data->ri_child_interrupt_wkups;
            case "ri_child_pageins": return $this->data->ri_child_pageins;
            case "ri_child_elapsed_abstime": return $this->data->ri_child_elapsed_abstime;
            case "ri_diskio_bytesread": return $this->data->ri_diskio_bytesread;
            case "ri_diskio_byteswritten": return $this->data->ri_diskio_byteswritten;
            case "ri_cpu_time_qos_default": return $this->data->ri_cpu_time_qos_default;
            case "ri_cpu_time_qos_maintenance": return $this->data->ri_cpu_time_qos_maintenance;
            case "ri_cpu_time_qos_background": return $this->data->ri_cpu_time_qos_background;
            case "ri_cpu_time_qos_utility": return $this->data->ri_cpu_time_qos_utility;
            case "ri_cpu_time_qos_legacy": return $this->data->ri_cpu_time_qos_legacy;
            case "ri_cpu_time_qos_user_initiated": return $this->data->ri_cpu_time_qos_user_initiated;
            case "ri_cpu_time_qos_user_interactive": return $this->data->ri_cpu_time_qos_user_interactive;
            case "ri_billed_system_time": return $this->data->ri_billed_system_time;
            case "ri_serviced_system_time": return $this->data->ri_serviced_system_time;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ri_uuid":
                (new uint8_t_ptr($this->data->ri_uuid))->set($value);
                break;
            case "ri_user_time":
                $this->data->ri_user_time = $value;
                break;
            case "ri_system_time":
                $this->data->ri_system_time = $value;
                break;
            case "ri_pkg_idle_wkups":
                $this->data->ri_pkg_idle_wkups = $value;
                break;
            case "ri_interrupt_wkups":
                $this->data->ri_interrupt_wkups = $value;
                break;
            case "ri_pageins":
                $this->data->ri_pageins = $value;
                break;
            case "ri_wired_size":
                $this->data->ri_wired_size = $value;
                break;
            case "ri_resident_size":
                $this->data->ri_resident_size = $value;
                break;
            case "ri_phys_footprint":
                $this->data->ri_phys_footprint = $value;
                break;
            case "ri_proc_start_abstime":
                $this->data->ri_proc_start_abstime = $value;
                break;
            case "ri_proc_exit_abstime":
                $this->data->ri_proc_exit_abstime = $value;
                break;
            case "ri_child_user_time":
                $this->data->ri_child_user_time = $value;
                break;
            case "ri_child_system_time":
                $this->data->ri_child_system_time = $value;
                break;
            case "ri_child_pkg_idle_wkups":
                $this->data->ri_child_pkg_idle_wkups = $value;
                break;
            case "ri_child_interrupt_wkups":
                $this->data->ri_child_interrupt_wkups = $value;
                break;
            case "ri_child_pageins":
                $this->data->ri_child_pageins = $value;
                break;
            case "ri_child_elapsed_abstime":
                $this->data->ri_child_elapsed_abstime = $value;
                break;
            case "ri_diskio_bytesread":
                $this->data->ri_diskio_bytesread = $value;
                break;
            case "ri_diskio_byteswritten":
                $this->data->ri_diskio_byteswritten = $value;
                break;
            case "ri_cpu_time_qos_default":
                $this->data->ri_cpu_time_qos_default = $value;
                break;
            case "ri_cpu_time_qos_maintenance":
                $this->data->ri_cpu_time_qos_maintenance = $value;
                break;
            case "ri_cpu_time_qos_background":
                $this->data->ri_cpu_time_qos_background = $value;
                break;
            case "ri_cpu_time_qos_utility":
                $this->data->ri_cpu_time_qos_utility = $value;
                break;
            case "ri_cpu_time_qos_legacy":
                $this->data->ri_cpu_time_qos_legacy = $value;
                break;
            case "ri_cpu_time_qos_user_initiated":
                $this->data->ri_cpu_time_qos_user_initiated = $value;
                break;
            case "ri_cpu_time_qos_user_interactive":
                $this->data->ri_cpu_time_qos_user_interactive = $value;
                break;
            case "ri_billed_system_time":
                $this->data->ri_billed_system_time = $value;
                break;
            case "ri_serviced_system_time":
                $this->data->ri_serviced_system_time = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_rusage_info_v3 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v3'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property uint8_t_ptr $ri_uuid
 * @property int $ri_user_time
 * @property int $ri_system_time
 * @property int $ri_pkg_idle_wkups
 * @property int $ri_interrupt_wkups
 * @property int $ri_pageins
 * @property int $ri_wired_size
 * @property int $ri_resident_size
 * @property int $ri_phys_footprint
 * @property int $ri_proc_start_abstime
 * @property int $ri_proc_exit_abstime
 * @property int $ri_child_user_time
 * @property int $ri_child_system_time
 * @property int $ri_child_pkg_idle_wkups
 * @property int $ri_child_interrupt_wkups
 * @property int $ri_child_pageins
 * @property int $ri_child_elapsed_abstime
 * @property int $ri_diskio_bytesread
 * @property int $ri_diskio_byteswritten
 * @property int $ri_cpu_time_qos_default
 * @property int $ri_cpu_time_qos_maintenance
 * @property int $ri_cpu_time_qos_background
 * @property int $ri_cpu_time_qos_utility
 * @property int $ri_cpu_time_qos_legacy
 * @property int $ri_cpu_time_qos_user_initiated
 * @property int $ri_cpu_time_qos_user_interactive
 * @property int $ri_billed_system_time
 * @property int $ri_serviced_system_time
 */
class struct_rusage_info_v3_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v3_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v3_ptr_ptr { return new struct_rusage_info_v3_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v3 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v3 { return new struct_rusage_info_v3($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v3[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v3($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "ri_uuid": return new uint8_t_ptr($this->data[0]->ri_uuid);
            case "ri_user_time": return $this->data[0]->ri_user_time;
            case "ri_system_time": return $this->data[0]->ri_system_time;
            case "ri_pkg_idle_wkups": return $this->data[0]->ri_pkg_idle_wkups;
            case "ri_interrupt_wkups": return $this->data[0]->ri_interrupt_wkups;
            case "ri_pageins": return $this->data[0]->ri_pageins;
            case "ri_wired_size": return $this->data[0]->ri_wired_size;
            case "ri_resident_size": return $this->data[0]->ri_resident_size;
            case "ri_phys_footprint": return $this->data[0]->ri_phys_footprint;
            case "ri_proc_start_abstime": return $this->data[0]->ri_proc_start_abstime;
            case "ri_proc_exit_abstime": return $this->data[0]->ri_proc_exit_abstime;
            case "ri_child_user_time": return $this->data[0]->ri_child_user_time;
            case "ri_child_system_time": return $this->data[0]->ri_child_system_time;
            case "ri_child_pkg_idle_wkups": return $this->data[0]->ri_child_pkg_idle_wkups;
            case "ri_child_interrupt_wkups": return $this->data[0]->ri_child_interrupt_wkups;
            case "ri_child_pageins": return $this->data[0]->ri_child_pageins;
            case "ri_child_elapsed_abstime": return $this->data[0]->ri_child_elapsed_abstime;
            case "ri_diskio_bytesread": return $this->data[0]->ri_diskio_bytesread;
            case "ri_diskio_byteswritten": return $this->data[0]->ri_diskio_byteswritten;
            case "ri_cpu_time_qos_default": return $this->data[0]->ri_cpu_time_qos_default;
            case "ri_cpu_time_qos_maintenance": return $this->data[0]->ri_cpu_time_qos_maintenance;
            case "ri_cpu_time_qos_background": return $this->data[0]->ri_cpu_time_qos_background;
            case "ri_cpu_time_qos_utility": return $this->data[0]->ri_cpu_time_qos_utility;
            case "ri_cpu_time_qos_legacy": return $this->data[0]->ri_cpu_time_qos_legacy;
            case "ri_cpu_time_qos_user_initiated": return $this->data[0]->ri_cpu_time_qos_user_initiated;
            case "ri_cpu_time_qos_user_interactive": return $this->data[0]->ri_cpu_time_qos_user_interactive;
            case "ri_billed_system_time": return $this->data[0]->ri_billed_system_time;
            case "ri_serviced_system_time": return $this->data[0]->ri_serviced_system_time;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ri_uuid":
                (new uint8_t_ptr($this->data[0]->ri_uuid))->set($value);
                break;
            case "ri_user_time":
                $this->data[0]->ri_user_time = $value;
                break;
            case "ri_system_time":
                $this->data[0]->ri_system_time = $value;
                break;
            case "ri_pkg_idle_wkups":
                $this->data[0]->ri_pkg_idle_wkups = $value;
                break;
            case "ri_interrupt_wkups":
                $this->data[0]->ri_interrupt_wkups = $value;
                break;
            case "ri_pageins":
                $this->data[0]->ri_pageins = $value;
                break;
            case "ri_wired_size":
                $this->data[0]->ri_wired_size = $value;
                break;
            case "ri_resident_size":
                $this->data[0]->ri_resident_size = $value;
                break;
            case "ri_phys_footprint":
                $this->data[0]->ri_phys_footprint = $value;
                break;
            case "ri_proc_start_abstime":
                $this->data[0]->ri_proc_start_abstime = $value;
                break;
            case "ri_proc_exit_abstime":
                $this->data[0]->ri_proc_exit_abstime = $value;
                break;
            case "ri_child_user_time":
                $this->data[0]->ri_child_user_time = $value;
                break;
            case "ri_child_system_time":
                $this->data[0]->ri_child_system_time = $value;
                break;
            case "ri_child_pkg_idle_wkups":
                $this->data[0]->ri_child_pkg_idle_wkups = $value;
                break;
            case "ri_child_interrupt_wkups":
                $this->data[0]->ri_child_interrupt_wkups = $value;
                break;
            case "ri_child_pageins":
                $this->data[0]->ri_child_pageins = $value;
                break;
            case "ri_child_elapsed_abstime":
                $this->data[0]->ri_child_elapsed_abstime = $value;
                break;
            case "ri_diskio_bytesread":
                $this->data[0]->ri_diskio_bytesread = $value;
                break;
            case "ri_diskio_byteswritten":
                $this->data[0]->ri_diskio_byteswritten = $value;
                break;
            case "ri_cpu_time_qos_default":
                $this->data[0]->ri_cpu_time_qos_default = $value;
                break;
            case "ri_cpu_time_qos_maintenance":
                $this->data[0]->ri_cpu_time_qos_maintenance = $value;
                break;
            case "ri_cpu_time_qos_background":
                $this->data[0]->ri_cpu_time_qos_background = $value;
                break;
            case "ri_cpu_time_qos_utility":
                $this->data[0]->ri_cpu_time_qos_utility = $value;
                break;
            case "ri_cpu_time_qos_legacy":
                $this->data[0]->ri_cpu_time_qos_legacy = $value;
                break;
            case "ri_cpu_time_qos_user_initiated":
                $this->data[0]->ri_cpu_time_qos_user_initiated = $value;
                break;
            case "ri_cpu_time_qos_user_interactive":
                $this->data[0]->ri_cpu_time_qos_user_interactive = $value;
                break;
            case "ri_billed_system_time":
                $this->data[0]->ri_billed_system_time = $value;
                break;
            case "ri_serviced_system_time":
                $this->data[0]->ri_serviced_system_time = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_rusage_info_v3_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v3*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rusage_info_v3_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v3_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v3_ptr_ptr_ptr { return new struct_rusage_info_v3_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v3_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v3_ptr { return new struct_rusage_info_v3_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v3_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rusage_info_v3_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v3_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rusage_info_v3_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v3**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rusage_info_v3_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v3_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v3_ptr_ptr_ptr_ptr { return new struct_rusage_info_v3_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v3_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v3_ptr_ptr { return new struct_rusage_info_v3_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v3_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rusage_info_v3_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v3_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rusage_info_v3_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v3***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rusage_info_v3_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v3_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v3_ptr_ptr_ptr_ptr_ptr { return new struct_rusage_info_v3_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v3_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v3_ptr_ptr_ptr { return new struct_rusage_info_v3_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v3_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rusage_info_v3_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v3_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rusage_info_v3_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v3****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property uint8_t_ptr $ri_uuid
 * @property int $ri_user_time
 * @property int $ri_system_time
 * @property int $ri_pkg_idle_wkups
 * @property int $ri_interrupt_wkups
 * @property int $ri_pageins
 * @property int $ri_wired_size
 * @property int $ri_resident_size
 * @property int $ri_phys_footprint
 * @property int $ri_proc_start_abstime
 * @property int $ri_proc_exit_abstime
 * @property int $ri_child_user_time
 * @property int $ri_child_system_time
 * @property int $ri_child_pkg_idle_wkups
 * @property int $ri_child_interrupt_wkups
 * @property int $ri_child_pageins
 * @property int $ri_child_elapsed_abstime
 * @property int $ri_diskio_bytesread
 * @property int $ri_diskio_byteswritten
 * @property int $ri_cpu_time_qos_default
 * @property int $ri_cpu_time_qos_maintenance
 * @property int $ri_cpu_time_qos_background
 * @property int $ri_cpu_time_qos_utility
 * @property int $ri_cpu_time_qos_legacy
 * @property int $ri_cpu_time_qos_user_initiated
 * @property int $ri_cpu_time_qos_user_interactive
 * @property int $ri_billed_system_time
 * @property int $ri_serviced_system_time
 * @property int $ri_logical_writes
 * @property int $ri_lifetime_max_phys_footprint
 * @property int $ri_instructions
 * @property int $ri_cycles
 * @property int $ri_billed_energy
 * @property int $ri_serviced_energy
 * @property int $ri_interval_max_phys_footprint
 * @property int $ri_runnable_time
 */
class struct_rusage_info_v4 implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v4 $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v4_ptr { return new struct_rusage_info_v4_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "ri_uuid": return new uint8_t_ptr($this->data->ri_uuid);
            case "ri_user_time": return $this->data->ri_user_time;
            case "ri_system_time": return $this->data->ri_system_time;
            case "ri_pkg_idle_wkups": return $this->data->ri_pkg_idle_wkups;
            case "ri_interrupt_wkups": return $this->data->ri_interrupt_wkups;
            case "ri_pageins": return $this->data->ri_pageins;
            case "ri_wired_size": return $this->data->ri_wired_size;
            case "ri_resident_size": return $this->data->ri_resident_size;
            case "ri_phys_footprint": return $this->data->ri_phys_footprint;
            case "ri_proc_start_abstime": return $this->data->ri_proc_start_abstime;
            case "ri_proc_exit_abstime": return $this->data->ri_proc_exit_abstime;
            case "ri_child_user_time": return $this->data->ri_child_user_time;
            case "ri_child_system_time": return $this->data->ri_child_system_time;
            case "ri_child_pkg_idle_wkups": return $this->data->ri_child_pkg_idle_wkups;
            case "ri_child_interrupt_wkups": return $this->data->ri_child_interrupt_wkups;
            case "ri_child_pageins": return $this->data->ri_child_pageins;
            case "ri_child_elapsed_abstime": return $this->data->ri_child_elapsed_abstime;
            case "ri_diskio_bytesread": return $this->data->ri_diskio_bytesread;
            case "ri_diskio_byteswritten": return $this->data->ri_diskio_byteswritten;
            case "ri_cpu_time_qos_default": return $this->data->ri_cpu_time_qos_default;
            case "ri_cpu_time_qos_maintenance": return $this->data->ri_cpu_time_qos_maintenance;
            case "ri_cpu_time_qos_background": return $this->data->ri_cpu_time_qos_background;
            case "ri_cpu_time_qos_utility": return $this->data->ri_cpu_time_qos_utility;
            case "ri_cpu_time_qos_legacy": return $this->data->ri_cpu_time_qos_legacy;
            case "ri_cpu_time_qos_user_initiated": return $this->data->ri_cpu_time_qos_user_initiated;
            case "ri_cpu_time_qos_user_interactive": return $this->data->ri_cpu_time_qos_user_interactive;
            case "ri_billed_system_time": return $this->data->ri_billed_system_time;
            case "ri_serviced_system_time": return $this->data->ri_serviced_system_time;
            case "ri_logical_writes": return $this->data->ri_logical_writes;
            case "ri_lifetime_max_phys_footprint": return $this->data->ri_lifetime_max_phys_footprint;
            case "ri_instructions": return $this->data->ri_instructions;
            case "ri_cycles": return $this->data->ri_cycles;
            case "ri_billed_energy": return $this->data->ri_billed_energy;
            case "ri_serviced_energy": return $this->data->ri_serviced_energy;
            case "ri_interval_max_phys_footprint": return $this->data->ri_interval_max_phys_footprint;
            case "ri_runnable_time": return $this->data->ri_runnable_time;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ri_uuid":
                (new uint8_t_ptr($this->data->ri_uuid))->set($value);
                break;
            case "ri_user_time":
                $this->data->ri_user_time = $value;
                break;
            case "ri_system_time":
                $this->data->ri_system_time = $value;
                break;
            case "ri_pkg_idle_wkups":
                $this->data->ri_pkg_idle_wkups = $value;
                break;
            case "ri_interrupt_wkups":
                $this->data->ri_interrupt_wkups = $value;
                break;
            case "ri_pageins":
                $this->data->ri_pageins = $value;
                break;
            case "ri_wired_size":
                $this->data->ri_wired_size = $value;
                break;
            case "ri_resident_size":
                $this->data->ri_resident_size = $value;
                break;
            case "ri_phys_footprint":
                $this->data->ri_phys_footprint = $value;
                break;
            case "ri_proc_start_abstime":
                $this->data->ri_proc_start_abstime = $value;
                break;
            case "ri_proc_exit_abstime":
                $this->data->ri_proc_exit_abstime = $value;
                break;
            case "ri_child_user_time":
                $this->data->ri_child_user_time = $value;
                break;
            case "ri_child_system_time":
                $this->data->ri_child_system_time = $value;
                break;
            case "ri_child_pkg_idle_wkups":
                $this->data->ri_child_pkg_idle_wkups = $value;
                break;
            case "ri_child_interrupt_wkups":
                $this->data->ri_child_interrupt_wkups = $value;
                break;
            case "ri_child_pageins":
                $this->data->ri_child_pageins = $value;
                break;
            case "ri_child_elapsed_abstime":
                $this->data->ri_child_elapsed_abstime = $value;
                break;
            case "ri_diskio_bytesread":
                $this->data->ri_diskio_bytesread = $value;
                break;
            case "ri_diskio_byteswritten":
                $this->data->ri_diskio_byteswritten = $value;
                break;
            case "ri_cpu_time_qos_default":
                $this->data->ri_cpu_time_qos_default = $value;
                break;
            case "ri_cpu_time_qos_maintenance":
                $this->data->ri_cpu_time_qos_maintenance = $value;
                break;
            case "ri_cpu_time_qos_background":
                $this->data->ri_cpu_time_qos_background = $value;
                break;
            case "ri_cpu_time_qos_utility":
                $this->data->ri_cpu_time_qos_utility = $value;
                break;
            case "ri_cpu_time_qos_legacy":
                $this->data->ri_cpu_time_qos_legacy = $value;
                break;
            case "ri_cpu_time_qos_user_initiated":
                $this->data->ri_cpu_time_qos_user_initiated = $value;
                break;
            case "ri_cpu_time_qos_user_interactive":
                $this->data->ri_cpu_time_qos_user_interactive = $value;
                break;
            case "ri_billed_system_time":
                $this->data->ri_billed_system_time = $value;
                break;
            case "ri_serviced_system_time":
                $this->data->ri_serviced_system_time = $value;
                break;
            case "ri_logical_writes":
                $this->data->ri_logical_writes = $value;
                break;
            case "ri_lifetime_max_phys_footprint":
                $this->data->ri_lifetime_max_phys_footprint = $value;
                break;
            case "ri_instructions":
                $this->data->ri_instructions = $value;
                break;
            case "ri_cycles":
                $this->data->ri_cycles = $value;
                break;
            case "ri_billed_energy":
                $this->data->ri_billed_energy = $value;
                break;
            case "ri_serviced_energy":
                $this->data->ri_serviced_energy = $value;
                break;
            case "ri_interval_max_phys_footprint":
                $this->data->ri_interval_max_phys_footprint = $value;
                break;
            case "ri_runnable_time":
                $this->data->ri_runnable_time = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_rusage_info_v4 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v4'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property uint8_t_ptr $ri_uuid
 * @property int $ri_user_time
 * @property int $ri_system_time
 * @property int $ri_pkg_idle_wkups
 * @property int $ri_interrupt_wkups
 * @property int $ri_pageins
 * @property int $ri_wired_size
 * @property int $ri_resident_size
 * @property int $ri_phys_footprint
 * @property int $ri_proc_start_abstime
 * @property int $ri_proc_exit_abstime
 * @property int $ri_child_user_time
 * @property int $ri_child_system_time
 * @property int $ri_child_pkg_idle_wkups
 * @property int $ri_child_interrupt_wkups
 * @property int $ri_child_pageins
 * @property int $ri_child_elapsed_abstime
 * @property int $ri_diskio_bytesread
 * @property int $ri_diskio_byteswritten
 * @property int $ri_cpu_time_qos_default
 * @property int $ri_cpu_time_qos_maintenance
 * @property int $ri_cpu_time_qos_background
 * @property int $ri_cpu_time_qos_utility
 * @property int $ri_cpu_time_qos_legacy
 * @property int $ri_cpu_time_qos_user_initiated
 * @property int $ri_cpu_time_qos_user_interactive
 * @property int $ri_billed_system_time
 * @property int $ri_serviced_system_time
 * @property int $ri_logical_writes
 * @property int $ri_lifetime_max_phys_footprint
 * @property int $ri_instructions
 * @property int $ri_cycles
 * @property int $ri_billed_energy
 * @property int $ri_serviced_energy
 * @property int $ri_interval_max_phys_footprint
 * @property int $ri_runnable_time
 */
class struct_rusage_info_v4_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v4_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v4_ptr_ptr { return new struct_rusage_info_v4_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v4 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v4 { return new struct_rusage_info_v4($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v4[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v4($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "ri_uuid": return new uint8_t_ptr($this->data[0]->ri_uuid);
            case "ri_user_time": return $this->data[0]->ri_user_time;
            case "ri_system_time": return $this->data[0]->ri_system_time;
            case "ri_pkg_idle_wkups": return $this->data[0]->ri_pkg_idle_wkups;
            case "ri_interrupt_wkups": return $this->data[0]->ri_interrupt_wkups;
            case "ri_pageins": return $this->data[0]->ri_pageins;
            case "ri_wired_size": return $this->data[0]->ri_wired_size;
            case "ri_resident_size": return $this->data[0]->ri_resident_size;
            case "ri_phys_footprint": return $this->data[0]->ri_phys_footprint;
            case "ri_proc_start_abstime": return $this->data[0]->ri_proc_start_abstime;
            case "ri_proc_exit_abstime": return $this->data[0]->ri_proc_exit_abstime;
            case "ri_child_user_time": return $this->data[0]->ri_child_user_time;
            case "ri_child_system_time": return $this->data[0]->ri_child_system_time;
            case "ri_child_pkg_idle_wkups": return $this->data[0]->ri_child_pkg_idle_wkups;
            case "ri_child_interrupt_wkups": return $this->data[0]->ri_child_interrupt_wkups;
            case "ri_child_pageins": return $this->data[0]->ri_child_pageins;
            case "ri_child_elapsed_abstime": return $this->data[0]->ri_child_elapsed_abstime;
            case "ri_diskio_bytesread": return $this->data[0]->ri_diskio_bytesread;
            case "ri_diskio_byteswritten": return $this->data[0]->ri_diskio_byteswritten;
            case "ri_cpu_time_qos_default": return $this->data[0]->ri_cpu_time_qos_default;
            case "ri_cpu_time_qos_maintenance": return $this->data[0]->ri_cpu_time_qos_maintenance;
            case "ri_cpu_time_qos_background": return $this->data[0]->ri_cpu_time_qos_background;
            case "ri_cpu_time_qos_utility": return $this->data[0]->ri_cpu_time_qos_utility;
            case "ri_cpu_time_qos_legacy": return $this->data[0]->ri_cpu_time_qos_legacy;
            case "ri_cpu_time_qos_user_initiated": return $this->data[0]->ri_cpu_time_qos_user_initiated;
            case "ri_cpu_time_qos_user_interactive": return $this->data[0]->ri_cpu_time_qos_user_interactive;
            case "ri_billed_system_time": return $this->data[0]->ri_billed_system_time;
            case "ri_serviced_system_time": return $this->data[0]->ri_serviced_system_time;
            case "ri_logical_writes": return $this->data[0]->ri_logical_writes;
            case "ri_lifetime_max_phys_footprint": return $this->data[0]->ri_lifetime_max_phys_footprint;
            case "ri_instructions": return $this->data[0]->ri_instructions;
            case "ri_cycles": return $this->data[0]->ri_cycles;
            case "ri_billed_energy": return $this->data[0]->ri_billed_energy;
            case "ri_serviced_energy": return $this->data[0]->ri_serviced_energy;
            case "ri_interval_max_phys_footprint": return $this->data[0]->ri_interval_max_phys_footprint;
            case "ri_runnable_time": return $this->data[0]->ri_runnable_time;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ri_uuid":
                (new uint8_t_ptr($this->data[0]->ri_uuid))->set($value);
                break;
            case "ri_user_time":
                $this->data[0]->ri_user_time = $value;
                break;
            case "ri_system_time":
                $this->data[0]->ri_system_time = $value;
                break;
            case "ri_pkg_idle_wkups":
                $this->data[0]->ri_pkg_idle_wkups = $value;
                break;
            case "ri_interrupt_wkups":
                $this->data[0]->ri_interrupt_wkups = $value;
                break;
            case "ri_pageins":
                $this->data[0]->ri_pageins = $value;
                break;
            case "ri_wired_size":
                $this->data[0]->ri_wired_size = $value;
                break;
            case "ri_resident_size":
                $this->data[0]->ri_resident_size = $value;
                break;
            case "ri_phys_footprint":
                $this->data[0]->ri_phys_footprint = $value;
                break;
            case "ri_proc_start_abstime":
                $this->data[0]->ri_proc_start_abstime = $value;
                break;
            case "ri_proc_exit_abstime":
                $this->data[0]->ri_proc_exit_abstime = $value;
                break;
            case "ri_child_user_time":
                $this->data[0]->ri_child_user_time = $value;
                break;
            case "ri_child_system_time":
                $this->data[0]->ri_child_system_time = $value;
                break;
            case "ri_child_pkg_idle_wkups":
                $this->data[0]->ri_child_pkg_idle_wkups = $value;
                break;
            case "ri_child_interrupt_wkups":
                $this->data[0]->ri_child_interrupt_wkups = $value;
                break;
            case "ri_child_pageins":
                $this->data[0]->ri_child_pageins = $value;
                break;
            case "ri_child_elapsed_abstime":
                $this->data[0]->ri_child_elapsed_abstime = $value;
                break;
            case "ri_diskio_bytesread":
                $this->data[0]->ri_diskio_bytesread = $value;
                break;
            case "ri_diskio_byteswritten":
                $this->data[0]->ri_diskio_byteswritten = $value;
                break;
            case "ri_cpu_time_qos_default":
                $this->data[0]->ri_cpu_time_qos_default = $value;
                break;
            case "ri_cpu_time_qos_maintenance":
                $this->data[0]->ri_cpu_time_qos_maintenance = $value;
                break;
            case "ri_cpu_time_qos_background":
                $this->data[0]->ri_cpu_time_qos_background = $value;
                break;
            case "ri_cpu_time_qos_utility":
                $this->data[0]->ri_cpu_time_qos_utility = $value;
                break;
            case "ri_cpu_time_qos_legacy":
                $this->data[0]->ri_cpu_time_qos_legacy = $value;
                break;
            case "ri_cpu_time_qos_user_initiated":
                $this->data[0]->ri_cpu_time_qos_user_initiated = $value;
                break;
            case "ri_cpu_time_qos_user_interactive":
                $this->data[0]->ri_cpu_time_qos_user_interactive = $value;
                break;
            case "ri_billed_system_time":
                $this->data[0]->ri_billed_system_time = $value;
                break;
            case "ri_serviced_system_time":
                $this->data[0]->ri_serviced_system_time = $value;
                break;
            case "ri_logical_writes":
                $this->data[0]->ri_logical_writes = $value;
                break;
            case "ri_lifetime_max_phys_footprint":
                $this->data[0]->ri_lifetime_max_phys_footprint = $value;
                break;
            case "ri_instructions":
                $this->data[0]->ri_instructions = $value;
                break;
            case "ri_cycles":
                $this->data[0]->ri_cycles = $value;
                break;
            case "ri_billed_energy":
                $this->data[0]->ri_billed_energy = $value;
                break;
            case "ri_serviced_energy":
                $this->data[0]->ri_serviced_energy = $value;
                break;
            case "ri_interval_max_phys_footprint":
                $this->data[0]->ri_interval_max_phys_footprint = $value;
                break;
            case "ri_runnable_time":
                $this->data[0]->ri_runnable_time = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_rusage_info_v4_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v4*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rusage_info_v4_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v4_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v4_ptr_ptr_ptr { return new struct_rusage_info_v4_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v4_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v4_ptr { return new struct_rusage_info_v4_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v4_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rusage_info_v4_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v4_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rusage_info_v4_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v4**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rusage_info_v4_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v4_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v4_ptr_ptr_ptr_ptr { return new struct_rusage_info_v4_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v4_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v4_ptr_ptr { return new struct_rusage_info_v4_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v4_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rusage_info_v4_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v4_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rusage_info_v4_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v4***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rusage_info_v4_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v4_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v4_ptr_ptr_ptr_ptr_ptr { return new struct_rusage_info_v4_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v4_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v4_ptr_ptr_ptr { return new struct_rusage_info_v4_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v4_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rusage_info_v4_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v4_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rusage_info_v4_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v4****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property uint8_t_ptr $ri_uuid
 * @property int $ri_user_time
 * @property int $ri_system_time
 * @property int $ri_pkg_idle_wkups
 * @property int $ri_interrupt_wkups
 * @property int $ri_pageins
 * @property int $ri_wired_size
 * @property int $ri_resident_size
 * @property int $ri_phys_footprint
 * @property int $ri_proc_start_abstime
 * @property int $ri_proc_exit_abstime
 * @property int $ri_child_user_time
 * @property int $ri_child_system_time
 * @property int $ri_child_pkg_idle_wkups
 * @property int $ri_child_interrupt_wkups
 * @property int $ri_child_pageins
 * @property int $ri_child_elapsed_abstime
 * @property int $ri_diskio_bytesread
 * @property int $ri_diskio_byteswritten
 * @property int $ri_cpu_time_qos_default
 * @property int $ri_cpu_time_qos_maintenance
 * @property int $ri_cpu_time_qos_background
 * @property int $ri_cpu_time_qos_utility
 * @property int $ri_cpu_time_qos_legacy
 * @property int $ri_cpu_time_qos_user_initiated
 * @property int $ri_cpu_time_qos_user_interactive
 * @property int $ri_billed_system_time
 * @property int $ri_serviced_system_time
 * @property int $ri_logical_writes
 * @property int $ri_lifetime_max_phys_footprint
 * @property int $ri_instructions
 * @property int $ri_cycles
 * @property int $ri_billed_energy
 * @property int $ri_serviced_energy
 * @property int $ri_interval_max_phys_footprint
 * @property int $ri_runnable_time
 * @property int $ri_flags
 */
class struct_rusage_info_v5 implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v5 $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v5_ptr { return new struct_rusage_info_v5_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "ri_uuid": return new uint8_t_ptr($this->data->ri_uuid);
            case "ri_user_time": return $this->data->ri_user_time;
            case "ri_system_time": return $this->data->ri_system_time;
            case "ri_pkg_idle_wkups": return $this->data->ri_pkg_idle_wkups;
            case "ri_interrupt_wkups": return $this->data->ri_interrupt_wkups;
            case "ri_pageins": return $this->data->ri_pageins;
            case "ri_wired_size": return $this->data->ri_wired_size;
            case "ri_resident_size": return $this->data->ri_resident_size;
            case "ri_phys_footprint": return $this->data->ri_phys_footprint;
            case "ri_proc_start_abstime": return $this->data->ri_proc_start_abstime;
            case "ri_proc_exit_abstime": return $this->data->ri_proc_exit_abstime;
            case "ri_child_user_time": return $this->data->ri_child_user_time;
            case "ri_child_system_time": return $this->data->ri_child_system_time;
            case "ri_child_pkg_idle_wkups": return $this->data->ri_child_pkg_idle_wkups;
            case "ri_child_interrupt_wkups": return $this->data->ri_child_interrupt_wkups;
            case "ri_child_pageins": return $this->data->ri_child_pageins;
            case "ri_child_elapsed_abstime": return $this->data->ri_child_elapsed_abstime;
            case "ri_diskio_bytesread": return $this->data->ri_diskio_bytesread;
            case "ri_diskio_byteswritten": return $this->data->ri_diskio_byteswritten;
            case "ri_cpu_time_qos_default": return $this->data->ri_cpu_time_qos_default;
            case "ri_cpu_time_qos_maintenance": return $this->data->ri_cpu_time_qos_maintenance;
            case "ri_cpu_time_qos_background": return $this->data->ri_cpu_time_qos_background;
            case "ri_cpu_time_qos_utility": return $this->data->ri_cpu_time_qos_utility;
            case "ri_cpu_time_qos_legacy": return $this->data->ri_cpu_time_qos_legacy;
            case "ri_cpu_time_qos_user_initiated": return $this->data->ri_cpu_time_qos_user_initiated;
            case "ri_cpu_time_qos_user_interactive": return $this->data->ri_cpu_time_qos_user_interactive;
            case "ri_billed_system_time": return $this->data->ri_billed_system_time;
            case "ri_serviced_system_time": return $this->data->ri_serviced_system_time;
            case "ri_logical_writes": return $this->data->ri_logical_writes;
            case "ri_lifetime_max_phys_footprint": return $this->data->ri_lifetime_max_phys_footprint;
            case "ri_instructions": return $this->data->ri_instructions;
            case "ri_cycles": return $this->data->ri_cycles;
            case "ri_billed_energy": return $this->data->ri_billed_energy;
            case "ri_serviced_energy": return $this->data->ri_serviced_energy;
            case "ri_interval_max_phys_footprint": return $this->data->ri_interval_max_phys_footprint;
            case "ri_runnable_time": return $this->data->ri_runnable_time;
            case "ri_flags": return $this->data->ri_flags;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ri_uuid":
                (new uint8_t_ptr($this->data->ri_uuid))->set($value);
                break;
            case "ri_user_time":
                $this->data->ri_user_time = $value;
                break;
            case "ri_system_time":
                $this->data->ri_system_time = $value;
                break;
            case "ri_pkg_idle_wkups":
                $this->data->ri_pkg_idle_wkups = $value;
                break;
            case "ri_interrupt_wkups":
                $this->data->ri_interrupt_wkups = $value;
                break;
            case "ri_pageins":
                $this->data->ri_pageins = $value;
                break;
            case "ri_wired_size":
                $this->data->ri_wired_size = $value;
                break;
            case "ri_resident_size":
                $this->data->ri_resident_size = $value;
                break;
            case "ri_phys_footprint":
                $this->data->ri_phys_footprint = $value;
                break;
            case "ri_proc_start_abstime":
                $this->data->ri_proc_start_abstime = $value;
                break;
            case "ri_proc_exit_abstime":
                $this->data->ri_proc_exit_abstime = $value;
                break;
            case "ri_child_user_time":
                $this->data->ri_child_user_time = $value;
                break;
            case "ri_child_system_time":
                $this->data->ri_child_system_time = $value;
                break;
            case "ri_child_pkg_idle_wkups":
                $this->data->ri_child_pkg_idle_wkups = $value;
                break;
            case "ri_child_interrupt_wkups":
                $this->data->ri_child_interrupt_wkups = $value;
                break;
            case "ri_child_pageins":
                $this->data->ri_child_pageins = $value;
                break;
            case "ri_child_elapsed_abstime":
                $this->data->ri_child_elapsed_abstime = $value;
                break;
            case "ri_diskio_bytesread":
                $this->data->ri_diskio_bytesread = $value;
                break;
            case "ri_diskio_byteswritten":
                $this->data->ri_diskio_byteswritten = $value;
                break;
            case "ri_cpu_time_qos_default":
                $this->data->ri_cpu_time_qos_default = $value;
                break;
            case "ri_cpu_time_qos_maintenance":
                $this->data->ri_cpu_time_qos_maintenance = $value;
                break;
            case "ri_cpu_time_qos_background":
                $this->data->ri_cpu_time_qos_background = $value;
                break;
            case "ri_cpu_time_qos_utility":
                $this->data->ri_cpu_time_qos_utility = $value;
                break;
            case "ri_cpu_time_qos_legacy":
                $this->data->ri_cpu_time_qos_legacy = $value;
                break;
            case "ri_cpu_time_qos_user_initiated":
                $this->data->ri_cpu_time_qos_user_initiated = $value;
                break;
            case "ri_cpu_time_qos_user_interactive":
                $this->data->ri_cpu_time_qos_user_interactive = $value;
                break;
            case "ri_billed_system_time":
                $this->data->ri_billed_system_time = $value;
                break;
            case "ri_serviced_system_time":
                $this->data->ri_serviced_system_time = $value;
                break;
            case "ri_logical_writes":
                $this->data->ri_logical_writes = $value;
                break;
            case "ri_lifetime_max_phys_footprint":
                $this->data->ri_lifetime_max_phys_footprint = $value;
                break;
            case "ri_instructions":
                $this->data->ri_instructions = $value;
                break;
            case "ri_cycles":
                $this->data->ri_cycles = $value;
                break;
            case "ri_billed_energy":
                $this->data->ri_billed_energy = $value;
                break;
            case "ri_serviced_energy":
                $this->data->ri_serviced_energy = $value;
                break;
            case "ri_interval_max_phys_footprint":
                $this->data->ri_interval_max_phys_footprint = $value;
                break;
            case "ri_runnable_time":
                $this->data->ri_runnable_time = $value;
                break;
            case "ri_flags":
                $this->data->ri_flags = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_rusage_info_v5 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v5'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property uint8_t_ptr $ri_uuid
 * @property int $ri_user_time
 * @property int $ri_system_time
 * @property int $ri_pkg_idle_wkups
 * @property int $ri_interrupt_wkups
 * @property int $ri_pageins
 * @property int $ri_wired_size
 * @property int $ri_resident_size
 * @property int $ri_phys_footprint
 * @property int $ri_proc_start_abstime
 * @property int $ri_proc_exit_abstime
 * @property int $ri_child_user_time
 * @property int $ri_child_system_time
 * @property int $ri_child_pkg_idle_wkups
 * @property int $ri_child_interrupt_wkups
 * @property int $ri_child_pageins
 * @property int $ri_child_elapsed_abstime
 * @property int $ri_diskio_bytesread
 * @property int $ri_diskio_byteswritten
 * @property int $ri_cpu_time_qos_default
 * @property int $ri_cpu_time_qos_maintenance
 * @property int $ri_cpu_time_qos_background
 * @property int $ri_cpu_time_qos_utility
 * @property int $ri_cpu_time_qos_legacy
 * @property int $ri_cpu_time_qos_user_initiated
 * @property int $ri_cpu_time_qos_user_interactive
 * @property int $ri_billed_system_time
 * @property int $ri_serviced_system_time
 * @property int $ri_logical_writes
 * @property int $ri_lifetime_max_phys_footprint
 * @property int $ri_instructions
 * @property int $ri_cycles
 * @property int $ri_billed_energy
 * @property int $ri_serviced_energy
 * @property int $ri_interval_max_phys_footprint
 * @property int $ri_runnable_time
 * @property int $ri_flags
 */
class struct_rusage_info_v5_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v5_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v5_ptr_ptr { return new struct_rusage_info_v5_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v5 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v5 { return new struct_rusage_info_v5($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v5[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v5($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "ri_uuid": return new uint8_t_ptr($this->data[0]->ri_uuid);
            case "ri_user_time": return $this->data[0]->ri_user_time;
            case "ri_system_time": return $this->data[0]->ri_system_time;
            case "ri_pkg_idle_wkups": return $this->data[0]->ri_pkg_idle_wkups;
            case "ri_interrupt_wkups": return $this->data[0]->ri_interrupt_wkups;
            case "ri_pageins": return $this->data[0]->ri_pageins;
            case "ri_wired_size": return $this->data[0]->ri_wired_size;
            case "ri_resident_size": return $this->data[0]->ri_resident_size;
            case "ri_phys_footprint": return $this->data[0]->ri_phys_footprint;
            case "ri_proc_start_abstime": return $this->data[0]->ri_proc_start_abstime;
            case "ri_proc_exit_abstime": return $this->data[0]->ri_proc_exit_abstime;
            case "ri_child_user_time": return $this->data[0]->ri_child_user_time;
            case "ri_child_system_time": return $this->data[0]->ri_child_system_time;
            case "ri_child_pkg_idle_wkups": return $this->data[0]->ri_child_pkg_idle_wkups;
            case "ri_child_interrupt_wkups": return $this->data[0]->ri_child_interrupt_wkups;
            case "ri_child_pageins": return $this->data[0]->ri_child_pageins;
            case "ri_child_elapsed_abstime": return $this->data[0]->ri_child_elapsed_abstime;
            case "ri_diskio_bytesread": return $this->data[0]->ri_diskio_bytesread;
            case "ri_diskio_byteswritten": return $this->data[0]->ri_diskio_byteswritten;
            case "ri_cpu_time_qos_default": return $this->data[0]->ri_cpu_time_qos_default;
            case "ri_cpu_time_qos_maintenance": return $this->data[0]->ri_cpu_time_qos_maintenance;
            case "ri_cpu_time_qos_background": return $this->data[0]->ri_cpu_time_qos_background;
            case "ri_cpu_time_qos_utility": return $this->data[0]->ri_cpu_time_qos_utility;
            case "ri_cpu_time_qos_legacy": return $this->data[0]->ri_cpu_time_qos_legacy;
            case "ri_cpu_time_qos_user_initiated": return $this->data[0]->ri_cpu_time_qos_user_initiated;
            case "ri_cpu_time_qos_user_interactive": return $this->data[0]->ri_cpu_time_qos_user_interactive;
            case "ri_billed_system_time": return $this->data[0]->ri_billed_system_time;
            case "ri_serviced_system_time": return $this->data[0]->ri_serviced_system_time;
            case "ri_logical_writes": return $this->data[0]->ri_logical_writes;
            case "ri_lifetime_max_phys_footprint": return $this->data[0]->ri_lifetime_max_phys_footprint;
            case "ri_instructions": return $this->data[0]->ri_instructions;
            case "ri_cycles": return $this->data[0]->ri_cycles;
            case "ri_billed_energy": return $this->data[0]->ri_billed_energy;
            case "ri_serviced_energy": return $this->data[0]->ri_serviced_energy;
            case "ri_interval_max_phys_footprint": return $this->data[0]->ri_interval_max_phys_footprint;
            case "ri_runnable_time": return $this->data[0]->ri_runnable_time;
            case "ri_flags": return $this->data[0]->ri_flags;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "ri_uuid":
                (new uint8_t_ptr($this->data[0]->ri_uuid))->set($value);
                break;
            case "ri_user_time":
                $this->data[0]->ri_user_time = $value;
                break;
            case "ri_system_time":
                $this->data[0]->ri_system_time = $value;
                break;
            case "ri_pkg_idle_wkups":
                $this->data[0]->ri_pkg_idle_wkups = $value;
                break;
            case "ri_interrupt_wkups":
                $this->data[0]->ri_interrupt_wkups = $value;
                break;
            case "ri_pageins":
                $this->data[0]->ri_pageins = $value;
                break;
            case "ri_wired_size":
                $this->data[0]->ri_wired_size = $value;
                break;
            case "ri_resident_size":
                $this->data[0]->ri_resident_size = $value;
                break;
            case "ri_phys_footprint":
                $this->data[0]->ri_phys_footprint = $value;
                break;
            case "ri_proc_start_abstime":
                $this->data[0]->ri_proc_start_abstime = $value;
                break;
            case "ri_proc_exit_abstime":
                $this->data[0]->ri_proc_exit_abstime = $value;
                break;
            case "ri_child_user_time":
                $this->data[0]->ri_child_user_time = $value;
                break;
            case "ri_child_system_time":
                $this->data[0]->ri_child_system_time = $value;
                break;
            case "ri_child_pkg_idle_wkups":
                $this->data[0]->ri_child_pkg_idle_wkups = $value;
                break;
            case "ri_child_interrupt_wkups":
                $this->data[0]->ri_child_interrupt_wkups = $value;
                break;
            case "ri_child_pageins":
                $this->data[0]->ri_child_pageins = $value;
                break;
            case "ri_child_elapsed_abstime":
                $this->data[0]->ri_child_elapsed_abstime = $value;
                break;
            case "ri_diskio_bytesread":
                $this->data[0]->ri_diskio_bytesread = $value;
                break;
            case "ri_diskio_byteswritten":
                $this->data[0]->ri_diskio_byteswritten = $value;
                break;
            case "ri_cpu_time_qos_default":
                $this->data[0]->ri_cpu_time_qos_default = $value;
                break;
            case "ri_cpu_time_qos_maintenance":
                $this->data[0]->ri_cpu_time_qos_maintenance = $value;
                break;
            case "ri_cpu_time_qos_background":
                $this->data[0]->ri_cpu_time_qos_background = $value;
                break;
            case "ri_cpu_time_qos_utility":
                $this->data[0]->ri_cpu_time_qos_utility = $value;
                break;
            case "ri_cpu_time_qos_legacy":
                $this->data[0]->ri_cpu_time_qos_legacy = $value;
                break;
            case "ri_cpu_time_qos_user_initiated":
                $this->data[0]->ri_cpu_time_qos_user_initiated = $value;
                break;
            case "ri_cpu_time_qos_user_interactive":
                $this->data[0]->ri_cpu_time_qos_user_interactive = $value;
                break;
            case "ri_billed_system_time":
                $this->data[0]->ri_billed_system_time = $value;
                break;
            case "ri_serviced_system_time":
                $this->data[0]->ri_serviced_system_time = $value;
                break;
            case "ri_logical_writes":
                $this->data[0]->ri_logical_writes = $value;
                break;
            case "ri_lifetime_max_phys_footprint":
                $this->data[0]->ri_lifetime_max_phys_footprint = $value;
                break;
            case "ri_instructions":
                $this->data[0]->ri_instructions = $value;
                break;
            case "ri_cycles":
                $this->data[0]->ri_cycles = $value;
                break;
            case "ri_billed_energy":
                $this->data[0]->ri_billed_energy = $value;
                break;
            case "ri_serviced_energy":
                $this->data[0]->ri_serviced_energy = $value;
                break;
            case "ri_interval_max_phys_footprint":
                $this->data[0]->ri_interval_max_phys_footprint = $value;
                break;
            case "ri_runnable_time":
                $this->data[0]->ri_runnable_time = $value;
                break;
            case "ri_flags":
                $this->data[0]->ri_flags = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_rusage_info_v5_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v5*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rusage_info_v5_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v5_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v5_ptr_ptr_ptr { return new struct_rusage_info_v5_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v5_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v5_ptr { return new struct_rusage_info_v5_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v5_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rusage_info_v5_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v5_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rusage_info_v5_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v5**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rusage_info_v5_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v5_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v5_ptr_ptr_ptr_ptr { return new struct_rusage_info_v5_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v5_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v5_ptr_ptr { return new struct_rusage_info_v5_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v5_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rusage_info_v5_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v5_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rusage_info_v5_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v5***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rusage_info_v5_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rusage_info_v5_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rusage_info_v5_ptr_ptr_ptr_ptr_ptr { return new struct_rusage_info_v5_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rusage_info_v5_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rusage_info_v5_ptr_ptr_ptr { return new struct_rusage_info_v5_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rusage_info_v5_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rusage_info_v5_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rusage_info_v5_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rusage_info_v5_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rusage_info_v5****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $rlim_cur
 * @property int $rlim_max
 */
class struct_rlimit implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rlimit $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rlimit_ptr { return new struct_rlimit_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "rlim_cur": return $this->data->rlim_cur;
            case "rlim_max": return $this->data->rlim_max;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "rlim_cur":
                $this->data->rlim_cur = $value;
                break;
            case "rlim_max":
                $this->data->rlim_max = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_rlimit $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rlimit'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $rlim_cur
 * @property int $rlim_max
 */
class struct_rlimit_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rlimit_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rlimit_ptr_ptr { return new struct_rlimit_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rlimit { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rlimit { return new struct_rlimit($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rlimit[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rlimit($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "rlim_cur": return $this->data[0]->rlim_cur;
            case "rlim_max": return $this->data[0]->rlim_max;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "rlim_cur":
                $this->data[0]->rlim_cur = $value;
                break;
            case "rlim_max":
                $this->data[0]->rlim_max = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_rlimit_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rlimit*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rlimit_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rlimit_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rlimit_ptr_ptr_ptr { return new struct_rlimit_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rlimit_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rlimit_ptr { return new struct_rlimit_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rlimit_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rlimit_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rlimit_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rlimit_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rlimit**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rlimit_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rlimit_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rlimit_ptr_ptr_ptr_ptr { return new struct_rlimit_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rlimit_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rlimit_ptr_ptr { return new struct_rlimit_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rlimit_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rlimit_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rlimit_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rlimit_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rlimit***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_rlimit_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_rlimit_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_rlimit_ptr_ptr_ptr_ptr_ptr { return new struct_rlimit_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_rlimit_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_rlimit_ptr_ptr_ptr { return new struct_rlimit_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_rlimit_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_rlimit_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_rlimit_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_rlimit_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct rlimit****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $wm_flags
 * @property int $wm_rate
 */
class struct_proc_rlimit_control_wakeupmon implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_proc_rlimit_control_wakeupmon $other): bool { return $this->data == $other->data; }
    public function addr(): struct_proc_rlimit_control_wakeupmon_ptr { return new struct_proc_rlimit_control_wakeupmon_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "wm_flags": return $this->data->wm_flags;
            case "wm_rate": return $this->data->wm_rate;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "wm_flags":
                $this->data->wm_flags = $value;
                break;
            case "wm_rate":
                $this->data->wm_rate = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_proc_rlimit_control_wakeupmon $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct proc_rlimit_control_wakeupmon'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $wm_flags
 * @property int $wm_rate
 */
class struct_proc_rlimit_control_wakeupmon_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_proc_rlimit_control_wakeupmon_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_proc_rlimit_control_wakeupmon_ptr_ptr { return new struct_proc_rlimit_control_wakeupmon_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_proc_rlimit_control_wakeupmon { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_proc_rlimit_control_wakeupmon { return new struct_proc_rlimit_control_wakeupmon($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_proc_rlimit_control_wakeupmon[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_proc_rlimit_control_wakeupmon($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "wm_flags": return $this->data[0]->wm_flags;
            case "wm_rate": return $this->data[0]->wm_rate;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "wm_flags":
                $this->data[0]->wm_flags = $value;
                break;
            case "wm_rate":
                $this->data[0]->wm_rate = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_proc_rlimit_control_wakeupmon_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct proc_rlimit_control_wakeupmon*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_proc_rlimit_control_wakeupmon_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_proc_rlimit_control_wakeupmon_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_proc_rlimit_control_wakeupmon_ptr_ptr_ptr { return new struct_proc_rlimit_control_wakeupmon_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_proc_rlimit_control_wakeupmon_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_proc_rlimit_control_wakeupmon_ptr { return new struct_proc_rlimit_control_wakeupmon_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_proc_rlimit_control_wakeupmon_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_proc_rlimit_control_wakeupmon_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_proc_rlimit_control_wakeupmon_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_proc_rlimit_control_wakeupmon_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct proc_rlimit_control_wakeupmon**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_proc_rlimit_control_wakeupmon_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_proc_rlimit_control_wakeupmon_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_proc_rlimit_control_wakeupmon_ptr_ptr_ptr_ptr { return new struct_proc_rlimit_control_wakeupmon_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_proc_rlimit_control_wakeupmon_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_proc_rlimit_control_wakeupmon_ptr_ptr { return new struct_proc_rlimit_control_wakeupmon_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_proc_rlimit_control_wakeupmon_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_proc_rlimit_control_wakeupmon_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_proc_rlimit_control_wakeupmon_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_proc_rlimit_control_wakeupmon_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct proc_rlimit_control_wakeupmon***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_proc_rlimit_control_wakeupmon_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_proc_rlimit_control_wakeupmon_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_proc_rlimit_control_wakeupmon_ptr_ptr_ptr_ptr_ptr { return new struct_proc_rlimit_control_wakeupmon_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_proc_rlimit_control_wakeupmon_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_proc_rlimit_control_wakeupmon_ptr_ptr_ptr { return new struct_proc_rlimit_control_wakeupmon_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_proc_rlimit_control_wakeupmon_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_proc_rlimit_control_wakeupmon_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_proc_rlimit_control_wakeupmon_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_proc_rlimit_control_wakeupmon_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct proc_rlimit_control_wakeupmon****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $w_status
 * @property struct_anonymous_id_66 $w_T
 * @property struct_anonymous_id_67 $w_S
 */
class union_wait implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(union_wait $other): bool { return $this->data == $other->data; }
    public function addr(): union_wait_ptr { return new union_wait_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "w_status": return $this->data->w_status;
            case "w_T": return new struct_anonymous_id_66($this->data->w_T);
            case "w_S": return new struct_anonymous_id_67($this->data->w_S);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "w_status":
                $this->data->w_status = $value;
                break;
            case "w_T":
                (new struct_anonymous_id_66($this->data->w_T))->set($value);
                break;
            case "w_S":
                (new struct_anonymous_id_67($this->data->w_S))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(union_wait $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'union wait'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $w_status
 * @property struct_anonymous_id_66 $w_T
 * @property struct_anonymous_id_67 $w_S
 */
class union_wait_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(union_wait_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): union_wait_ptr_ptr { return new union_wait_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): union_wait { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): union_wait { return new union_wait($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return union_wait[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new union_wait($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "w_status": return $this->data[0]->w_status;
            case "w_T": return new struct_anonymous_id_66($this->data[0]->w_T);
            case "w_S": return new struct_anonymous_id_67($this->data[0]->w_S);
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "w_status":
                $this->data[0]->w_status = $value;
                break;
            case "w_T":
                (new struct_anonymous_id_66($this->data[0]->w_T))->set($value);
                break;
            case "w_S":
                (new struct_anonymous_id_67($this->data[0]->w_S))->set($value);
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | union_wait_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'union wait*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class union_wait_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(union_wait_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): union_wait_ptr_ptr_ptr { return new union_wait_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): union_wait_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): union_wait_ptr { return new union_wait_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return union_wait_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new union_wait_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new union_wait_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | union_wait_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'union wait**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class union_wait_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(union_wait_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): union_wait_ptr_ptr_ptr_ptr { return new union_wait_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): union_wait_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): union_wait_ptr_ptr { return new union_wait_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return union_wait_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new union_wait_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new union_wait_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | union_wait_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'union wait***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class union_wait_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(union_wait_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): union_wait_ptr_ptr_ptr_ptr_ptr { return new union_wait_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): union_wait_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): union_wait_ptr_ptr_ptr { return new union_wait_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return union_wait_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new union_wait_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new union_wait_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | union_wait_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'union wait****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $w_Termsig
 * @property int $w_Coredump
 * @property int $w_Retcode
 * @property int $w_Filler
 */
class struct_anonymous_id_66 implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_anonymous_id_66 $other): bool { return $this->data == $other->data; }
    public function addr(): struct_anonymous_id_66_ptr { return new struct_anonymous_id_66_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "w_Termsig": return $this->data->w_Termsig;
            case "w_Coredump": return $this->data->w_Coredump;
            case "w_Retcode": return $this->data->w_Retcode;
            case "w_Filler": return $this->data->w_Filler;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "w_Termsig":
                $this->data->w_Termsig = $value;
                break;
            case "w_Coredump":
                $this->data->w_Coredump = $value;
                break;
            case "w_Retcode":
                $this->data->w_Retcode = $value;
                break;
            case "w_Filler":
                $this->data->w_Filler = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_anonymous_id_66 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct anonymous id 66'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $w_Termsig
 * @property int $w_Coredump
 * @property int $w_Retcode
 * @property int $w_Filler
 */
class struct_anonymous_id_66_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_anonymous_id_66_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_anonymous_id_66_ptr_ptr { return new struct_anonymous_id_66_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_anonymous_id_66 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_anonymous_id_66 { return new struct_anonymous_id_66($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_anonymous_id_66[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_anonymous_id_66($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "w_Termsig": return $this->data[0]->w_Termsig;
            case "w_Coredump": return $this->data[0]->w_Coredump;
            case "w_Retcode": return $this->data[0]->w_Retcode;
            case "w_Filler": return $this->data[0]->w_Filler;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "w_Termsig":
                $this->data[0]->w_Termsig = $value;
                break;
            case "w_Coredump":
                $this->data[0]->w_Coredump = $value;
                break;
            case "w_Retcode":
                $this->data[0]->w_Retcode = $value;
                break;
            case "w_Filler":
                $this->data[0]->w_Filler = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_anonymous_id_66_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct anonymous id 66*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_anonymous_id_66_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_anonymous_id_66_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_anonymous_id_66_ptr_ptr_ptr { return new struct_anonymous_id_66_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_anonymous_id_66_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_anonymous_id_66_ptr { return new struct_anonymous_id_66_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_anonymous_id_66_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_anonymous_id_66_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_anonymous_id_66_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_anonymous_id_66_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct anonymous id 66**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_anonymous_id_66_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_anonymous_id_66_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_anonymous_id_66_ptr_ptr_ptr_ptr { return new struct_anonymous_id_66_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_anonymous_id_66_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_anonymous_id_66_ptr_ptr { return new struct_anonymous_id_66_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_anonymous_id_66_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_anonymous_id_66_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_anonymous_id_66_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_anonymous_id_66_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct anonymous id 66***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_anonymous_id_66_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_anonymous_id_66_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_anonymous_id_66_ptr_ptr_ptr_ptr_ptr { return new struct_anonymous_id_66_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_anonymous_id_66_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_anonymous_id_66_ptr_ptr_ptr { return new struct_anonymous_id_66_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_anonymous_id_66_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_anonymous_id_66_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_anonymous_id_66_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_anonymous_id_66_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct anonymous id 66****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $w_Stopval
 * @property int $w_Stopsig
 * @property int $w_Filler
 */
class struct_anonymous_id_67 implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_anonymous_id_67 $other): bool { return $this->data == $other->data; }
    public function addr(): struct_anonymous_id_67_ptr { return new struct_anonymous_id_67_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "w_Stopval": return $this->data->w_Stopval;
            case "w_Stopsig": return $this->data->w_Stopsig;
            case "w_Filler": return $this->data->w_Filler;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "w_Stopval":
                $this->data->w_Stopval = $value;
                break;
            case "w_Stopsig":
                $this->data->w_Stopsig = $value;
                break;
            case "w_Filler":
                $this->data->w_Filler = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(struct_anonymous_id_67 $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct anonymous id 67'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $w_Stopval
 * @property int $w_Stopsig
 * @property int $w_Filler
 */
class struct_anonymous_id_67_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_anonymous_id_67_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_anonymous_id_67_ptr_ptr { return new struct_anonymous_id_67_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_anonymous_id_67 { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_anonymous_id_67 { return new struct_anonymous_id_67($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_anonymous_id_67[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_anonymous_id_67($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "w_Stopval": return $this->data[0]->w_Stopval;
            case "w_Stopsig": return $this->data[0]->w_Stopsig;
            case "w_Filler": return $this->data[0]->w_Filler;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "w_Stopval":
                $this->data[0]->w_Stopval = $value;
                break;
            case "w_Stopsig":
                $this->data[0]->w_Stopsig = $value;
                break;
            case "w_Filler":
                $this->data[0]->w_Filler = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | struct_anonymous_id_67_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct anonymous id 67*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_anonymous_id_67_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_anonymous_id_67_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_anonymous_id_67_ptr_ptr_ptr { return new struct_anonymous_id_67_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_anonymous_id_67_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_anonymous_id_67_ptr { return new struct_anonymous_id_67_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_anonymous_id_67_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_anonymous_id_67_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_anonymous_id_67_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_anonymous_id_67_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct anonymous id 67**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_anonymous_id_67_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_anonymous_id_67_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_anonymous_id_67_ptr_ptr_ptr_ptr { return new struct_anonymous_id_67_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_anonymous_id_67_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_anonymous_id_67_ptr_ptr { return new struct_anonymous_id_67_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_anonymous_id_67_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_anonymous_id_67_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_anonymous_id_67_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_anonymous_id_67_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct anonymous id 67***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class struct_anonymous_id_67_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(struct_anonymous_id_67_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): struct_anonymous_id_67_ptr_ptr_ptr_ptr_ptr { return new struct_anonymous_id_67_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): struct_anonymous_id_67_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): struct_anonymous_id_67_ptr_ptr_ptr { return new struct_anonymous_id_67_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return struct_anonymous_id_67_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new struct_anonymous_id_67_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new struct_anonymous_id_67_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | struct_anonymous_id_67_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'struct anonymous id 67****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $quot
 * @property int $rem
 */
class div_t implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(div_t $other): bool { return $this->data == $other->data; }
    public function addr(): div_t_ptr { return new div_t_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "quot": return $this->data->quot;
            case "rem": return $this->data->rem;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "quot":
                $this->data->quot = $value;
                break;
            case "rem":
                $this->data->rem = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(div_t $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'div_t'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $quot
 * @property int $rem
 */
class div_t_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(div_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): div_t_ptr_ptr { return new div_t_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): div_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): div_t { return new div_t($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return div_t[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new div_t($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "quot": return $this->data[0]->quot;
            case "rem": return $this->data[0]->rem;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "quot":
                $this->data[0]->quot = $value;
                break;
            case "rem":
                $this->data[0]->rem = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | div_t_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'div_t*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class div_t_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(div_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): div_t_ptr_ptr_ptr { return new div_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): div_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): div_t_ptr { return new div_t_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return div_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new div_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new div_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | div_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'div_t**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class div_t_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(div_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): div_t_ptr_ptr_ptr_ptr { return new div_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): div_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): div_t_ptr_ptr { return new div_t_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return div_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new div_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new div_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | div_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'div_t***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class div_t_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(div_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): div_t_ptr_ptr_ptr_ptr_ptr { return new div_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): div_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): div_t_ptr_ptr_ptr { return new div_t_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return div_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new div_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new div_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | div_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'div_t****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $quot
 * @property int $rem
 */
class ldiv_t implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(ldiv_t $other): bool { return $this->data == $other->data; }
    public function addr(): ldiv_t_ptr { return new ldiv_t_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "quot": return $this->data->quot;
            case "rem": return $this->data->rem;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "quot":
                $this->data->quot = $value;
                break;
            case "rem":
                $this->data->rem = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(ldiv_t $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'ldiv_t'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $quot
 * @property int $rem
 */
class ldiv_t_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(ldiv_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): ldiv_t_ptr_ptr { return new ldiv_t_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): ldiv_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): ldiv_t { return new ldiv_t($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return ldiv_t[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new ldiv_t($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "quot": return $this->data[0]->quot;
            case "rem": return $this->data[0]->rem;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "quot":
                $this->data[0]->quot = $value;
                break;
            case "rem":
                $this->data[0]->rem = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | ldiv_t_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'ldiv_t*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class ldiv_t_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(ldiv_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): ldiv_t_ptr_ptr_ptr { return new ldiv_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): ldiv_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): ldiv_t_ptr { return new ldiv_t_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return ldiv_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new ldiv_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new ldiv_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | ldiv_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'ldiv_t**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class ldiv_t_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(ldiv_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): ldiv_t_ptr_ptr_ptr_ptr { return new ldiv_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): ldiv_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): ldiv_t_ptr_ptr { return new ldiv_t_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return ldiv_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new ldiv_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new ldiv_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | ldiv_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'ldiv_t***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class ldiv_t_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(ldiv_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): ldiv_t_ptr_ptr_ptr_ptr_ptr { return new ldiv_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): ldiv_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): ldiv_t_ptr_ptr_ptr { return new ldiv_t_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return ldiv_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new ldiv_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new ldiv_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | ldiv_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'ldiv_t****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $quot
 * @property int $rem
 */
class lldiv_t implements iExtism {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(lldiv_t $other): bool { return $this->data == $other->data; }
    public function addr(): lldiv_t_ptr { return new lldiv_t_ptr(FFI::addr($this->data)); }
    public function __get($prop) {
        switch ($prop) {
            case "quot": return $this->data->quot;
            case "rem": return $this->data->rem;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "quot":
                $this->data->quot = $value;
                break;
            case "rem":
                $this->data->rem = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(lldiv_t $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'lldiv_t'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
/**
 * @property int $quot
 * @property int $rem
 */
class lldiv_t_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(lldiv_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): lldiv_t_ptr_ptr { return new lldiv_t_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): lldiv_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): lldiv_t { return new lldiv_t($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return lldiv_t[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = new lldiv_t($this->data[$i]); } return $ret; }
    public function __get($prop) {
        switch ($prop) {
            case "quot": return $this->data[0]->quot;
            case "rem": return $this->data[0]->rem;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function __set($prop, $value) {
        switch ($prop) {
            case "quot":
                $this->data[0]->quot = $value;
                break;
            case "rem":
                $this->data[0]->rem = $value;
                break;
        }
        throw new \Error("Unknown field $prop on type " . self::getType());
    }
    public function set(void_ptr | lldiv_t_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'lldiv_t*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class lldiv_t_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(lldiv_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): lldiv_t_ptr_ptr_ptr { return new lldiv_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): lldiv_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): lldiv_t_ptr { return new lldiv_t_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return lldiv_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new lldiv_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new lldiv_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | lldiv_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'lldiv_t**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class lldiv_t_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(lldiv_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): lldiv_t_ptr_ptr_ptr_ptr { return new lldiv_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): lldiv_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): lldiv_t_ptr_ptr { return new lldiv_t_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return lldiv_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new lldiv_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new lldiv_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | lldiv_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'lldiv_t***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class lldiv_t_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(lldiv_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): lldiv_t_ptr_ptr_ptr_ptr_ptr { return new lldiv_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): lldiv_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): lldiv_t_ptr_ptr_ptr { return new lldiv_t_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return lldiv_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new lldiv_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new lldiv_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | lldiv_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'lldiv_t****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class _Bool_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(_Bool_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): _Bool_ptr_ptr { return new _Bool_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): _Bool { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value; }
    public function deref(int $n = 0): int { return $this->data[$n]; }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return int[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = ($this->data[$i]); } return $ret; }
    public function set(int | void_ptr | _Bool_ptr $value): void {
        if (\is_scalar($value)) {
            $this->data[0] = $value;
        } else {
            FFI::addr($this->data)[0] = $value->getData();
        }
    }
    public static function getType(): string { return '_Bool*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class _Bool_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(_Bool_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): _Bool_ptr_ptr_ptr { return new _Bool_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): _Bool_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): _Bool_ptr { return new _Bool_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return _Bool_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new _Bool_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new _Bool_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | _Bool_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '_Bool**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class _Bool_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(_Bool_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): _Bool_ptr_ptr_ptr_ptr { return new _Bool_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): _Bool_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): _Bool_ptr_ptr { return new _Bool_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return _Bool_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new _Bool_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new _Bool_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | _Bool_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '_Bool***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class _Bool_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(_Bool_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): _Bool_ptr_ptr_ptr_ptr_ptr { return new _Bool_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): _Bool_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): _Bool_ptr_ptr_ptr { return new _Bool_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return _Bool_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new _Bool_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new _Bool_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | _Bool_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return '_Bool****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
\class_alias(__NAMESPACE__ . "\\_Bool_ptr", __NAMESPACE__ . "\\uint8_t_ptr");
\class_alias(__NAMESPACE__ . "\\_Bool_ptr_ptr", __NAMESPACE__ . "\\uint8_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\_Bool_ptr_ptr_ptr", __NAMESPACE__ . "\\uint8_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\_Bool_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\uint8_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\_Bool_ptr", __NAMESPACE__ . "\\unsigned_char_ptr");
\class_alias(__NAMESPACE__ . "\\_Bool_ptr_ptr", __NAMESPACE__ . "\\unsigned_char_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\_Bool_ptr_ptr_ptr", __NAMESPACE__ . "\\unsigned_char_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\_Bool_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\unsigned_char_ptr_ptr_ptr_ptr");
class int8_t_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int8_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int8_t_ptr_ptr { return new int8_t_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int8_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value; }
    public function deref(int $n = 0): int { return $this->data[$n]; }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return int[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = ($this->data[$i]); } return $ret; }
    public function set(int | void_ptr | int8_t_ptr $value): void {
        if (\is_scalar($value)) {
            $this->data[0] = $value;
        } else {
            FFI::addr($this->data)[0] = $value->getData();
        }
    }
    public static function getType(): string { return 'int8_t*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int8_t_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int8_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int8_t_ptr_ptr_ptr { return new int8_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int8_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): int8_t_ptr { return new int8_t_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return int8_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int8_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int8_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int8_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int8_t**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int8_t_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int8_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int8_t_ptr_ptr_ptr_ptr { return new int8_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int8_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): int8_t_ptr_ptr { return new int8_t_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return int8_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int8_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int8_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int8_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int8_t***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int8_t_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int8_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int8_t_ptr_ptr_ptr_ptr_ptr { return new int8_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int8_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): int8_t_ptr_ptr_ptr { return new int8_t_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return int8_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int8_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int8_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int8_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int8_t****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int16_t_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int16_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int16_t_ptr_ptr { return new int16_t_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int16_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value; }
    public function deref(int $n = 0): int { return $this->data[$n]; }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return int[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = ($this->data[$i]); } return $ret; }
    public function set(int | void_ptr | int16_t_ptr $value): void {
        if (\is_scalar($value)) {
            $this->data[0] = $value;
        } else {
            FFI::addr($this->data)[0] = $value->getData();
        }
    }
    public static function getType(): string { return 'int16_t*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int16_t_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int16_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int16_t_ptr_ptr_ptr { return new int16_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int16_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): int16_t_ptr { return new int16_t_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return int16_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int16_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int16_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int16_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int16_t**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int16_t_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int16_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int16_t_ptr_ptr_ptr_ptr { return new int16_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int16_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): int16_t_ptr_ptr { return new int16_t_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return int16_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int16_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int16_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int16_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int16_t***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int16_t_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int16_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int16_t_ptr_ptr_ptr_ptr_ptr { return new int16_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int16_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): int16_t_ptr_ptr_ptr { return new int16_t_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return int16_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int16_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int16_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int16_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int16_t****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
\class_alias(__NAMESPACE__ . "\\int16_t_ptr", __NAMESPACE__ . "\\short_ptr");
\class_alias(__NAMESPACE__ . "\\int16_t_ptr_ptr", __NAMESPACE__ . "\\short_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int16_t_ptr_ptr_ptr", __NAMESPACE__ . "\\short_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int16_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\short_ptr_ptr_ptr_ptr");
class uint16_t_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint16_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint16_t_ptr_ptr { return new uint16_t_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): uint16_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value; }
    public function deref(int $n = 0): int { return $this->data[$n]; }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return int[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = ($this->data[$i]); } return $ret; }
    public function set(int | void_ptr | uint16_t_ptr $value): void {
        if (\is_scalar($value)) {
            $this->data[0] = $value;
        } else {
            FFI::addr($this->data)[0] = $value->getData();
        }
    }
    public static function getType(): string { return 'uint16_t*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class uint16_t_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint16_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint16_t_ptr_ptr_ptr { return new uint16_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): uint16_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): uint16_t_ptr { return new uint16_t_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return uint16_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new uint16_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new uint16_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | uint16_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'uint16_t**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class uint16_t_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint16_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint16_t_ptr_ptr_ptr_ptr { return new uint16_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): uint16_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): uint16_t_ptr_ptr { return new uint16_t_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return uint16_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new uint16_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new uint16_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | uint16_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'uint16_t***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class uint16_t_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint16_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint16_t_ptr_ptr_ptr_ptr_ptr { return new uint16_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): uint16_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): uint16_t_ptr_ptr_ptr { return new uint16_t_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return uint16_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new uint16_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new uint16_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | uint16_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'uint16_t****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
\class_alias(__NAMESPACE__ . "\\uint16_t_ptr", __NAMESPACE__ . "\\unsigned_short_ptr");
\class_alias(__NAMESPACE__ . "\\uint16_t_ptr_ptr", __NAMESPACE__ . "\\unsigned_short_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint16_t_ptr_ptr_ptr", __NAMESPACE__ . "\\unsigned_short_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint16_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\unsigned_short_ptr_ptr_ptr_ptr");
class int32_t_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int32_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int32_t_ptr_ptr { return new int32_t_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int32_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value; }
    public function deref(int $n = 0): int { return $this->data[$n]; }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return int[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = ($this->data[$i]); } return $ret; }
    public function set(int | void_ptr | int32_t_ptr $value): void {
        if (\is_scalar($value)) {
            $this->data[0] = $value;
        } else {
            FFI::addr($this->data)[0] = $value->getData();
        }
    }
    public static function getType(): string { return 'int32_t*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int32_t_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int32_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int32_t_ptr_ptr_ptr { return new int32_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int32_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): int32_t_ptr { return new int32_t_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return int32_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int32_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int32_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int32_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int32_t**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int32_t_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int32_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int32_t_ptr_ptr_ptr_ptr { return new int32_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int32_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): int32_t_ptr_ptr { return new int32_t_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return int32_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int32_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int32_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int32_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int32_t***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int32_t_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int32_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int32_t_ptr_ptr_ptr_ptr_ptr { return new int32_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int32_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): int32_t_ptr_ptr_ptr { return new int32_t_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return int32_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int32_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int32_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int32_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int32_t****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
\class_alias(__NAMESPACE__ . "\\int32_t_ptr", __NAMESPACE__ . "\\int_ptr");
\class_alias(__NAMESPACE__ . "\\int32_t_ptr_ptr", __NAMESPACE__ . "\\int_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int32_t_ptr_ptr_ptr", __NAMESPACE__ . "\\int_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int32_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\int_ptr_ptr_ptr_ptr");
class uint32_t_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint32_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint32_t_ptr_ptr { return new uint32_t_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): uint32_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value; }
    public function deref(int $n = 0): int { return $this->data[$n]; }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return int[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = ($this->data[$i]); } return $ret; }
    public function set(int | void_ptr | uint32_t_ptr $value): void {
        if (\is_scalar($value)) {
            $this->data[0] = $value;
        } else {
            FFI::addr($this->data)[0] = $value->getData();
        }
    }
    public static function getType(): string { return 'uint32_t*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class uint32_t_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint32_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint32_t_ptr_ptr_ptr { return new uint32_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): uint32_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): uint32_t_ptr { return new uint32_t_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return uint32_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new uint32_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new uint32_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | uint32_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'uint32_t**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class uint32_t_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint32_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint32_t_ptr_ptr_ptr_ptr { return new uint32_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): uint32_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): uint32_t_ptr_ptr { return new uint32_t_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return uint32_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new uint32_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new uint32_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | uint32_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'uint32_t***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class uint32_t_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint32_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint32_t_ptr_ptr_ptr_ptr_ptr { return new uint32_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): uint32_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): uint32_t_ptr_ptr_ptr { return new uint32_t_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return uint32_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new uint32_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new uint32_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | uint32_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'uint32_t****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
\class_alias(__NAMESPACE__ . "\\uint32_t_ptr", __NAMESPACE__ . "\\unsigned_int_ptr");
\class_alias(__NAMESPACE__ . "\\uint32_t_ptr_ptr", __NAMESPACE__ . "\\unsigned_int_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint32_t_ptr_ptr_ptr", __NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint32_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr_ptr");
class int64_t_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int64_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int64_t_ptr_ptr { return new int64_t_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int64_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value; }
    public function deref(int $n = 0): int { return $this->data[$n]; }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return int[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = ($this->data[$i]); } return $ret; }
    public function set(int | void_ptr | int64_t_ptr $value): void {
        if (\is_scalar($value)) {
            $this->data[0] = $value;
        } else {
            FFI::addr($this->data)[0] = $value->getData();
        }
    }
    public static function getType(): string { return 'int64_t*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int64_t_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int64_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int64_t_ptr_ptr_ptr { return new int64_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int64_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): int64_t_ptr { return new int64_t_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return int64_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int64_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int64_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int64_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int64_t**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int64_t_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int64_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int64_t_ptr_ptr_ptr_ptr { return new int64_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int64_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): int64_t_ptr_ptr { return new int64_t_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return int64_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int64_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int64_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int64_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int64_t***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class int64_t_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(int64_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): int64_t_ptr_ptr_ptr_ptr_ptr { return new int64_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): int64_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): int64_t_ptr_ptr_ptr { return new int64_t_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return int64_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new int64_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new int64_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | int64_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'int64_t****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
\class_alias(__NAMESPACE__ . "\\int64_t_ptr", __NAMESPACE__ . "\\size_t_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr", __NAMESPACE__ . "\\size_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr_ptr", __NAMESPACE__ . "\\size_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\size_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr", __NAMESPACE__ . "\\long_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr", __NAMESPACE__ . "\\long_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr_ptr", __NAMESPACE__ . "\\long_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\long_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr", __NAMESPACE__ . "\\long_long_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr", __NAMESPACE__ . "\\long_long_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr_ptr", __NAMESPACE__ . "\\long_long_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\long_long_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr", __NAMESPACE__ . "\\long_int_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr", __NAMESPACE__ . "\\long_int_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr_ptr", __NAMESPACE__ . "\\long_int_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\long_int_ptr_ptr_ptr_ptr");
class uint64_t_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint64_t_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint64_t_ptr_ptr { return new uint64_t_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): uint64_t { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value; }
    public function deref(int $n = 0): int { return $this->data[$n]; }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return int[] */ public function toArray(int $length): array { $ret = []; for ($i = 0; $i < $length; ++$i) { $ret[] = ($this->data[$i]); } return $ret; }
    public function set(int | void_ptr | uint64_t_ptr $value): void {
        if (\is_scalar($value)) {
            $this->data[0] = $value;
        } else {
            FFI::addr($this->data)[0] = $value->getData();
        }
    }
    public static function getType(): string { return 'uint64_t*'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class uint64_t_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint64_t_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint64_t_ptr_ptr_ptr { return new uint64_t_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): uint64_t_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): uint64_t_ptr { return new uint64_t_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return uint64_t_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new uint64_t_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new uint64_t_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | uint64_t_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'uint64_t**'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class uint64_t_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint64_t_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint64_t_ptr_ptr_ptr_ptr { return new uint64_t_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): uint64_t_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): uint64_t_ptr_ptr { return new uint64_t_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return uint64_t_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new uint64_t_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new uint64_t_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | uint64_t_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'uint64_t***'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
class uint64_t_ptr_ptr_ptr_ptr implements iExtism, iExtism_ptr, \ArrayAccess {
    private FFI\CData $data;
    public function __construct(FFI\CData $data) { $this->data = $data; }
    public static function castFrom(iExtism $data): self { return Extism::cast($data, self::class); }
    public function getData(): FFI\CData { return $this->data; }
    public function equals(uint64_t_ptr_ptr_ptr_ptr $other): bool { return $this->data == $other->data; }
    public function addr(): uint64_t_ptr_ptr_ptr_ptr_ptr { return new uint64_t_ptr_ptr_ptr_ptr_ptr(FFI::addr($this->data)); }
    #[\ReturnTypeWillChange] public function offsetGet($offset): uint64_t_ptr_ptr_ptr { return $this->deref($offset); }
    #[\ReturnTypeWillChange] public function offsetExists($offset): bool { return !FFI::isNull($this->data); }
    #[\ReturnTypeWillChange] public function offsetUnset($offset): void { throw new \Error("Cannot unset C structures"); }
    #[\ReturnTypeWillChange] public function offsetSet($offset, $value): void { $this->data[$offset] = $value->getData(); }
    public function deref(int $n = 0): uint64_t_ptr_ptr_ptr { return new uint64_t_ptr_ptr_ptr($this->data[$n]); }
    public static function array(int $size = 1): self { return Extism::makeArray(self::class, $size); }
    /** @return uint64_t_ptr_ptr_ptr[] */ public function toArray(?int $length = null): array { $ret = []; if ($length === null) { $i = 0; while (null !== $cur = $this->data[$i++]) { $ret[] = new uint64_t_ptr_ptr_ptr($cur); } } else { for ($i = 0; $i < $length; ++$i) { $ret[] = new uint64_t_ptr_ptr_ptr($this->data[$i]); } } return $ret; }
    public function set(void_ptr | uint64_t_ptr_ptr_ptr_ptr $value): void {
        FFI::addr($this->data)[0] = $value->getData();
    }
    public static function getType(): string { return 'uint64_t****'; }
    public static function size(): int { return Extism::sizeof(self::class); }
    public function getDefinition(): string { return static::getType(); }
}
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr", __NAMESPACE__ . "\\unsigned_long_ptr");
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr_ptr", __NAMESPACE__ . "\\unsigned_long_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr_ptr_ptr", __NAMESPACE__ . "\\unsigned_long_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\unsigned_long_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr", __NAMESPACE__ . "\\unsigned_long_int_ptr");
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr_ptr", __NAMESPACE__ . "\\unsigned_long_int_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr_ptr_ptr", __NAMESPACE__ . "\\unsigned_long_int_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\unsigned_long_int_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr", __NAMESPACE__ . "\\unsigned_long_long_ptr");
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr_ptr", __NAMESPACE__ . "\\unsigned_long_long_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr_ptr_ptr", __NAMESPACE__ . "\\unsigned_long_long_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\unsigned_long_long_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\__builtin_va_list", __NAMESPACE__ . "\\va_list");
\class_alias(__NAMESPACE__ . "\\__builtin_va_list_ptr", __NAMESPACE__ . "\\va_list_ptr");
\class_alias(__NAMESPACE__ . "\\__builtin_va_list_ptr_ptr", __NAMESPACE__ . "\\va_list_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\__builtin_va_list_ptr_ptr_ptr", __NAMESPACE__ . "\\va_list_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\__builtin_va_list_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\va_list_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int8_t_ptr", __NAMESPACE__ . "\\int_least8_t_ptr");
\class_alias(__NAMESPACE__ . "\\int8_t_ptr_ptr", __NAMESPACE__ . "\\int_least8_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int8_t_ptr_ptr_ptr", __NAMESPACE__ . "\\int_least8_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int8_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\int_least8_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int16_t_ptr", __NAMESPACE__ . "\\int_least16_t_ptr");
\class_alias(__NAMESPACE__ . "\\int16_t_ptr_ptr", __NAMESPACE__ . "\\int_least16_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int16_t_ptr_ptr_ptr", __NAMESPACE__ . "\\int_least16_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int16_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\int_least16_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int32_t_ptr", __NAMESPACE__ . "\\int_least32_t_ptr");
\class_alias(__NAMESPACE__ . "\\int32_t_ptr_ptr", __NAMESPACE__ . "\\int_least32_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int32_t_ptr_ptr_ptr", __NAMESPACE__ . "\\int_least32_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int32_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\int_least32_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr", __NAMESPACE__ . "\\int_least64_t_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr", __NAMESPACE__ . "\\int_least64_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr_ptr", __NAMESPACE__ . "\\int_least64_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\int_least64_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint8_t_ptr", __NAMESPACE__ . "\\uint_least8_t_ptr");
\class_alias(__NAMESPACE__ . "\\uint8_t_ptr_ptr", __NAMESPACE__ . "\\uint_least8_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint8_t_ptr_ptr_ptr", __NAMESPACE__ . "\\uint_least8_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint8_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\uint_least8_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint16_t_ptr", __NAMESPACE__ . "\\uint_least16_t_ptr");
\class_alias(__NAMESPACE__ . "\\uint16_t_ptr_ptr", __NAMESPACE__ . "\\uint_least16_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint16_t_ptr_ptr_ptr", __NAMESPACE__ . "\\uint_least16_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint16_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\uint_least16_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint32_t_ptr", __NAMESPACE__ . "\\uint_least32_t_ptr");
\class_alias(__NAMESPACE__ . "\\uint32_t_ptr_ptr", __NAMESPACE__ . "\\uint_least32_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint32_t_ptr_ptr_ptr", __NAMESPACE__ . "\\uint_least32_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint32_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\uint_least32_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr", __NAMESPACE__ . "\\uint_least64_t_ptr");
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr_ptr", __NAMESPACE__ . "\\uint_least64_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr_ptr_ptr", __NAMESPACE__ . "\\uint_least64_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\uint_least64_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int8_t_ptr", __NAMESPACE__ . "\\int_fast8_t_ptr");
\class_alias(__NAMESPACE__ . "\\int8_t_ptr_ptr", __NAMESPACE__ . "\\int_fast8_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int8_t_ptr_ptr_ptr", __NAMESPACE__ . "\\int_fast8_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int8_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\int_fast8_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int16_t_ptr", __NAMESPACE__ . "\\int_fast16_t_ptr");
\class_alias(__NAMESPACE__ . "\\int16_t_ptr_ptr", __NAMESPACE__ . "\\int_fast16_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int16_t_ptr_ptr_ptr", __NAMESPACE__ . "\\int_fast16_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int16_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\int_fast16_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int32_t_ptr", __NAMESPACE__ . "\\int_fast32_t_ptr");
\class_alias(__NAMESPACE__ . "\\int32_t_ptr_ptr", __NAMESPACE__ . "\\int_fast32_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int32_t_ptr_ptr_ptr", __NAMESPACE__ . "\\int_fast32_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int32_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\int_fast32_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr", __NAMESPACE__ . "\\int_fast64_t_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr", __NAMESPACE__ . "\\int_fast64_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr_ptr", __NAMESPACE__ . "\\int_fast64_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\int_fast64_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint8_t_ptr", __NAMESPACE__ . "\\uint_fast8_t_ptr");
\class_alias(__NAMESPACE__ . "\\uint8_t_ptr_ptr", __NAMESPACE__ . "\\uint_fast8_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint8_t_ptr_ptr_ptr", __NAMESPACE__ . "\\uint_fast8_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint8_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\uint_fast8_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint16_t_ptr", __NAMESPACE__ . "\\uint_fast16_t_ptr");
\class_alias(__NAMESPACE__ . "\\uint16_t_ptr_ptr", __NAMESPACE__ . "\\uint_fast16_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint16_t_ptr_ptr_ptr", __NAMESPACE__ . "\\uint_fast16_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint16_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\uint_fast16_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint32_t_ptr", __NAMESPACE__ . "\\uint_fast32_t_ptr");
\class_alias(__NAMESPACE__ . "\\uint32_t_ptr_ptr", __NAMESPACE__ . "\\uint_fast32_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint32_t_ptr_ptr_ptr", __NAMESPACE__ . "\\uint_fast32_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint32_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\uint_fast32_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr", __NAMESPACE__ . "\\uint_fast64_t_ptr");
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr_ptr", __NAMESPACE__ . "\\uint_fast64_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr_ptr_ptr", __NAMESPACE__ . "\\uint_fast64_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\uint_fast64_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\string_", __NAMESPACE__ . "\\__int8_t_ptr");
\class_alias(__NAMESPACE__ . "\\string_ptr", __NAMESPACE__ . "\\__int8_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\string_ptr_ptr", __NAMESPACE__ . "\\__int8_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\string_ptr_ptr_ptr", __NAMESPACE__ . "\\__int8_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_char_ptr", __NAMESPACE__ . "\\__uint8_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_char_ptr_ptr", __NAMESPACE__ . "\\__uint8_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_char_ptr_ptr_ptr", __NAMESPACE__ . "\\__uint8_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_char_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__uint8_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\short_ptr", __NAMESPACE__ . "\\__int16_t_ptr");
\class_alias(__NAMESPACE__ . "\\short_ptr_ptr", __NAMESPACE__ . "\\__int16_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\short_ptr_ptr_ptr", __NAMESPACE__ . "\\__int16_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\short_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__int16_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_short_ptr", __NAMESPACE__ . "\\__uint16_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_short_ptr_ptr", __NAMESPACE__ . "\\__uint16_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_short_ptr_ptr_ptr", __NAMESPACE__ . "\\__uint16_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_short_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__uint16_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr", __NAMESPACE__ . "\\__int32_t_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr", __NAMESPACE__ . "\\__int32_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr", __NAMESPACE__ . "\\__int32_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__int32_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr", __NAMESPACE__ . "\\__uint32_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr", __NAMESPACE__ . "\\__uint32_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr", __NAMESPACE__ . "\\__uint32_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__uint32_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_long_ptr", __NAMESPACE__ . "\\__int64_t_ptr");
\class_alias(__NAMESPACE__ . "\\long_long_ptr_ptr", __NAMESPACE__ . "\\__int64_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_long_ptr_ptr_ptr", __NAMESPACE__ . "\\__int64_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_long_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__int64_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr", __NAMESPACE__ . "\\__uint64_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr", __NAMESPACE__ . "\\__uint64_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr_ptr", __NAMESPACE__ . "\\__uint64_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__uint64_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_ptr", __NAMESPACE__ . "\\__darwin_intptr_t_ptr");
\class_alias(__NAMESPACE__ . "\\long_ptr_ptr", __NAMESPACE__ . "\\__darwin_intptr_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_intptr_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_intptr_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr", __NAMESPACE__ . "\\__darwin_natural_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr", __NAMESPACE__ . "\\__darwin_natural_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_natural_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_natural_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr", __NAMESPACE__ . "\\__darwin_ct_rune_t_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr", __NAMESPACE__ . "\\__darwin_ct_rune_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_ct_rune_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_ct_rune_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\__mbstate_t", __NAMESPACE__ . "\\__darwin_mbstate_t");
\class_alias(__NAMESPACE__ . "\\__mbstate_t_ptr", __NAMESPACE__ . "\\__darwin_mbstate_t_ptr");
\class_alias(__NAMESPACE__ . "\\__mbstate_t_ptr_ptr", __NAMESPACE__ . "\\__darwin_mbstate_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\__mbstate_t_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_mbstate_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\__mbstate_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_mbstate_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_int_ptr", __NAMESPACE__ . "\\__darwin_ptrdiff_t_ptr");
\class_alias(__NAMESPACE__ . "\\long_int_ptr_ptr", __NAMESPACE__ . "\\__darwin_ptrdiff_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_ptrdiff_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_ptrdiff_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_int_ptr", __NAMESPACE__ . "\\__darwin_size_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_int_ptr_ptr", __NAMESPACE__ . "\\__darwin_size_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_size_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_size_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\__builtin_va_list", __NAMESPACE__ . "\\__darwin_va_list");
\class_alias(__NAMESPACE__ . "\\__builtin_va_list_ptr", __NAMESPACE__ . "\\__darwin_va_list_ptr");
\class_alias(__NAMESPACE__ . "\\__builtin_va_list_ptr_ptr", __NAMESPACE__ . "\\__darwin_va_list_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\__builtin_va_list_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_va_list_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\__builtin_va_list_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_va_list_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr", __NAMESPACE__ . "\\__darwin_wchar_t_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr", __NAMESPACE__ . "\\__darwin_wchar_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_wchar_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_wchar_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr", __NAMESPACE__ . "\\__darwin_rune_t_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr", __NAMESPACE__ . "\\__darwin_rune_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_rune_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_rune_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr", __NAMESPACE__ . "\\__darwin_wint_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr", __NAMESPACE__ . "\\__darwin_wint_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_wint_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_wint_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_ptr", __NAMESPACE__ . "\\__darwin_clock_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_ptr_ptr", __NAMESPACE__ . "\\__darwin_clock_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_clock_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_clock_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr", __NAMESPACE__ . "\\__darwin_socklen_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr", __NAMESPACE__ . "\\__darwin_socklen_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_socklen_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_socklen_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_ptr", __NAMESPACE__ . "\\__darwin_ssize_t_ptr");
\class_alias(__NAMESPACE__ . "\\long_ptr_ptr", __NAMESPACE__ . "\\__darwin_ssize_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_ssize_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_ssize_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_ptr", __NAMESPACE__ . "\\__darwin_time_t_ptr");
\class_alias(__NAMESPACE__ . "\\long_ptr_ptr", __NAMESPACE__ . "\\__darwin_time_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_time_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_time_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_long_ptr", __NAMESPACE__ . "\\__darwin_blkcnt_t_ptr");
\class_alias(__NAMESPACE__ . "\\long_long_ptr_ptr", __NAMESPACE__ . "\\__darwin_blkcnt_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_long_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_blkcnt_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_long_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_blkcnt_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr", __NAMESPACE__ . "\\__darwin_blksize_t_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr", __NAMESPACE__ . "\\__darwin_blksize_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_blksize_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_blksize_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr", __NAMESPACE__ . "\\__darwin_dev_t_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr", __NAMESPACE__ . "\\__darwin_dev_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_dev_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_dev_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr", __NAMESPACE__ . "\\__darwin_fsblkcnt_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr", __NAMESPACE__ . "\\__darwin_fsblkcnt_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_fsblkcnt_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_fsblkcnt_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr", __NAMESPACE__ . "\\__darwin_fsfilcnt_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr", __NAMESPACE__ . "\\__darwin_fsfilcnt_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_fsfilcnt_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_fsfilcnt_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr", __NAMESPACE__ . "\\__darwin_gid_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr", __NAMESPACE__ . "\\__darwin_gid_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_gid_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_gid_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr", __NAMESPACE__ . "\\__darwin_id_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr", __NAMESPACE__ . "\\__darwin_id_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_id_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_id_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr", __NAMESPACE__ . "\\__darwin_ino64_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr", __NAMESPACE__ . "\\__darwin_ino64_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_ino64_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_ino64_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr", __NAMESPACE__ . "\\__darwin_ino_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr", __NAMESPACE__ . "\\__darwin_ino_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_ino_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_ino_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr", __NAMESPACE__ . "\\__darwin_mach_port_name_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr", __NAMESPACE__ . "\\__darwin_mach_port_name_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_mach_port_name_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_mach_port_name_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr", __NAMESPACE__ . "\\__darwin_mach_port_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr", __NAMESPACE__ . "\\__darwin_mach_port_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_mach_port_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_mach_port_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_short_ptr", __NAMESPACE__ . "\\__darwin_mode_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_short_ptr_ptr", __NAMESPACE__ . "\\__darwin_mode_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_short_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_mode_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_short_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_mode_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_long_ptr", __NAMESPACE__ . "\\__darwin_off_t_ptr");
\class_alias(__NAMESPACE__ . "\\long_long_ptr_ptr", __NAMESPACE__ . "\\__darwin_off_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_long_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_off_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_long_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_off_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr", __NAMESPACE__ . "\\__darwin_pid_t_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr", __NAMESPACE__ . "\\__darwin_pid_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_pid_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_pid_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr", __NAMESPACE__ . "\\__darwin_sigset_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr", __NAMESPACE__ . "\\__darwin_sigset_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_sigset_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_sigset_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr", __NAMESPACE__ . "\\__darwin_suseconds_t_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr", __NAMESPACE__ . "\\__darwin_suseconds_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_suseconds_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_suseconds_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr", __NAMESPACE__ . "\\__darwin_uid_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr", __NAMESPACE__ . "\\__darwin_uid_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_uid_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_uid_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr", __NAMESPACE__ . "\\__darwin_useconds_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr", __NAMESPACE__ . "\\__darwin_useconds_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_useconds_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_useconds_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_char_ptr", __NAMESPACE__ . "\\__darwin_uuid_t");
\class_alias(__NAMESPACE__ . "\\unsigned_char_ptr_ptr", __NAMESPACE__ . "\\__darwin_uuid_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_char_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_uuid_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_char_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_uuid_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\string_", __NAMESPACE__ . "\\__darwin_uuid_string_t");
\class_alias(__NAMESPACE__ . "\\string_ptr", __NAMESPACE__ . "\\__darwin_uuid_string_t_ptr");
\class_alias(__NAMESPACE__ . "\\string_ptr_ptr", __NAMESPACE__ . "\\__darwin_uuid_string_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\string_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_uuid_string_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_attr_t", __NAMESPACE__ . "\\__darwin_pthread_attr_t");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_attr_t_ptr", __NAMESPACE__ . "\\__darwin_pthread_attr_t_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_attr_t_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_attr_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_attr_t_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_attr_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_attr_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_attr_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_cond_t", __NAMESPACE__ . "\\__darwin_pthread_cond_t");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_cond_t_ptr", __NAMESPACE__ . "\\__darwin_pthread_cond_t_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_cond_t_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_cond_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_cond_t_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_cond_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_cond_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_cond_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_condattr_t", __NAMESPACE__ . "\\__darwin_pthread_condattr_t");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_condattr_t_ptr", __NAMESPACE__ . "\\__darwin_pthread_condattr_t_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_condattr_t_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_condattr_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_condattr_t_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_condattr_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_condattr_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_condattr_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_ptr", __NAMESPACE__ . "\\__darwin_pthread_key_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_key_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_key_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_key_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_mutex_t", __NAMESPACE__ . "\\__darwin_pthread_mutex_t");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_mutex_t_ptr", __NAMESPACE__ . "\\__darwin_pthread_mutex_t_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_mutex_t_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_mutex_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_mutex_t_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_mutex_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_mutex_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_mutex_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_mutexattr_t", __NAMESPACE__ . "\\__darwin_pthread_mutexattr_t");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_mutexattr_t_ptr", __NAMESPACE__ . "\\__darwin_pthread_mutexattr_t_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_mutexattr_t_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_mutexattr_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_mutexattr_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_mutexattr_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_mutexattr_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_once_t", __NAMESPACE__ . "\\__darwin_pthread_once_t");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_once_t_ptr", __NAMESPACE__ . "\\__darwin_pthread_once_t_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_once_t_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_once_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_once_t_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_once_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_once_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_once_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_rwlock_t", __NAMESPACE__ . "\\__darwin_pthread_rwlock_t");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_rwlock_t_ptr", __NAMESPACE__ . "\\__darwin_pthread_rwlock_t_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_rwlock_t_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_rwlock_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_rwlock_t_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_rwlock_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_rwlock_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_rwlock_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_rwlockattr_t", __NAMESPACE__ . "\\__darwin_pthread_rwlockattr_t");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_rwlockattr_t_ptr", __NAMESPACE__ . "\\__darwin_pthread_rwlockattr_t_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_rwlockattr_t_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_rwlockattr_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_rwlockattr_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_rwlockattr_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_rwlockattr_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_t_ptr", __NAMESPACE__ . "\\__darwin_pthread_t");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_t_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_t_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_t_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_pthread_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_char_ptr", __NAMESPACE__ . "\\u_int8_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_char_ptr_ptr", __NAMESPACE__ . "\\u_int8_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_char_ptr_ptr_ptr", __NAMESPACE__ . "\\u_int8_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_char_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\u_int8_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_short_ptr", __NAMESPACE__ . "\\u_int16_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_short_ptr_ptr", __NAMESPACE__ . "\\u_int16_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_short_ptr_ptr_ptr", __NAMESPACE__ . "\\u_int16_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_short_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\u_int16_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr", __NAMESPACE__ . "\\u_int32_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr", __NAMESPACE__ . "\\u_int32_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr", __NAMESPACE__ . "\\u_int32_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\u_int32_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr", __NAMESPACE__ . "\\u_int64_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr", __NAMESPACE__ . "\\u_int64_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr_ptr", __NAMESPACE__ . "\\u_int64_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\u_int64_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr", __NAMESPACE__ . "\\register_t_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr", __NAMESPACE__ . "\\register_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr_ptr", __NAMESPACE__ . "\\register_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\register_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_ptr", __NAMESPACE__ . "\\uintptr_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_ptr_ptr", __NAMESPACE__ . "\\uintptr_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_ptr_ptr_ptr", __NAMESPACE__ . "\\uintptr_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\uintptr_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr", __NAMESPACE__ . "\\user_addr_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr", __NAMESPACE__ . "\\user_addr_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr_ptr", __NAMESPACE__ . "\\user_addr_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\user_addr_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr", __NAMESPACE__ . "\\user_size_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr", __NAMESPACE__ . "\\user_size_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr_ptr", __NAMESPACE__ . "\\user_size_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\user_size_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr", __NAMESPACE__ . "\\user_ssize_t_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr", __NAMESPACE__ . "\\user_ssize_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr_ptr", __NAMESPACE__ . "\\user_ssize_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\user_ssize_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr", __NAMESPACE__ . "\\user_long_t_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr", __NAMESPACE__ . "\\user_long_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr_ptr", __NAMESPACE__ . "\\user_long_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\user_long_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr", __NAMESPACE__ . "\\user_ulong_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr", __NAMESPACE__ . "\\user_ulong_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr_ptr", __NAMESPACE__ . "\\user_ulong_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\user_ulong_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr", __NAMESPACE__ . "\\user_time_t_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr", __NAMESPACE__ . "\\user_time_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr_ptr", __NAMESPACE__ . "\\user_time_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\user_time_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr", __NAMESPACE__ . "\\user_off_t_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr", __NAMESPACE__ . "\\user_off_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr_ptr", __NAMESPACE__ . "\\user_off_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int64_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\user_off_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr", __NAMESPACE__ . "\\syscall_arg_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr", __NAMESPACE__ . "\\syscall_arg_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr_ptr", __NAMESPACE__ . "\\syscall_arg_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\syscall_arg_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_ptr", __NAMESPACE__ . "\\intptr_t_ptr");
\class_alias(__NAMESPACE__ . "\\long_ptr_ptr", __NAMESPACE__ . "\\intptr_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_ptr_ptr_ptr", __NAMESPACE__ . "\\intptr_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\intptr_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_int_ptr", __NAMESPACE__ . "\\intmax_t_ptr");
\class_alias(__NAMESPACE__ . "\\long_int_ptr_ptr", __NAMESPACE__ . "\\intmax_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_int_ptr_ptr_ptr", __NAMESPACE__ . "\\intmax_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\long_int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\intmax_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_int_ptr", __NAMESPACE__ . "\\uintmax_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_int_ptr_ptr", __NAMESPACE__ . "\\uintmax_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_int_ptr_ptr_ptr", __NAMESPACE__ . "\\uintmax_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\uintmax_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr", __NAMESPACE__ . "\\__darwin_nl_item_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr", __NAMESPACE__ . "\\__darwin_nl_item_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_nl_item_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_nl_item_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr", __NAMESPACE__ . "\\__darwin_wctrans_t_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr", __NAMESPACE__ . "\\__darwin_wctrans_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_wctrans_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_wctrans_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr", __NAMESPACE__ . "\\__darwin_wctype_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr", __NAMESPACE__ . "\\__darwin_wctype_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_wctype_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_wctype_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr", __NAMESPACE__ . "\\pid_t_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr", __NAMESPACE__ . "\\pid_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr", __NAMESPACE__ . "\\pid_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\pid_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr", __NAMESPACE__ . "\\id_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr", __NAMESPACE__ . "\\id_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr", __NAMESPACE__ . "\\id_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\id_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr", __NAMESPACE__ . "\\sig_atomic_t_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr", __NAMESPACE__ . "\\sig_atomic_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr", __NAMESPACE__ . "\\sig_atomic_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\sig_atomic_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct___darwin_fp_control", __NAMESPACE__ . "\\__darwin_fp_control_t");
\class_alias(__NAMESPACE__ . "\\struct___darwin_fp_control_ptr", __NAMESPACE__ . "\\__darwin_fp_control_t_ptr");
\class_alias(__NAMESPACE__ . "\\struct___darwin_fp_control_ptr_ptr", __NAMESPACE__ . "\\__darwin_fp_control_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct___darwin_fp_control_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_fp_control_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct___darwin_fp_control_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_fp_control_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct___darwin_fp_status", __NAMESPACE__ . "\\__darwin_fp_status_t");
\class_alias(__NAMESPACE__ . "\\struct___darwin_fp_status_ptr", __NAMESPACE__ . "\\__darwin_fp_status_t_ptr");
\class_alias(__NAMESPACE__ . "\\struct___darwin_fp_status_ptr_ptr", __NAMESPACE__ . "\\__darwin_fp_status_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct___darwin_fp_status_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_fp_status_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct___darwin_fp_status_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\__darwin_fp_status_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct___darwin_mcontext64_ptr", __NAMESPACE__ . "\\mcontext_t");
\class_alias(__NAMESPACE__ . "\\struct___darwin_mcontext64_ptr_ptr", __NAMESPACE__ . "\\mcontext_t_ptr");
\class_alias(__NAMESPACE__ . "\\struct___darwin_mcontext64_ptr_ptr_ptr", __NAMESPACE__ . "\\mcontext_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct___darwin_mcontext64_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\mcontext_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_attr_t", __NAMESPACE__ . "\\pthread_attr_t");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_attr_t_ptr", __NAMESPACE__ . "\\pthread_attr_t_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_attr_t_ptr_ptr", __NAMESPACE__ . "\\pthread_attr_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_attr_t_ptr_ptr_ptr", __NAMESPACE__ . "\\pthread_attr_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct__opaque_pthread_attr_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\pthread_attr_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct___darwin_sigaltstack", __NAMESPACE__ . "\\stack_t");
\class_alias(__NAMESPACE__ . "\\struct___darwin_sigaltstack_ptr", __NAMESPACE__ . "\\stack_t_ptr");
\class_alias(__NAMESPACE__ . "\\struct___darwin_sigaltstack_ptr_ptr", __NAMESPACE__ . "\\stack_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct___darwin_sigaltstack_ptr_ptr_ptr", __NAMESPACE__ . "\\stack_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct___darwin_sigaltstack_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\stack_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct___darwin_ucontext", __NAMESPACE__ . "\\ucontext_t");
\class_alias(__NAMESPACE__ . "\\struct___darwin_ucontext_ptr", __NAMESPACE__ . "\\ucontext_t_ptr");
\class_alias(__NAMESPACE__ . "\\struct___darwin_ucontext_ptr_ptr", __NAMESPACE__ . "\\ucontext_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct___darwin_ucontext_ptr_ptr_ptr", __NAMESPACE__ . "\\ucontext_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct___darwin_ucontext_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\ucontext_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr", __NAMESPACE__ . "\\sigset_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr", __NAMESPACE__ . "\\sigset_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr", __NAMESPACE__ . "\\sigset_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\sigset_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr", __NAMESPACE__ . "\\uid_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr", __NAMESPACE__ . "\\uid_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr", __NAMESPACE__ . "\\uid_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\uid_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct___siginfo", __NAMESPACE__ . "\\siginfo_t");
\class_alias(__NAMESPACE__ . "\\struct___siginfo_ptr", __NAMESPACE__ . "\\siginfo_t_ptr");
\class_alias(__NAMESPACE__ . "\\struct___siginfo_ptr_ptr", __NAMESPACE__ . "\\siginfo_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct___siginfo_ptr_ptr_ptr", __NAMESPACE__ . "\\siginfo_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct___siginfo_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\siginfo_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\function_type_ptr", __NAMESPACE__ . "\\sig_t");
\class_alias(__NAMESPACE__ . "\\function_type_ptr_ptr", __NAMESPACE__ . "\\sig_t_ptr");
\class_alias(__NAMESPACE__ . "\\function_type_ptr_ptr_ptr", __NAMESPACE__ . "\\sig_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\function_type_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\sig_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr", __NAMESPACE__ . "\\rlim_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr", __NAMESPACE__ . "\\rlim_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr_ptr", __NAMESPACE__ . "\\rlim_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_long_long_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\rlim_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\void_ptr", __NAMESPACE__ . "\\rusage_info_t");
\class_alias(__NAMESPACE__ . "\\void_ptr_ptr", __NAMESPACE__ . "\\rusage_info_t_ptr");
\class_alias(__NAMESPACE__ . "\\void_ptr_ptr_ptr", __NAMESPACE__ . "\\rusage_info_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\void_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\rusage_info_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct_rusage_info_v5", __NAMESPACE__ . "\\rusage_info_current");
\class_alias(__NAMESPACE__ . "\\struct_rusage_info_v5_ptr", __NAMESPACE__ . "\\rusage_info_current_ptr");
\class_alias(__NAMESPACE__ . "\\struct_rusage_info_v5_ptr_ptr", __NAMESPACE__ . "\\rusage_info_current_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct_rusage_info_v5_ptr_ptr_ptr", __NAMESPACE__ . "\\rusage_info_current_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\struct_rusage_info_v5_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\rusage_info_current_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr", __NAMESPACE__ . "\\ct_rune_t_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr", __NAMESPACE__ . "\\ct_rune_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr", __NAMESPACE__ . "\\ct_rune_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\ct_rune_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr", __NAMESPACE__ . "\\rune_t_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr", __NAMESPACE__ . "\\rune_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr", __NAMESPACE__ . "\\rune_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\rune_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr", __NAMESPACE__ . "\\wchar_t_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr", __NAMESPACE__ . "\\wchar_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr", __NAMESPACE__ . "\\wchar_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\wchar_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr", __NAMESPACE__ . "\\dev_t_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr", __NAMESPACE__ . "\\dev_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr", __NAMESPACE__ . "\\dev_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\dev_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_short_ptr", __NAMESPACE__ . "\\mode_t_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_short_ptr_ptr", __NAMESPACE__ . "\\mode_t_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_short_ptr_ptr_ptr", __NAMESPACE__ . "\\mode_t_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\unsigned_short_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\mode_t_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int32_t_ptr", __NAMESPACE__ . "\\ExtismPlugin_ptr");
\class_alias(__NAMESPACE__ . "\\int32_t_ptr_ptr", __NAMESPACE__ . "\\ExtismPlugin_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int32_t_ptr_ptr_ptr", __NAMESPACE__ . "\\ExtismPlugin_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\int32_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\ExtismPlugin_ptr_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr", __NAMESPACE__ . "\\ExtismSize_ptr");
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr_ptr", __NAMESPACE__ . "\\ExtismSize_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr_ptr_ptr", __NAMESPACE__ . "\\ExtismSize_ptr_ptr_ptr");
\class_alias(__NAMESPACE__ . "\\uint64_t_ptr_ptr_ptr_ptr", __NAMESPACE__ . "\\ExtismSize_ptr_ptr_ptr_ptr");